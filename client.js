! function() {
    "use strict";
    var t, e, i, s, n, a;
    let r = new Map,
        l = new Map,
        o = new Map,
        c = new Map,
        d = new Map,
        u = new Map,
        $ = new Map,
        h = new Map,
        m = new Map,
        _ = new Map,
        f = new Map,
        p = new Map,
        g = new Map,
        v = new Map,
        y = new Map,
        b = new Map,
        x = [],
        w = t => {
            t.files.forEach(t => c.set(t.id, t)), t.particles.forEach(t => r.set(t.id, t)), t.effects.forEach(t => l.set(t.id, t)), t.sounds.forEach(t => o.set(t.id, t)), t.meshes.forEach(t => d.set(t.id, t)), t.ribbons.forEach(t => u.set(t.id, t)), t.terrains.forEach(t => $.set(t.id, t)), t.animations.forEach(t => h.set(t.id, t)), t.skins.forEach(t => m.set(t.id, t)), t.skeletons.forEach(t => _.set(t.id, t)), t.creatures.forEach(t => f.set(t.id, t)), t.creaturesMonster.forEach(t => p.set(t.id, t)), t.creaturesConjurer.forEach(t => g.set(t.id, t)), t.creaturesTrader.forEach(t => v.set(t.id, t)), t.traderShopItems.forEach(t => y.set(t.id, t)), t.worlds.forEach(t => b.set(t.id, t)), x.push(...t.filesExt)
        },
        k = (t, e = !1) => {
            if (!c.has(t)) return console.log("unknown file id: " + t), "";
            let i = c.get(t);
            return `${t}.${2===i.ext&&e?"webp":x[i.ext]}`
        };

    function C() {}
    let S = t => t;

    function E(t, e) {
        for (let i in e) t[i] = e[i];
        return t
    }

    function P(t) {
        return t()
    }

    function M() {
        return Object.create(null)
    }

    function D(t) {
        t.forEach(P)
    }

    function T(t) {
        return "function" == typeof t
    }

    function A(t, e) {
        return t != t ? e == e : t !== e || t && "object" == typeof t || "function" == typeof t
    }

    function R(t, e) {
        return t != t ? e == e : t !== e
    }

    function F(t, ...e) {
        if (null == t) return C;
        let i = t.subscribe(...e);
        return i.unsubscribe ? () => i.unsubscribe() : i
    }

    function N(t, e, i) {
        t.$$.on_destroy.push(F(e, i))
    }

    function I(t, e, i, s) {
        if (t) {
            let n = U(t, e, i, s);
            return t[0](n)
        }
    }

    function U(t, e, i, s) {
        return t[1] && s ? E(i.ctx.slice(), t[1](s(e))) : i.ctx
    }

    function z(t, e, i, s, n, a, r) {
        let l = function t(e, i, s, n) {
            if (e[2] && n) {
                let a = e[2](n(s));
                if (void 0 === i.dirty) return a;
                if ("object" == typeof a) {
                    let r = [],
                        l = Math.max(i.dirty.length, a.length);
                    for (let o = 0; o < l; o += 1) r[o] = i.dirty[o] | a[o];
                    return r
                }
                return i.dirty | a
            }
            return i.dirty
        }(e, s, n, a);
        if (l) {
            let o = U(e, i, s, r);
            t.p(o, l)
        }
    }

    function O(t) {
        return null == t ? "" : t
    }

    function L(t, e, i = e) {
        return t.set(i), e
    }
    let B = "undefined" != typeof window,
        q = B ? () => window.performance.now() : () => Date.now(),
        V = B ? t => requestAnimationFrame(t) : C,
        W = new Set;

    function H(t) {
        W.forEach(e => {
            e.c(t) || (W.delete(e), e.f())
        }), 0 !== W.size && V(H)
    }

    function j(t) {
        let e;
        return 0 === W.size && V(H), {
            promise: new Promise(i => {
                W.add(e = {
                    c: t,
                    f: i
                })
            }),
            abort() {
                W.delete(e)
            }
        }
    }

    function G(t, e) {
        t.appendChild(e)
    }

    function Y(t, e, i) {
        t.insertBefore(e, i || null)
    }

    function Q(t) {
        t.parentNode.removeChild(t)
    }

    function X(t, e) {
        for (let i = 0; i < t.length; i += 1) t[i] && t[i].d(e)
    }

    function J(t) {
        return document.createElement(t)
    }

    function K(t) {
        return document.createTextNode(t)
    }

    function Z() {
        return K(" ")
    }

    function tt() {
        return K("")
    }

    function te(t, e, i, s) {
        return t.addEventListener(e, i, s), () => t.removeEventListener(e, i, s)
    }

    function ti(t, e, i) {
        null == i ? t.removeAttribute(e) : t.getAttribute(e) !== i && t.setAttribute(e, i)
    }

    function ts(t) {
        return "" === t ? void 0 : +t
    }

    function tn(t, e) {
        e = "" + e, t.wholeText !== e && (t.data = e)
    }

    function ta(t, e) {
        t.value = null == e ? "" : e
    }

    function tr(t, e, i, s) {
        t.style.setProperty(e, i, s ? "important" : "")
    }

    function tl(t, e) {
        for (let i = 0; i < t.options.length; i += 1) {
            let s = t.options[i];
            if (s.__value === e) return void(s.selected = !0)
        }
    }

    function to(t) {
        let e = t.querySelector(":checked") || t.options[0];
        return e && e.__value
    }

    function tc(t, e) {
        let i = document.createEvent("CustomEvent");
        return i.initCustomEvent(t, !1, !1, e), i
    }
    class td {
        constructor(t = null) {
            this.a = t, this.e = this.n = null
        }
        m(t, e, i = null) {
            this.e || (this.e = J(e.nodeName), this.t = e, this.h(t)), this.i(i)
        }
        h(t) {
            this.e.innerHTML = t, this.n = Array.from(this.e.childNodes)
        }
        i(t) {
            for (let e = 0; e < this.n.length; e += 1) Y(this.t, this.n[e], t)
        }
        p(t) {
            this.d(), this.h(t), this.i(this.a)
        }
        d() {
            this.n.forEach(Q)
        }
    }
    let tu = new Set,
        t$, th = 0;

    function tm(t, e, i, s, n, a, r, l = 0) {
        let o = 16.666 / s,
            c = "{\n";
        for (let d = 0; d <= 1; d += o) {
            let u = e + (i - e) * a(d);
            c += 100 * d + `%{${r(u,1-u)}}
`
        }
        let $ = c + `100% {${r(i,1-i)}}
}`,
            h = `__svelte_${function t(e){let i=5381,s=e.length;for(;s--;)i=(i<<5)-i^e.charCodeAt(s);return i>>>0}($)}_${l}`,
            m = t.ownerDocument;
        tu.add(m);
        let _ = m.__svelte_stylesheet || (m.__svelte_stylesheet = m.head.appendChild(J("style")).sheet),
            f = m.__svelte_rules || (m.__svelte_rules = {});
        f[h] || (f[h] = !0, _.insertRule(`@keyframes ${h} ${$}`, _.cssRules.length));
        let p = t.style.animation || "";
        return t.style.animation = `${p?p+", ":""}${h} ${s}ms linear ${n}ms 1 both`, th += 1, h
    }

    function t_(t, e) {
        let i = (t.style.animation || "").split(", "),
            s = i.filter(e ? t => 0 > t.indexOf(e) : t => -1 === t.indexOf("__svelte")),
            n = i.length - s.length;
        n && (t.style.animation = s.join(", "), (th -= n) || V(() => {
            th || (tu.forEach(t => {
                let e = t.__svelte_stylesheet,
                    i = e.cssRules.length;
                for (; i--;) e.deleteRule(i);
                t.__svelte_rules = {}
            }), tu.clear())
        }))
    }

    function tf(t) {
        t$ = t
    }

    function tp() {
        if (!t$) throw Error("Function called outside component initialization");
        return t$
    }

    function tg(t) {
        tp().$$.on_mount.push(t)
    }

    function tv(t) {
        tp().$$.after_update.push(t)
    }

    function ty(t) {
        tp().$$.on_destroy.push(t)
    }

    function t0() {
        let t = tp();
        return (e, i) => {
            let s = t.$$.callbacks[e];
            if (s) {
                let n = tc(e, i);
                s.slice().forEach(e => {
                    e.call(t, n)
                })
            }
        }
    }

    function tb(t, e) {
        let i = t.$$.callbacks[e.type];
        i && i.slice().forEach(t => t(e))
    }
    let tx = [],
        tw = [],
        t1 = [],
        t9 = [],
        t3 = Promise.resolve(),
        tk = !1;

    function t2() {
        tk || (tk = !0, t3.then(tE))
    }

    function t4(t) {
        t1.push(t)
    }

    function tC(t) {
        t9.push(t)
    }
    let tS = !1,
        t7 = new Set;

    function tE() {
        if (!tS) {
            tS = !0;
            do {
                for (let t = 0; t < tx.length; t += 1) {
                    var e;
                    let i = tx[t];
                    t$ = i, t6(i.$$)
                }
                for (tx.length = 0; tw.length;) tw.pop()();
                for (let s = 0; s < t1.length; s += 1) {
                    let n = t1[s];
                    t7.has(n) || (t7.add(n), n())
                }
                t1.length = 0
            } while (tx.length);
            for (; t9.length;) t9.pop()();
            tk = !1, tS = !1, t7.clear()
        }
    }

    function t6(t) {
        if (null !== t.fragment) {
            t.update(), D(t.before_update);
            let e = t.dirty;
            t.dirty = [-1], t.fragment && t.fragment.p(t.ctx, e), t.after_update.forEach(t4)
        }
    }
    let tP;

    function tM() {
        return tP || (tP = Promise.resolve()).then(() => {
            tP = null
        }), tP
    }

    function t5(t, e, i) {
        t.dispatchEvent(tc(`${e?"intro":"outro"}${i}`))
    }
    let tD = new Set,
        tT;

    function tA() {
        tT = {
            r: 0,
            c: [],
            p: tT
        }
    }

    function t8() {
        tT.r || D(tT.c), tT = tT.p
    }

    function tR(t, e) {
        t && t.i && (tD.delete(t), t.i(e))
    }

    function tF(t, e, i, s) {
        t && t.o && !tD.has(t) && (tD.add(t), tT.c.push(() => {
            tD.delete(t), s && (i && t.d(1), s())
        }), t.o(e))
    }
    let tN = {
        duration: 0
    };

    function tI(t, e, i, s) {
        let n = e(t, i),
            a = s ? 0 : 1,
            r = null,
            l = null,
            o = null;

        function c() {
            o && t_(t, o)
        }

        function d(t, e) {
            let i = t.b - a;
            return e *= Math.abs(i), {
                a: a,
                b: t.b,
                d: i,
                duration: e,
                start: t.start,
                end: t.start + e,
                group: t.group
            }
        }

        function u(e) {
            let {
                delay: i = 0,
                duration: s = 300,
                easing: u = S,
                tick: $ = C,
                css: h
            } = n || tN, m = {
                start: q() + i,
                b: e
            };
            e || (m.group = tT, tT.r += 1), r ? l = m : (h && (c(), o = tm(t, a, e, s, i, u, h)), e && $(0, 1), r = d(m, s), t4(() => t5(t, e, "start")), j(e => {
                if (l && e > l.start && (r = d(l, s), l = null, t5(t, r.b, "start"), h && (c(), o = tm(t, a, r.b, r.duration, 0, u, n.css))), r) {
                    if (e >= r.end) $(a = r.b, 1 - a), t5(t, r.b, "end"), l || (r.b ? c() : --r.group.r || D(r.group.c)), r = null;
                    else if (e >= r.start) {
                        let i = e - r.start;
                        $(a = r.a + r.d * u(i / r.duration), 1 - a)
                    }
                }
                return !(!r && !l)
            }))
        }
        return {
            run(t) {
                T(n) ? tM().then(() => {
                    n = n(), u(t)
                }) : u(t)
            },
            end() {
                c(), r = l = null
            }
        }
    }
    let tU = "undefined" != typeof window ? window : "undefined" != typeof globalThis ? globalThis : global;

    function tz(t, e) {
        t.d(1), e.delete(t.key)
    }

    function tO(t, e) {
        tF(t, 1, 1, () => {
            e.delete(t.key)
        })
    }

    function tL(t, e, i, s, n, a, r, l, o, c, d, u) {
        let $ = t.length,
            h = a.length,
            m = $,
            _ = {};
        for (; m--;) _[t[m].key] = m;
        let f = [],
            p = new Map,
            g = new Map;
        for (m = h; m--;) {
            let v = u(n, a, m),
                y = i(v),
                b = r.get(y);
            b ? s && b.p(v, e) : (b = c(y, v)).c(), p.set(y, f[m] = b), y in _ && g.set(y, Math.abs(m - _[y]))
        }
        let x = new Set,
            w = new Set;

        function k(t) {
            tR(t, 1), t.m(l, d), r.set(t.key, t), d = t.first, h--
        }
        for (; $ && h;) {
            let C = f[h - 1],
                S = t[$ - 1],
                E = C.key,
                P = S.key;
            C === S ? (d = C.first, $--, h--) : p.has(P) ? !r.has(E) || x.has(E) ? k(C) : w.has(P) ? $-- : g.get(E) > g.get(P) ? (w.add(E), k(C)) : (x.add(P), $--) : (o(S, r), $--)
        }
        for (; $--;) {
            let M = t[$];
            p.has(M.key) || o(M, r)
        }
        for (; h;) k(f[h - 1]);
        return f
    }

    function tB(t, e) {
        let i = {},
            s = {},
            n = {
                $$scope: 1
            },
            a = t.length;
        for (; a--;) {
            let r = t[a],
                l = e[a];
            if (l) {
                for (let o in r) o in l || (s[o] = 1);
                for (let c in l) n[c] || (i[c] = l[c], n[c] = 1);
                t[a] = l
            } else
                for (let d in r) n[d] = 1
        }
        for (let u in s) u in i || (i[u] = void 0);
        return i
    }

    function tq(t) {
        return "object" == typeof t && null !== t ? t : {}
    }

    function tV(t, e, i) {
        let s = t.$$.props[e];
        void 0 !== s && (t.$$.bound[s] = i, i(t.$$.ctx[s]))
    }

    function tW(t) {
        t && t.c()
    }

    function tH(t, e, i) {
        let {
            fragment: s,
            on_mount: n,
            on_destroy: a,
            after_update: r
        } = t.$$;
        s && s.m(e, i), t4(() => {
            let e = n.map(P).filter(T);
            a ? a.push(...e) : D(e), t.$$.on_mount = []
        }), r.forEach(t4)
    }

    function tj(t, e) {
        let i = t.$$;
        null !== i.fragment && (D(i.on_destroy), i.fragment && i.fragment.d(e), i.on_destroy = i.fragment = null, i.ctx = [])
    }

    function tG(t, e, i, s, n, a, r = [-1]) {
        var l, o, c;
        let d = t$;
        t$ = l = t;
        let u = e.props || {},
            $ = t.$$ = {
                fragment: null,
                ctx: null,
                props: a,
                update: C,
                not_equal: n,
                bound: M(),
                on_mount: [],
                on_destroy: [],
                before_update: [],
                after_update: [],
                context: new Map(d ? d.$$.context : []),
                callbacks: M(),
                dirty: r,
                skip_bound: !1
            },
            h = !1;
        if ($.ctx = i ? i(t, u, (e, i, ...s) => {
                var a, r;
                let l = s.length ? s[0] : i;
                return $.ctx && n($.ctx[e], $.ctx[e] = l) && (!$.skip_bound && $.bound[e] && $.bound[e](l), h && (a = t, r = e, -1 === a.$$.dirty[0] && (tx.push(a), t2(), a.$$.dirty.fill(0)), a.$$.dirty[r / 31 | 0] |= 1 << r % 31)), i
            }) : [], $.update(), h = !0, D($.before_update), $.fragment = !!s && s($.ctx), e.target) {
            if (e.hydrate) {
                let m = Array.from((o = e.target).childNodes);
                $.fragment && $.fragment.l(m), m.forEach(Q)
            } else $.fragment && $.fragment.c();
            e.intro && tR(t.$$.fragment), tH(t, e.target, e.anchor), tE()
        }
        t$ = c = d
    }
    class tY {
        $destroy() {
            tj(this, 1), this.$destroy = C
        }
        $on(t, e) {
            let i = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
            return i.push(e), () => {
                let t = i.indexOf(e); - 1 !== t && i.splice(t, 1)
            }
        }
        $set(t) {
            var e;
            this.$$set && 0 !== Object.keys(e = t).length && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1)
        }
    }
    let tQ = [];

    function tX(t, e = C) {
        let i, s = [];

        function n(e) {
            if (A(t, e) && (t = e, i)) {
                let n = !tQ.length;
                for (let a = 0; a < s.length; a += 1) {
                    let r = s[a];
                    r[1](), tQ.push(r, t)
                }
                if (n) {
                    for (let l = 0; l < tQ.length; l += 2) tQ[l][0](tQ[l + 1]);
                    tQ.length = 0
                }
            }
        }
        return {
            set: n,
            update: function e(i) {
                n(i(t))
            },
            subscribe: function a(r, l = C) {
                let o = [r, l];
                return s.push(o), 1 === s.length && (i = e(n) || C), r(t), () => {
                    let t = s.indexOf(o); - 1 !== t && s.splice(t, 1), 0 === s.length && (i(), i = null)
                }
            }
        }
    }
    let tJ = tX([]),
        tK = tX({}),
        tZ = tX([]),
        et = tX(),
        ee = tX([]),
        ei = tX({}),
        es = tX(),
        en = tX(!1),
        ea = tX(),
        er = tX(!1),
        el = tX("Loading"),
        eo = tX([]),
        ec = tX({}),
        ed = tX({}),
        eu = tX([]),
        e$ = tX([]),
        eh = tX(),
        em = tX("auto"),
        e_ = tX(0),
        ef = tX(0),
        ep = tX(0),
        eg = tX([]),
        ev = tX({}),
        ey = tX({}),
        e0 = tX({
            current: 0,
            max: 1
        }),
        eb = tX(),
        ex = tX(),
        ew = tX(!1),
        e1 = tX(0),
        e9 = tX([0, 0]),
        e3 = tX(),
        ek = tX(),
        e2 = tX(!1),
        e4 = tX(new Map),
        eC = tX(new Map),
        eS = tX(),
        e7 = tX(),
        eE = tX(),
        e6 = tX([]),
        eP = tX(),
        eM = tX(0),
        e5 = tX(!1),
        eD = tX(!1),
        eT = tX(),
        eA = tX([]),
        e8 = tX(),
        eR = tX(),
        eF = tX(),
        eN = tX(),
        eI = tX({}),
        eU = tX({}),
        ez = tX(),
        eO = tX(),
        eL = [],
        eB = tX(""),
        eq = tX(0),
        eV = tX(35),
        eW = tX(90),
        eH = tX(50),
        ej = tX(2),
        eG = tX(!1),
        eY = tX(!0),
        eQ = tX(!0),
        eX = tX(!0),
        eJ = tX(!0),
        eK = tX(!0),
        eZ = tX(!0),
        it = tX(2),
        ie = tX(!0),
        ii = tX(!0),
        is = tX(50),
        ia = tX(65),
        ir = tX(50),
        il = tX(20),
        io = tX("en"),
        ic = tX("global"),
        id = tX(8),
        iu = tX(300),
        i$ = tX(5),
        ih = tX(!1),
        im = tX(!1),
        i_ = tX(!1),
        ip = tX(!1),
        ig = tX(!0),
        iv = tX(!1),
        iy = tX(!1),
        i0 = tX(!1),
        ib = tX(!0),
        ix = tX(0),
        iw = tX(0),
        i1 = tX(!1),
        i9 = tX({}),
        i3 = tX([0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1]),
        ik = tX(7),
        i2 = tX(!1),
        i4 = tX(100),
        iC = tX(!0),
        iS = tX(!0),
        i7 = tX(!0),
        iE = tX(!0),
        i6 = tX(!0),
        iP = tX(!0),
        iM = tX(!0),
        i5 = tX(!1),
        iD = tX(!0),
        iT = tX(!1),
        iA = tX(!0),
        i8 = tX(!1),
        iR = tX(0),
        iF = tX(!0),
        iN = tX(!0),
        iI = tX(!0),
        iU = tX(!0),
        iz = tX([]),
        iO = tX(""),
        iL = tX(0),
        iB = tX(!1),
        iq = tX(!1),
        iV = tX(70),
        iW = tX(!0),
        iH = tX(!0),
        ij = tX(.5),
        iG = tX(3),
        iY = tX(!0),
        iQ = tX(200),
        iX = tX(!0),
        iJ = tX(!1),
        iK = tX(14),
        iZ = tX(8),
        st = tX(!1),
        se = tX(1),
        si = tX(!1),
        ss = tX(!1),
        sn = tX(!0),
        sa = tX(!0),
        sr = tX("w"),
        sl = tX("arrowleft"),
        so = tX("arrowright"),
        sc = tX("arrowup"),
        sd = tX("arrowdown"),
        su = tX("a"),
        s$ = tX("s"),
        sh = tX("d"),
        sm = tX("tab"),
        s_ = tX("escape"),
        sf = tX("m"),
        sp = tX("k"),
        sg = tX("c"),
        sv = tX("b"),
        sy = tX("g"),
        s0 = tX("v"),
        sb = tX(12),
        sx = tX("1"),
        sw = tX("2"),
        s1 = tX("3"),
        s9 = tX("4"),
        s3 = tX("5"),
        sk = tX("6"),
        s2 = tX("7"),
        s4 = tX("8"),
        sC = tX("9"),
        sS = tX("0"),
        s7 = tX("o"),
        sE = tX("p"),
        s6 = tX(""),
        sP = tX(""),
        sM = tX(""),
        s5 = tX(""),
        sD = tX(""),
        sT = tX(""),
        sA = tX(""),
        s8 = tX(""),
        sR = tX(""),
        sF = tX(""),
        sN = tX(""),
        sI = tX(""),
        sU;
    sU = {
        ...Object.freeze({
            __proto__: null,
            activeWorld: eB,
            lastConnectedChar: eq,
            viewRange: eV,
            resolution: eW,
            foliage: eH,
            shadowmapResolution: ej,
            realtimeShadows: eG,
            fxaa: eY,
            disableoffscreen: eQ,
            shadows: eX,
            bloom: eJ,
            clouds: eK,
            particles: eZ,
            anisotropy: it,
            fogpattern: ie,
            shadowscreature: ii,
            ambienceVolume: is,
            audioVolume: ia,
            audioVolumeLowered: ir,
            musicVolume: il,
            lang: io,
            command: ic,
            stashCols: id,
            stashHeight: iu,
            inventoryCols: i$,
            inventoryOpen: ih,
            settingsOpen: im,
            skillmenuOpen: i_,
            dpsmeterOpen: ip,
            twitchOpen: ig,
            subscriptionOpen: iv,
            clanOpen: iy,
            pvpOpen: i0,
            dpsmeterParty: ib,
            dpsmeterMode: ix,
            dpsmeterTarget: iw,
            charpanelOpen: i1,
            skillbarsettings: i9,
            chat: i3,
            cameraZoom: ik,
            editorActive: i2,
            nameplateViewRange: i4,
            nameplateShowMonsters: iC,
            nameplateShowFriendlyPlayers: iS,
            nameplateShowEnemyPlayers: i7,
            nameShowMonsters: iE,
            nameShowFriendlyPlayers: i6,
            nameShowEnemyPlayers: iP,
            nameplateShowTransparency: iM,
            alwaysShowLevel: i5,
            combatTextPush: iD,
            classColorBars: iT,
            mapShowMonsters: iA,
            mapLowQuality: i8,
            tutprogress: iR,
            chatbubbles: iF,
            showIncomingHeal: iN,
            showIncomingDamage: iI,
            showIncomingMana: iU,
            filteredChannels: iz,
            itemTypeFilter: iO,
            itemQualityFilter: iL,
            itemQualityPercent: iB,
            showFpsPing: iq,
            itemProtectQuality: iV,
            cdTextSkills: iW,
            cdTextBuffs: iH,
            buffCdFlashingInterval: ij,
            buffCdFlashingDuration: iG,
            partyBuffLimitUpdateRate: iY,
            partyWidth: iQ,
            showSelfInParty: iX,
            showPartyMana: iJ,
            buffcountUnitframes: iK,
            buffcountParty: iZ,
            buffsHideIrrelevant: st,
            mouseSensitivity: se,
            invertMouseX: si,
            invertMouseY: ss,
            lockedcamera: sn,
            pointerlock: sa,
            kbForward: sr,
            kbTurnLeft: sl,
            kbTurnRight: so,
            kbAltForward: sc,
            kbAltBack: sd,
            kbLeft: su,
            kbBack: s$,
            kbRight: sh,
            kbNextTarget: sm,
            kbUntarget: s_,
            kbMap: sf,
            kbSkills: sp,
            kbCharacter: sg,
            kbInventory: sv,
            kbClan: sy,
            kbPvp: s0,
            skillbarAmount: sb,
            kbSkillbar1: sx,
            kbSkillbar2: sw,
            kbSkillbar3: s1,
            kbSkillbar4: s9,
            kbSkillbar5: s3,
            kbSkillbar6: sk,
            kbSkillbar7: s2,
            kbSkillbar8: s4,
            kbSkillbar9: sC,
            kbSkillbar10: sS,
            kbSkillbar11: s7,
            kbSkillbar12: sE,
            kbSkillbar13: s6,
            kbSkillbar14: sP,
            kbSkillbar15: sM,
            kbSkillbar16: s5,
            kbSkillbar17: sD,
            kbSkillbar18: sT,
            kbSkillbar19: sA,
            kbSkillbar20: s8,
            kbSkillbar21: sR,
            kbSkillbar22: sF,
            kbSkillbar23: sN,
            kbSkillbar24: sI
        })
    };
    let sz = (t, e) => {
            let i = localStorage.getItem(t),
                s = JSON.parse("undefined" == i ? null : i);
            null !== s && e.set(s), e.subscribe(e => {
                sO[t] = e, localStorage.setItem(t, JSON.stringify(e))
            })
        },
        sO = {};
    for (let sL in sU) sz(sL, sU[sL]);
    let sB = Object.freeze({
        __proto__: null,
        registerSetting: sz,
        current: sO,
        activeWorld: eB,
        lastConnectedChar: eq,
        viewRange: eV,
        resolution: eW,
        foliage: eH,
        shadowmapResolution: ej,
        realtimeShadows: eG,
        fxaa: eY,
        disableoffscreen: eQ,
        shadows: eX,
        bloom: eJ,
        clouds: eK,
        particles: eZ,
        anisotropy: it,
        fogpattern: ie,
        shadowscreature: ii,
        ambienceVolume: is,
        audioVolume: ia,
        audioVolumeLowered: ir,
        musicVolume: il,
        lang: io,
        command: ic,
        stashCols: id,
        stashHeight: iu,
        inventoryCols: i$,
        inventoryOpen: ih,
        settingsOpen: im,
        skillmenuOpen: i_,
        dpsmeterOpen: ip,
        twitchOpen: ig,
        subscriptionOpen: iv,
        clanOpen: iy,
        pvpOpen: i0,
        dpsmeterParty: ib,
        dpsmeterMode: ix,
        dpsmeterTarget: iw,
        charpanelOpen: i1,
        skillbarsettings: i9,
        chat: i3,
        cameraZoom: ik,
        editorActive: i2,
        nameplateViewRange: i4,
        nameplateShowMonsters: iC,
        nameplateShowFriendlyPlayers: iS,
        nameplateShowEnemyPlayers: i7,
        nameShowMonsters: iE,
        nameShowFriendlyPlayers: i6,
        nameShowEnemyPlayers: iP,
        nameplateShowTransparency: iM,
        alwaysShowLevel: i5,
        combatTextPush: iD,
        classColorBars: iT,
        mapShowMonsters: iA,
        mapLowQuality: i8,
        tutprogress: iR,
        chatbubbles: iF,
        showIncomingHeal: iN,
        showIncomingDamage: iI,
        showIncomingMana: iU,
        filteredChannels: iz,
        itemTypeFilter: iO,
        itemQualityFilter: iL,
        itemQualityPercent: iB,
        showFpsPing: iq,
        itemProtectQuality: iV,
        cdTextSkills: iW,
        cdTextBuffs: iH,
        buffCdFlashingInterval: ij,
        buffCdFlashingDuration: iG,
        partyBuffLimitUpdateRate: iY,
        partyWidth: iQ,
        showSelfInParty: iX,
        showPartyMana: iJ,
        buffcountUnitframes: iK,
        buffcountParty: iZ,
        buffsHideIrrelevant: st,
        mouseSensitivity: se,
        invertMouseX: si,
        invertMouseY: ss,
        lockedcamera: sn,
        pointerlock: sa,
        kbForward: sr,
        kbTurnLeft: sl,
        kbTurnRight: so,
        kbAltForward: sc,
        kbAltBack: sd,
        kbLeft: su,
        kbBack: s$,
        kbRight: sh,
        kbNextTarget: sm,
        kbUntarget: s_,
        kbMap: sf,
        kbSkills: sp,
        kbCharacter: sg,
        kbInventory: sv,
        kbClan: sy,
        kbPvp: s0,
        skillbarAmount: sb,
        kbSkillbar1: sx,
        kbSkillbar2: sw,
        kbSkillbar3: s1,
        kbSkillbar4: s9,
        kbSkillbar5: s3,
        kbSkillbar6: sk,
        kbSkillbar7: s2,
        kbSkillbar8: s4,
        kbSkillbar9: sC,
        kbSkillbar10: sS,
        kbSkillbar11: s7,
        kbSkillbar12: sE,
        kbSkillbar13: s6,
        kbSkillbar14: sP,
        kbSkillbar15: sM,
        kbSkillbar16: s5,
        kbSkillbar17: sD,
        kbSkillbar18: sT,
        kbSkillbar19: sA,
        kbSkillbar20: s8,
        kbSkillbar21: sR,
        kbSkillbar22: sF,
        kbSkillbar23: sN,
        kbSkillbar24: sI
    });

    function sq(t) {
        let e = t[0],
            i = t[1],
            s = t[2];
        return Math.sqrt(e * e + i * i + s * s)
    }

    function sV(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t
    }

    function sW(t, e, i, s) {
        return t[0] = e, t[1] = i, t[2] = s, t
    }

    function sH(t, e) {
        return t[0] = e, t[1] = e, t[2] = e, t
    }

    function sj(t, e, i) {
        return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t[2] = e[2] + i[2], t
    }

    function sG(t, e, i, s) {
        return t[0] += e, t[1] += i, t[2] += s, t
    }

    function sY(t, e, i) {
        return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t[2] = e[2] - i[2], t
    }

    function sQ(t, e, i) {
        return t[0] = e[0] * i, t[1] = e[1] * i, t[2] = e[2] * i, t
    }

    function sX(t, e, i, s) {
        return t[0] = e[0] + i[0] * s, t[1] = e[1] + i[1] * s, t[2] = e[2] + i[2] * s, t
    }

    function sJ(t, e) {
        let i = e[0] - t[0],
            s = e[1] - t[1],
            n = e[2] - t[2];
        return Math.sqrt(i * i + s * s + n * n)
    }

    function sK(t, e) {
        let i = e[0] - t[0],
            s = e[1] - t[1],
            n = e[2] - t[2];
        return i * i + s * s + n * n
    }

    function sZ(t, e) {
        let i = e[0],
            s = e[1],
            n = e[2],
            a = i * i + s * s + n * n;
        return a > 0 && (a = 1 / Math.sqrt(a)), t[0] = e[0] * a, t[1] = e[1] * a, t[2] = e[2] * a, t
    }

    function nt(t, e) {
        return t[0] * e[0] + t[1] * e[1] + t[2] * e[2]
    }

    function ne(t, e, i) {
        let s = e[0],
            n = e[1],
            a = e[2],
            r = i[0],
            l = i[1],
            o = i[2];
        return t[0] = n * o - a * l, t[1] = a * r - s * o, t[2] = s * l - n * r, t
    }

    function ni(t, e, i) {
        let s = e[0],
            n = e[1],
            a = e[2],
            r = i[3] * s + i[7] * n + i[11] * a + i[15];
        return r = r || 1, t[0] = (i[0] * s + i[4] * n + i[8] * a + i[12]) / r, t[1] = (i[1] * s + i[5] * n + i[9] * a + i[13]) / r, t[2] = (i[2] * s + i[6] * n + i[10] * a + i[14]) / r, t
    }

    function ns(t, e, i, s, n) {
        return t[0] = n[0] * e + n[4] * i + n[8] * s + n[12], t[1] = n[1] * e + n[5] * i + n[9] * s + n[13], t[2] = n[2] * e + n[6] * i + n[10] * s + n[14], t
    }

    function nn(t, e, i) {
        let s = e[0],
            n = e[1],
            a = e[2],
            r = i[0],
            l = i[1],
            o = i[2],
            c = l * a - o * n,
            d = o * s - r * a,
            u = r * n - l * s,
            $ = l * u - o * d,
            h = o * c - r * u,
            m = r * d - l * c,
            _ = 2 * i[3];
        return c *= _, d *= _, u *= _, $ *= 2, h *= 2, m *= 2, t[0] = s + c + $, t[1] = n + d + h, t[2] = a + u + m, t
    }

    function na(t, e, i) {
        let s = Math.sin(i),
            n = Math.cos(i);
        return t[0] = e[2] * s + e[0] * n, t[1] = e[1], t[2] = e[2] * n - e[0] * s, t
    }
    let nr = [0, 0, 0],
        nl = 1,
        no = 1,
        nc = (t, e, i, s, n) => {
            if (t.length > 0) {
                sW(e, 1 / 0, 1 / 0, 1 / 0), sW(i, -1 / 0, -1 / 0, -1 / 0);
                for (let a = 0, r = t.length; a < r; a += 3) {
                    let l = t[a],
                        o = t[a + 1],
                        c = t[a + 2];
                    e[0] = Math.min(l, e[0]), e[1] = Math.min(o, e[1]), e[2] = Math.min(c, e[2]), i[0] = Math.max(l, i[0]), i[1] = Math.max(o, i[1]), i[2] = Math.max(c, i[2])
                }
            } else sW(e, 0, 0, 0), sW(i, -0, -0, -0);
            sY(n, i, e), sQ(s, sj(s, e, i), .5)
        };
    class nd {
        constructor(t, e = {}) {
            this.gl = t, this.attributes = e, this.id = nl++, this.drawRange = {
                start: 0,
                count: 0
            }, this.attrRange = 0, this.instancedCount = 0, this.isInstanced = !1, this.vao = {}, this.bounds = {
                min: [0, 0, 0],
                max: [0, 0, 0],
                center: [0, 0, 0],
                scale: [0, 0, 0],
                radius: 1 / 0,
                initiated: !1
            }, this.addAttributes(e)
        }
        addAttributes(t) {
            for (let e in this.gl.renderer.bindVertexArray(null), this.gl.renderer.currentGeometry = "", this.glState = this.gl.renderer.state, t) this.addAttribute(e, t[e]);
            this.attributes.position && this.computeBoundingSphere()
        }
        addAttribute(t, e) {
            if (this.attributes[t] = e, e.id = no++, e.size = e.size || 1, e.type = e.type || (e.data.constructor === Float32Array ? this.gl.FLOAT : e.data.constructor === Uint16Array ? this.gl.UNSIGNED_SHORT : this.gl.UNSIGNED_INT), e.target = "index" === t ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER, e.normalize = e.normalize || !1, e.buffer = this.gl.createBuffer(), e.count = e.data.length / e.size, e.divisor = e.instanced ? "number" == typeof e.instanced ? e.instanced : 1 : 0, e.needsUpdate = !1, e.bufferMode = e.bufferMode || this.gl.STATIC_DRAW, this.updateAttribute(e), e.divisor) {
                if (this.isInstanced = !0, this.instancedCount && this.instancedCount !== e.count * e.divisor) return console.warn("geometry has multiple instanced buffers of different length"), this.instancedCount = Math.min(this.instancedCount, e.count * e.divisor);
                this.instancedCount = e.count * e.divisor
            } else "index" === t ? this.drawRange.count = e.count : this.attributes.index || (this.drawRange.count = Math.max(this.drawRange.count, e.count))
        }
        updateAttribute(t) {
            this.glState.boundBuffer !== t.id && (this.gl.bindBuffer(t.target, t.buffer), this.glState.boundBuffer = t.id), this.gl.bufferData(t.target, t.data, t.bufferMode, 0, this.isInstanced ? this.instancedCount * t.size : this.attrRange * t.size), t.needsUpdate = !1
        }
        setIndex(t) {
            this.addAttribute("index", t)
        }
        setDrawRange(t, e) {
            this.attrRange = e, this.drawRange.start = t, this.drawRange.count = e
        }
        setInstancedCount(t) {
            this.instancedCount = t
        }
        createVAO(t) {
            this.vao[t.attributeOrder] = this.gl.renderer.createVertexArray(), this.gl.renderer.bindVertexArray(this.vao[t.attributeOrder]), this.bindAttributes(t)
        }
        bindAttributes(t) {
            for (let e = 0; e < t.attributeLocations.length; ++e) {
                let i = t.attributeLocations[e],
                    s = this.attributes[t.attributeNames[e]];
                if (this.gl.bindBuffer(this.gl.ARRAY_BUFFER, s.buffer), this.glState.boundBuffer = s.id, s.size > 4) {
                    let n = s.size / 4,
                        a = 4 * n,
                        r = 4 * a;
                    for (let l = 0; l < n; ++l) this.gl.vertexAttribPointer(i + l, n, this.gl.FLOAT, !1, r, a * l), this.gl.enableVertexAttribArray(i + l), this.gl.renderer.vertexAttribDivisor(i + l, 1)
                } else this.gl.vertexAttribPointer(i, s.size, s.type, s.normalize, 0, 0), this.gl.enableVertexAttribArray(i), this.gl.renderer.vertexAttribDivisor(i, s.divisor)
            }
            this.attributes.index && this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.attributes.index.buffer)
        }
        draw(t, e) {
            this.gl.renderer.currentGeometry === this.id && this.gl.renderer.currentAttributeOrder === t.attributeOrder || (this.vao[t.attributeOrder] || this.createVAO(t), this.gl.renderer.bindVertexArray(this.vao[t.attributeOrder]), this.gl.renderer.currentGeometry = this.id, this.gl.renderer.currentAttributeOrder = t.attributeOrder);
            for (let i = 0; i < t.attributeNames.length; ++i) {
                let s = this.attributes[t.attributeNames[i]];
                s.needsUpdate && this.updateAttribute(s)
            }
            this.isInstanced ? this.attributes.index ? this.gl.renderer.drawElementsInstanced(e, this.drawRange.count, this.attributes.index.type, this.drawRange.start, this.instancedCount) : this.gl.renderer.drawArraysInstanced(e, this.drawRange.start, this.drawRange.count, this.instancedCount) : this.attributes.index ? this.gl.drawElements(e, this.drawRange.count, this.attributes.index.type, this.drawRange.start) : this.gl.drawArrays(e, this.drawRange.start, this.drawRange.count)
        }
        computeBoundingBox() {
            nc(this.attributes.position.data, this.bounds.min, this.bounds.max, this.bounds.center, this.bounds.scale), this.bounds.initiated = !0
        }
        computeBoundingSphereRadius() {
            let t = 0;
            for (let e = 0, i = this.attributes.position.data.length; e < i; e += 3) nr[0] = this.attributes.position.data[e], nr[1] = this.attributes.position.data[e + 1], nr[2] = this.attributes.position.data[e + 2], t = Math.max(t, sK(this.bounds.center, nr));
            this.bounds.radius = Math.sqrt(t)
        }
        computeBoundingSphere() {
            this.bounds.initiated || this.computeBoundingBox(), this.computeBoundingSphereRadius()
        }
        remove() {
            for (let t in this.vao) this.gl.renderer.deleteVertexArray(this.vao[t]);
            for (let e in this.attributes) this.gl.deleteBuffer(this.attributes[e].buffer), delete this.attributes[e]
        }
    }
    let nu = 1;
    class n$ {
        constructor(t, {
            vertex: e,
            fragment: i,
            uniforms: s = {},
            instanced: n = [],
            active: a = !0,
            transparent: r = !1,
            cullFace: l = t.BACK,
            frontFace: o = t.CCW,
            depthTest: c = !0,
            depthWrite: d = !0,
            depthFunc: u = t.LESS,
            globalUniforms: $ = {}
        } = {}) {
            this.gl = t, this.uniforms = s, this.instancedAttributes = n, this.autoUniforms = [], this.id = nu++, this.active = a, this.textureUnitsUsed = this.gl.renderer.textureUnitsUsed, this.textureUnitsState = this.gl.renderer.state.textureUnits, this.maxTextureUnits = this.gl.renderer.parameters.maxTextureUnits, this.transparent = r, this.cullFace = l, this.frontFace = o, this.depthTest = c, this.depthWrite = d, this.depthFunc = u, this.blendFunc = {}, this.blendEquation = {}, this.transparent && !this.blendFunc.src && this.setBlendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
            let h = t.createShader(t.VERTEX_SHADER);
            t.shaderSource(h, e), t.compileShader(h);
            let m = t.createShader(t.FRAGMENT_SHADER);
            t.shaderSource(m, i), t.compileShader(m), this.program = t.createProgram(), t.attachShader(this.program, h), t.attachShader(this.program, m), t.linkProgram(this.program), t.deleteShader(h), t.deleteShader(m), this.uniformArray = [];
            let _ = t.getProgramParameter(this.program, t.ACTIVE_UNIFORMS);
            for (let f = 0; f < _; f++) {
                let p = t.getActiveUniform(this.program, f),
                    g = t.getUniformLocation(this.program, p.name),
                    v = p.name.match(/(\w+)/g);
                p.uniformName = v[0];
                let y = p.uniformName;
                $[y] ? this.uniforms[y] || (this.uniforms[y] = $[y]) : this.uniforms[y] || (nm.has(y) || this.autoUniforms.push(y), this.uniforms[y] = {
                    value: void 0
                });
                let b = {
                    name: y,
                    location: g,
                    cacheArray: [],
                    cacheValue: -0,
                    cacheState: -1,
                    data: this.uniforms[y],
                    type: p.type,
                    isTexture: 35678 === p.type || 35682 === p.type
                };
                this.uniformArray.push(b)
            }
            this.attributeLocations = [], this.attributeNames = [];
            let x = [],
                w = t.getProgramParameter(this.program, t.ACTIVE_ATTRIBUTES);
            for (let k = 0; k < w; k++) {
                let C = t.getActiveAttrib(this.program, k),
                    S = t.getAttribLocation(this.program, C.name);
                x[S] = C.name, this.attributeNames.push(C.name), this.attributeLocations.push(S)
            }
            this.attributeOrder = x.join("")
        }
        setBlendFunc(t, e, i, s) {
            this.blendFunc.src = t, this.blendFunc.dst = e, this.blendFunc.srcAlpha = i, this.blendFunc.dstAlpha = s, t && (this.transparent = !0)
        }
        setBlendEquation(t, e) {
            this.blendEquation.modeRGB = t, this.blendEquation.modeAlpha = e
        }
        applyState() {
            this.depthTest ? this.gl.renderer.enable(this.gl.DEPTH_TEST) : this.gl.renderer.disable(this.gl.DEPTH_TEST), this.cullFace ? this.gl.renderer.enable(this.gl.CULL_FACE) : this.gl.renderer.disable(this.gl.CULL_FACE), this.blendFunc.src ? this.gl.renderer.enable(this.gl.BLEND) : this.gl.renderer.disable(this.gl.BLEND), this.cullFace && this.gl.renderer.setCullFace(this.cullFace), this.gl.renderer.setFrontFace(this.frontFace), this.gl.renderer.setDepthMask(this.depthWrite), this.gl.renderer.setDepthFunc(this.depthFunc), this.blendFunc.src && this.gl.renderer.setBlendFunc(this.blendFunc.src, this.blendFunc.dst, this.blendFunc.srcAlpha, this.blendFunc.dstAlpha), this.blendEquation.modeRGB && this.gl.renderer.setBlendEquation(this.blendEquation.modeRGB, this.blendEquation.modeAlpha)
        }
        use(t) {
            t || (this.gl.useProgram(this.program), this.gl.renderer.currentProgram = this.id), this.updateUniforms(), this.applyState()
        }
        updateValueUniform(t) {
            let e = !1;
            if (t.data.state > 0) {
                if (!(t.data.state > t.cacheState)) return;
                e = !0, t.cacheState = t.data.state
            }(e || function t(e) {
                if (void 0 !== e.data.value.length) {
                    if (function t(e, i) {
                            let s = !0,
                                n = e.length,
                                a = i.length;
                            n !== a && (s = !1);
                            for (let r = 0; r < a; r++) e[r] !== i[r] && (s = !1, e[r] = i[r]);
                            return s
                        }(e.cacheArray, e.data.value)) return !1
                } else {
                    if (e.cacheValue === e.data.value) return !1;
                    e.cacheValue = e.data.value
                }
                return !0
            }(t)) && nh(this.gl, t.type, t.location, t.data.value)
        }
        updateTextureUniformSingle(t, e, i) {
            let s = this.textureUnitsState.indexOf(e.id);
            if (s >= 0) t.cacheValue !== s && (nh(this.gl, t.type, t.location, s), t.cacheValue = s);
            else {
                let n = this.textureUnitsState.length;
                if (n < this.maxTextureUnits) e.update(n), nh(this.gl, t.type, t.location, n), t.cacheValue = n;
                else
                    for (let a = 0; a < n; ++a)
                        if (0 > i.indexOf(this.textureUnitsState[a])) return e.update(a), nh(this.gl, t.type, t.location, a), void(t.cacheValue = a)
            }
        }
        updateTextureUniformArray(t, e, i) {
            let s = [];
            for (let n = 0; n < e.length; ++n) {
                let a = e[n];
                if (void 0 !== a) {
                    let r = this.textureUnitsState.indexOf(a.id);
                    if (r >= 0) s.push(r);
                    else
                        for (let l = 0, o = this.maxTextureUnits; l < o; ++l) 0 > i.indexOf(this.textureUnitsState[l]) && (a.update(l), s.push(l), o = l)
                }
            }
            let c = !1;
            for (let d = 0; d < s.length; ++d) t.cacheArray[d] !== s[d] && (c = !0, t.cacheArray[d] = s[d]);
            c && nh(this.gl, t.type, t.location, s)
        }
        updateTextureUniform(t, e) {
            void 0 === t.data.value.length ? this.updateTextureUniformSingle(t, t.data.value, e) : t.data.value.length > 0 && this.updateTextureUniformArray(t, t.data.value, e)
        }
        compileTextureIds() {
            let t = [];
            for (let e = 0; e < this.uniformArray.length; ++e) {
                let i = this.uniformArray[e];
                if (i.isTexture) {
                    if (void 0 === i.data.value.length) {
                        let s = i.data.value;
                        t.push(s.id), 0 > this.textureUnitsUsed.indexOf(s.id) && this.textureUnitsUsed.push(s.id)
                    } else {
                        let n = i.data.value;
                        for (let a = 0; a < n.length; ++a) void 0 !== n[a] && (t.push(n[a].id), 0 > this.textureUnitsUsed.indexOf(n[a].id) && this.textureUnitsUsed.push(n[a].id))
                    }
                }
            }
            if (this.textureUnitsUsed.length > this.maxTextureUnits) {
                for (let r = 0; r < this.maxTextureUnits - t.length; ++r) 0 > t.indexOf(this.textureUnitsUsed) && t.push(this.textureUnitsUsed[r]);
                return t
            }
            return this.textureUnitsUsed
        }
        updateUniforms() {
            let t = this.compileTextureIds();
            for (let e = 0; e < this.uniformArray.length; ++e) {
                let i = this.uniformArray[e];
                i.isTexture ? this.updateTextureUniform(i, t) : this.updateValueUniform(i)
            }
        }
        remove() {
            this.gl.deleteProgram(this.program), this.gl.deleteShader(this.vertexShader), this.gl.deleteShader(this.fragmentShader)
        }
    }

    function nh(t, e, i, s) {
        switch (e) {
            case 5126:
                return s.length ? t.uniform1fv(i, s) : t.uniform1f(i, s);
            case 35664:
                return t.uniform2fv(i, s);
            case 35665:
                return t.uniform3fv(i, s);
            case 35666:
                return t.uniform4fv(i, s);
            case 35670:
            case 5124:
            case 35678:
            case 35682:
            case 35680:
                return s.length ? t.uniform1iv(i, s) : t.uniform1i(i, s);
            case 35671:
            case 35667:
                return t.uniform2iv(i, s);
            case 35672:
            case 35668:
                return t.uniform3iv(i, s);
            case 35673:
            case 35669:
                return t.uniform4iv(i, s);
            case 35674:
                return t.uniformMatrix2fv(i, !1, s);
            case 35675:
                return t.uniformMatrix3fv(i, !1, s);
            case 35676:
                return t.uniformMatrix4fv(i, !1, s)
        }
    }
    let nm = new Set(["projectionViewMatrix", "shadowPVMatrix", "modelMatrix", "viewMatrix", "projectionMatrix", "cameraPosition"]);

    function n_() {
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    }

    function nf(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5], t[6] = e[6], t[7] = e[7], t[8] = e[8], t[9] = e[9], t[10] = e[10], t[11] = e[11], t[12] = e[12], t[13] = e[13], t[14] = e[14], t[15] = e[15], t
    }

    function np(t, e) {
        let i = e[0],
            s = e[1],
            n = e[2],
            a = e[3],
            r = e[4],
            l = e[5],
            o = e[6],
            c = e[7],
            d = e[8],
            u = e[9],
            $ = e[10],
            h = e[11],
            m = e[12],
            _ = e[13],
            f = e[14],
            p = e[15],
            g = i * l - s * r,
            v = i * o - n * r,
            y = i * c - a * r,
            b = s * o - n * l,
            x = s * c - a * l,
            w = n * c - a * o,
            k = d * _ - u * m,
            C = d * f - $ * m,
            S = d * p - h * m,
            E = u * f - $ * _,
            P = u * p - h * _,
            M = $ * p - h * f,
            D = g * M - v * P + y * E + b * S - x * C + w * k;
        return D ? (D = 1 / D, t[0] = (l * M - o * P + c * E) * D, t[1] = (n * P - s * M - a * E) * D, t[2] = (_ * w - f * x + p * b) * D, t[3] = ($ * x - u * w - h * b) * D, t[4] = (o * S - r * M - c * C) * D, t[5] = (i * M - n * S + a * C) * D, t[6] = (f * y - m * w - p * v) * D, t[7] = (d * w - $ * y + h * v) * D, t[8] = (r * P - l * S + c * k) * D, t[9] = (s * S - i * P - a * k) * D, t[10] = (m * x - _ * y + p * g) * D, t[11] = (u * y - d * x - h * g) * D, t[12] = (l * C - r * E - o * k) * D, t[13] = (i * E - s * C + n * k) * D, t[14] = (_ * v - m * b - f * g) * D, t[15] = (d * b - u * v + $ * g) * D, t) : null
    }

    function ng(t, e, i) {
        let s = e[0],
            n = e[1],
            a = e[2],
            r = e[3],
            l = e[4],
            o = e[5],
            c = e[6],
            d = e[7],
            u = e[8],
            $ = e[9],
            h = e[10],
            m = e[11],
            _ = e[12],
            f = e[13],
            p = e[14],
            g = e[15],
            v = i[0],
            y = i[1],
            b = i[2],
            x = i[3];
        return t[0] = v * s + y * l + b * u + x * _, t[1] = v * n + y * o + b * $ + x * f, t[2] = v * a + y * c + b * h + x * p, t[3] = v * r + y * d + b * m + x * g, v = i[4], y = i[5], b = i[6], x = i[7], t[4] = v * s + y * l + b * u + x * _, t[5] = v * n + y * o + b * $ + x * f, t[6] = v * a + y * c + b * h + x * p, t[7] = v * r + y * d + b * m + x * g, v = i[8], y = i[9], b = i[10], x = i[11], t[8] = v * s + y * l + b * u + x * _, t[9] = v * n + y * o + b * $ + x * f, t[10] = v * a + y * c + b * h + x * p, t[11] = v * r + y * d + b * m + x * g, v = i[12], y = i[13], b = i[14], x = i[15], t[12] = v * s + y * l + b * u + x * _, t[13] = v * n + y * o + b * $ + x * f, t[14] = v * a + y * c + b * h + x * p, t[15] = v * r + y * d + b * m + x * g, t
    }

    function nv(t, e) {
        return t[0] = e[12], t[1] = e[13], t[2] = e[14], t
    }

    function ny(t, e) {
        let i = e[0],
            s = e[1],
            n = e[2],
            a = e[4],
            r = e[5],
            l = e[6],
            o = e[8],
            c = e[9],
            d = e[10];
        return t[0] = Math.sqrt(i * i + s * s + n * n), t[1] = Math.sqrt(a * a + r * r + l * l), t[2] = Math.sqrt(o * o + c * c + d * d), t
    }

    function n0(t, e) {
        let i = e[0] + e[5] + e[10],
            s = 0;
        return i > 0 ? (s = 2 * Math.sqrt(i + 1), t[3] = .25 * s, t[0] = (e[6] - e[9]) / s, t[1] = (e[8] - e[2]) / s, t[2] = (e[1] - e[4]) / s) : e[0] > e[5] && e[0] > e[10] ? (s = 2 * Math.sqrt(1 + e[0] - e[5] - e[10]), t[3] = (e[6] - e[9]) / s, t[0] = .25 * s, t[1] = (e[1] + e[4]) / s, t[2] = (e[8] + e[2]) / s) : e[5] > e[10] ? (s = 2 * Math.sqrt(1 + e[5] - e[0] - e[10]), t[3] = (e[8] - e[2]) / s, t[0] = (e[1] + e[4]) / s, t[1] = .25 * s, t[2] = (e[6] + e[9]) / s) : (s = 2 * Math.sqrt(1 + e[10] - e[0] - e[5]), t[3] = (e[1] - e[4]) / s, t[0] = (e[8] + e[2]) / s, t[1] = (e[6] + e[9]) / s, t[2] = .25 * s), t
    }

    function nb(t, e, i, s) {
        let n = e[0],
            a = e[1],
            r = e[2],
            l = e[3],
            o = n + n,
            c = a + a,
            d = r + r,
            u = n * o,
            $ = n * c,
            h = n * d,
            m = a * c,
            _ = a * d,
            f = r * d,
            p = l * o,
            g = l * c,
            v = l * d,
            y = s[0],
            b = s[1],
            x = s[2];
        return t[0] = (1 - (m + f)) * y, t[1] = ($ + v) * y, t[2] = (h - g) * y, t[3] = 0, t[4] = ($ - v) * b, t[5] = (1 - (u + f)) * b, t[6] = (_ + p) * b, t[7] = 0, t[8] = (h + g) * x, t[9] = (_ - p) * x, t[10] = (1 - (u + m)) * x, t[11] = 0, t[12] = i[0], t[13] = i[1], t[14] = i[2], t[15] = 1, t
    }

    function nx(t, e, i, s) {
        let n = e[0],
            a = e[1],
            r = e[2],
            l = s[0],
            o = s[1],
            c = s[2],
            d = n - i[0],
            u = a - i[1],
            $ = r - i[2],
            h = d * d + u * u + $ * $;
        h > 0 && (d *= h = 1 / Math.sqrt(h), u *= h, $ *= h);
        let m = o * $ - c * u,
            _ = c * d - l * $,
            f = l * u - o * d;
        return (h = m * m + _ * _ + f * f) > 0 && (m *= h = 1 / Math.sqrt(h), _ *= h, f *= h), t[0] = m, t[1] = _, t[2] = f, t[3] = 0, t[4] = u * f - $ * _, t[5] = $ * m - d * f, t[6] = d * _ - u * m, t[7] = 0, t[8] = d, t[9] = u, t[10] = $, t[11] = 0, t[12] = n, t[13] = a, t[14] = r, t[15] = 1, t
    }
    let nw = [0, 0, 0],
        n1 = (t, e, i, s, n) => {
            let a = e.visible;
            if (a) {
                let r = e.data.mesh;
                if ((a = !(i && !r.receiveShadow.has(i) && !r.throwShadow.has(i))) && n && r.frustumCulled && void 0 !== s && !s.frustumIntersectsMesh(r.geometry, e)) return;
                a && t.push(r);
                for (let l = 0; l < e.children.length; ++l) n1(t, e.children[l], i, s, n)
            }
        };

    function n9(t, e) {
        return t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t
    }

    function n3(t, e, i, s, n) {
        return t[0] = e, t[1] = i, t[2] = s, t[3] = n, t
    }

    function nk(t, e) {
        let i = Math.sin(.5 * e[0]),
            s = Math.cos(.5 * e[0]),
            n = Math.sin(.5 * e[1]),
            a = Math.cos(.5 * e[1]),
            r = Math.sin(.5 * e[2]),
            l = Math.cos(.5 * e[2]);
        return t[0] = i * a * l + s * n * r, t[1] = s * n * l - i * a * r, t[2] = s * a * r - i * n * l, t[3] = s * a * l + i * n * r, t
    }
    let n2 = n_(),
        n4 = () => ({
            parent: null,
            children: [],
            visible: !0,
            geometry: void 0,
            matrix: n_(),
            worldMatrix: n_(),
            position: [0, 0, 0],
            scale: [1, 1, 1],
            quaternion: [-0, -0, -0, 1],
            rotation: [-0, -0, -0],
            matrixAutoUpdate: !1,
            matrixNeedsUpdate: !0,
            data: {}
        }),
        nC = (t, e, i = !0) => {
            i && null !== t.parent && e !== t.parent && n7(t.parent, t, !1), t.parent = e, t.matrixNeedsUpdate = !0, i && e && nS(e, t, !1)
        },
        nS = (t, e, i = !0) => {
            ~t.children.indexOf(e) || t.children.push(e), i && nC(e, t, !1)
        },
        n7 = (t, e, i = !0) => {
            ~t.children.indexOf(e) && t.children.splice(t.children.indexOf(e), 1), i && nC(e, null, !1)
        },
        nE = (t, e) => {
            if (!t.visible) return;
            let i = n6(t),
                s = nP(t, e, i);
            t.children.forEach(t => {
                t.visible && nE(t, s)
            })
        },
        n6 = t => !(!t.matrixAutoUpdate && !t.matrixNeedsUpdate) && (t.matrixNeedsUpdate = !1, nk(t.quaternion, t.rotation), nb(t.matrix, t.quaternion, t.position, t.scale), !0),
        nP = (t, e, i) => null !== t.parent ? !(!e && !i) && (ng(t.worldMatrix, t.parent.worldMatrix, t.matrix), !0) : !!i && (nf(t.worldMatrix, t.matrix), !0),
        nM = (t, e, i, s) => {
            let n = sY([0, 0, 0], i.position, e.position);
            sZ(n, n), sX(t.position, e.position, n, s), t.rotation[0] = 0, t.rotation[1] = Math.atan2(n[0], n[2]) + 1.5, t.rotation[2] = Math.sin(-n[1]) + 1.5, nE(t, !1)
        },
        n5 = (t, e, i = !1, s) => {
            var n, a;
            i ? nx(n2, t.position, e, s) : nx(n2, e, t.position, s), n = t.rotation, a = n2, n[0] = Math.asin(-Math.min(Math.max(a[9], -1), 1)), .99999 > Math.abs(a[9]) ? (n[1] = Math.atan2(a[8], a[10]), n[2] = Math.atan2(a[1], a[5])) : (n[1] = Math.atan2(-a[2], a[0]), n[2] = 0)
        },
        nD = [],
        nT = () => nD.length > 0 ? nD.pop() : n4(),
        nA = t => {
            n8(t), 0 > nD.indexOf(t) ? nD.push(t) : console.log("tried returning transform that is already known")
        },
        n8 = t => {
            t.data = {}, t.geometry = void 0, t.visible = !0, t.matrixAutoUpdate = !1, sW(t.position, 0, 0, 0), sW(t.scale, 1, 1, 1), sW(t.rotation, 0, 0, 0), nC(t, null, !0);
            for (let e = 0; e < t.children.length; ++e) nC(t.children[e], null);
            t.children.length = 0
        },
        nR = n_(),
        nF = [0, 0, 0];
    class nN {
        constructor(t = .1, e = 100, i = 45, s = 1) {
            this.near = t, this.far = e, this.fov = i, this.aspect = s, this.transform = nT(), this.transform.matrixAutoUpdate = !0, this.projectionMatrix = n_(), this.viewMatrix = n_(), this.projectionViewMatrix = n_(), this.worldPosition = [0, 0, 0], this.frustum = [
                [0, 0, 0],
                [0, 0, 0],
                [0, 0, 0],
                [0, 0, 0],
                [0, 0, 0],
                [0, 0, 0]
            ], this.frustumConstants = [0, 0, 0, 0, 0, 0]
        }
        perspective({
            near: t = this.near,
            far: e = this.far,
            fov: i = this.fov,
            aspect: s = this.aspect
        } = {}) {
            return function t(e, i, s, n, a) {
                let r = 1 / Math.tan(i / 2),
                    l = 1 / (n - a);
                return e[0] = r / s, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = r, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = (a + n) * l, e[11] = -1, e[12] = 0, e[13] = 0, e[14] = 2 * a * n * l, e[15] = 0, e
            }(this.projectionMatrix, i * (Math.PI / 180), s, t, e), this
        }
        orthographic({
            near: t = this.near,
            far: e = this.far,
            left: i = -1,
            right: s = 1,
            bottom: n = -1,
            top: a = 1
        } = {}) {
            return function t(e, i, s, n, a, r, l) {
                let o = 1 / (i - s),
                    c = 1 / (n - a),
                    d = 1 / (r - l);
                return e[0] = -2 * o, e[1] = 0, e[2] = 0, e[3] = 0, e[4] = 0, e[5] = -2 * c, e[6] = 0, e[7] = 0, e[8] = 0, e[9] = 0, e[10] = 2 * d, e[11] = 0, e[12] = (i + s) * o, e[13] = (a + n) * c, e[14] = (l + r) * d, e[15] = 1, e
            }(this.projectionMatrix, i, s, n, a, t, e), this
        }
        updateGlobalWorldPos() {
            nv(this.worldPosition, this.transform.worldMatrix)
        }
        updateMatrixWorldCamView(t) {
            nE(this.transform, t), np(this.viewMatrix, this.transform.worldMatrix), ng(this.projectionViewMatrix, this.projectionMatrix, this.viewMatrix), this.updateGlobalWorldPos()
        }
        lookAt(t, e) {
            n5(this.transform, t, !0, e)
        }
        project(t) {
            return ni(t, t, this.viewMatrix), ni(t, t, this.projectionMatrix), t
        }
        unproject(t) {
            return ni(t, t, np(nR, this.projectionMatrix)), ni(t, t, this.transform.worldMatrix), t
        }
        updateFrustum() {
            let t = this.projectionViewMatrix;
            sW(this.frustum[0], t[3] - t[0], t[7] - t[4], t[11] - t[8]), sW(this.frustum[1], t[3] + t[0], t[7] + t[4], t[11] + t[8]), sW(this.frustum[2], t[3] + t[1], t[7] + t[5], t[11] + t[9]), sW(this.frustum[3], t[3] - t[1], t[7] - t[5], t[11] - t[9]), sW(this.frustum[4], t[3] - t[2], t[7] - t[6], t[11] - t[10]), sW(this.frustum[5], t[3] + t[2], t[7] + t[6], t[11] + t[10]), this.frustumConstants[0] = t[15] - t[12], this.frustumConstants[1] = t[15] + t[12], this.frustumConstants[2] = t[15] + t[13], this.frustumConstants[3] = t[15] - t[13], this.frustumConstants[4] = t[15] - t[14], this.frustumConstants[5] = t[15] + t[14];
            for (let e = 0; e < 6; e++) {
                let i = this.frustum[e],
                    s = 1 / sq(i);
                sQ(i, i, s), this.frustumConstants[e] *= s
            }
        }
        frustumIntersectsMesh(t, e) {
            sV(nF, t.bounds.center), ni(nF, nF, e.worldMatrix);
            let i = t.bounds.radius * function t(e) {
                let i = e[0],
                    s = e[1],
                    n = e[2],
                    a = e[4],
                    r = e[5],
                    l = e[6],
                    o = e[8],
                    c = e[9],
                    d = e[10];
                return Math.sqrt(Math.max(i * i + s * s + n * n, a * a + r * r + l * l, o * o + c * c + d * d))
            }(e.worldMatrix);
            return this.frustumIntersectsSphere(nF, i)
        }
        frustumIntersectsSphere(t, e) {
            for (let i = 0; i < 6; i++)
                if (nt(this.frustum[i], t) + this.frustumConstants[i] < -e) return !1;
            return !0
        }
    }
    let nI = 0;
    class nU {
        constructor(t, e, i, s = !0, n = 0, a = null, r = new Set, l = new Set) {
            this.id = nI++, this.geometry = t, this.program = e, this.shadowProgram = a, this.throwShadow = r, this.receiveShadow = l, this.mode = i, this.frustumCulled = s, this.renderOrder = n, this.transform = nT(), this.transform.data.mesh = this, this.zDepth = 0, this.uniformData = {}
        }
        draw(t, e = null) {
            if (!this.program.active || e && !this.throwShadow.has(e)) return;
            let i = e ? this.shadowProgram : this.program;
            i.uniforms.modelMatrix && (i.uniforms.modelMatrix.value = this.transform.worldMatrix);
            for (let s = 0; s < i.autoUniforms.length; ++s) {
                let n = i.autoUniforms[s];
                i.uniforms[n].value = this.uniformData[n]
            }
            let a = i.gl.renderer.currentProgram === i.id;
            i.use(a), this.geometry.draw(i, this.mode)
        }
    }
    class nz extends nU {
        constructor(t, e, i, s = 0, n = null, a = new Set, r = new Set, l = !1, o = !1) {
            super(new nd(t), e, i, !1, s, n, a, r), this.transform.visible = !1, this.individualFrustums = o, this.dynamicThrowShadows = !1, this.dynamic = l, this.needsUpdate = !1, this.lastUpdateCamPos = [0, 0, 0], this.drawCount = 0, this.cullFace = 1029, this.uniformData.shadowActive = !1, this.instances = [], this.instancedAttributes = [], this.instancedData = [], [...this.program.instancedAttributes, {
                name: "worldMatrix",
                size: 16
            }].forEach(t => {
                this.instancedAttributes.push({
                    name: t.name,
                    instanced: !0,
                    bufferMode: this.dynamic ? 35048 : 35044,
                    size: t.size,
                    data: new Float32Array(t.size)
                }), this.instancedData.push([])
            })
        }
        create() {
            let t = nT();
            t.geometry = this.geometry, t.data.multi = this, this.instances.push(t);
            for (let e = 0; e < this.instancedAttributes.length; ++e) {
                let i = this.instancedAttributes[e];
                this.instancedData[e].push(t.data[i.name] = "worldMatrix" === i.name ? t.worldMatrix : Array(i.size).fill(0))
            }
            return this.needsUpdate = !0, t
        }
        remove(t) {
            let e = this.instances.indexOf(t);
            this.instances.splice(e, 1);
            for (let i = 0; i < this.instancedAttributes.length; ++i) this.instancedData[i].splice(e, 1);
            this.needsUpdate = !0, nA(t)
        }
        rebuild(t) {
            if (!this.needsUpdate && 100 > sK(this.lastUpdateCamPos, t.worldPosition)) return;
            sV(this.lastUpdateCamPos, t.worldPosition), this.needsUpdate = this.dynamic;
            for (let e = 0; e < this.instancedAttributes.length; ++e) {
                let i = this.instancedAttributes[e];
                nO(i, i.size, this.instances.length)
            }
            let s = t.worldPosition[0],
                n = t.worldPosition[1],
                a = t.worldPosition[2],
                r = (t.far + 10) ** 2,
                l = this.dynamic,
                o = this.individualFrustums,
                c = this.instancedData,
                d = this.instances,
                u = 0;
            for (let $ = 0; $ < d.length; ++$) {
                let h = d[$];
                if (h.visible) {
                    let m = h.worldMatrix;
                    if ((m[12] - s) ** 2 + (m[13] - n) ** 2 + (m[14] - a) ** 2 < r && (!l || !o || t.frustumIntersectsMesh(h.geometry, h))) {
                        for (let _ = 0; _ < this.instancedAttributes.length; ++_) {
                            let f = this.instancedAttributes[_],
                                p = f.data,
                                g = c[_][$],
                                v = u * f.size,
                                y = v + f.size;
                            for (let b = v, x = 0; b < y; ++b, ++x) p[b] = g[x]
                        }
                        u++
                    }
                }
            }
            if (this.drawCount = u, this.geometry.setInstancedCount(this.drawCount), 0 !== this.drawCount)
                for (let w = 0; w < this.instancedAttributes.length; ++w) {
                    let k = this.instancedAttributes[w];
                    this.geometry.updateAttribute(k)
                }
        }
        draw(t, e = null, i, s) {
            this.transform.visible && ((s && this.dynamicThrowShadows || !this.dynamicThrowShadows && !e) && this.rebuild(i || t), this.drawCount > 0 && (e || (this.program.cullFace = this.cullFace), super.draw(t, e)))
        }
        setAttributes(t) {
            let e = {
                ...t
            };
            for (let i = 0; i < this.instancedAttributes.length; ++i) e[this.instancedAttributes[i].name] = this.instancedAttributes[i];
            this.geometry.addAttributes(e)
        }
    }
    let nO = (t, e, i) => {
            t.data = t.data.byteLength >= e * i * 4 ? t.data : new Float32Array(e * (i + 5))
        },
        nL = new Uint8Array(4),
        nB = 1;
    class nq {
        constructor(t, {
            image: e,
            target: i = t.TEXTURE_2D,
            type: s = t.UNSIGNED_BYTE,
            format: n = t.RGBA,
            internalFormat: a = n,
            wrapS: r = t.CLAMP_TO_EDGE,
            wrapT: l = t.CLAMP_TO_EDGE,
            generateMipmaps: o = !0,
            minFilter: c = o ? t.NEAREST_MIPMAP_LINEAR : t.LINEAR,
            magFilter: d = t.LINEAR,
            flipY: u = !0,
            level: $ = 0,
            width: h,
            height: m = h,
            compareMode: _ = t.NONE,
            compareFunc: f = t.LEQUAL,
            anisotropy: p = 1
        } = {}) {
            this.gl = t, this.id = nB++, this.image = e, this.target = i, this.type = s, this.format = n, this.internalFormat = a, this.minFilter = c, this.magFilter = d, this.wrapS = r, this.wrapT = l, this.generateMipmaps = o, this.flipY = u, this.level = $, this.width = h, this.height = m, this.compareMode = _, this.texture = t.createTexture(), this.anisotropy = Math.min(Math.max(1, p), t.renderer.parameters.maxAnisotropy), this.store = {
                image: void 0
            }, this.glState = this.gl.renderer.state, this.state = {
                minFilter: this.gl.NEAREST_MIPMAP_LINEAR,
                magFilter: this.gl.LINEAR,
                wrapS: this.gl.REPEAT,
                wrapT: this.gl.REPEAT,
                anisotropy: 1
            }, this.needsUpdate = !0
        }
        bind() {
            this.glState.textureUnits[this.glState.activeTextureUnit] !== this.id && (this.gl.bindTexture(this.target, this.texture), this.glState.textureUnits[this.glState.activeTextureUnit] = this.id)
        }
        update(t = 0) {
            let e = !(this.image === this.store.image && !this.needsUpdate);
            (e || this.glState.textureUnits[t] !== this.id) && (this.gl.renderer.activeTexture(t), this.bind()), e && (this.needsUpdate = !1, this.flipY !== this.glState.flipY && (this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.flipY), this.glState.flipY = this.flipY), this.minFilter !== this.state.minFilter && (this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.minFilter), this.state.minFilter = this.minFilter), this.magFilter !== this.state.magFilter && (this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.magFilter), this.state.magFilter = this.magFilter), this.wrapS !== this.state.wrapS && (this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.wrapS), this.state.wrapS = this.wrapS), this.wrapT !== this.state.wrapT && (this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.wrapT), this.state.wrapT = this.wrapT), this.anisotropy !== this.state.anisotropy && (this.gl.texParameterf(this.target, this.gl.renderer.anisotropy.TEXTURE_MAX_ANISOTROPY_EXT, this.anisotropy), this.state.anisotropy = this.anisotropy), this.compareMode !== this.state.compareMode && (this.gl.texParameteri(this.target, this.gl.TEXTURE_COMPARE_MODE, this.compareMode), this.state.compareMode = this.compareMode), this.compareFunc !== this.state.compareFunc && (this.gl.texParameteri(this.target, this.gl.TEXTURE_COMPARE_FUNC, this.compareFunc), this.state.compareFunc = this.compareFunc), this.image ? (this.image.width && (this.width = this.image.width, this.height = this.image.height), this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, this.image), this.generateMipmaps && this.gl.generateMipmap(this.target)) : this.width ? this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, null) : this.gl.texImage2D(this.target, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, nL), this.store.image = this.image)
        }
        setAnisotropy(t) {
            this.anisotropy = Math.min(Math.max(1, t), this.gl.renderer.parameters.maxAnisotropy), this.needsUpdate = !0
        }
    }
    class nV {
        constructor(t, {
            width: e = t.canvas.width,
            height: i = t.canvas.height,
            target: s = t.FRAMEBUFFER,
            color: n = 1,
            depth: a = !0,
            stencil: r = !1,
            depthTexture: l = !1,
            depthCompareMode: o = t.NONE,
            wrapS: c = t.CLAMP_TO_EDGE,
            wrapT: d = t.CLAMP_TO_EDGE,
            minFilter: u = t.LINEAR,
            magFilter: $ = t.LINEAR
        } = {}) {
            this.gl = t, this.width = e, this.height = i, this.buffer = this.gl.createFramebuffer(), this.target = s, this.gl.bindFramebuffer(this.target, this.buffer), this.textures = [];
            for (let h = 0; h < n; h++) this.textures.push(new nq(t, {
                width: e,
                height: i,
                wrapS: c,
                wrapT: d,
                minFilter: u,
                magFilter: $,
                flipY: !1,
                generateMipmaps: !1
            })), this.textures[h].update(), this.gl.framebufferTexture2D(this.target, this.gl.COLOR_ATTACHMENT0 + h, this.gl.TEXTURE_2D, this.textures[h].texture, 0);
            if (this.texture = this.textures[0], l) {
                let m = o == this.gl.COMPARE_REF_TO_TEXTURE ? this.gl.LINEAR : this.gl.NEAREST;
                this.depthTexture = new nq(t, {
                    width: e,
                    height: i,
                    wrapS: c,
                    wrapT: d,
                    minFilter: m,
                    magFilter: m,
                    flipY: !1,
                    format: this.gl.DEPTH_COMPONENT,
                    internalFormat: this.gl.DEPTH_COMPONENT24,
                    type: this.gl.UNSIGNED_INT,
                    generateMipmaps: !1,
                    compareMode: o
                }), this.depthTexture.update(), this.gl.framebufferTexture2D(this.target, this.gl.DEPTH_ATTACHMENT, this.gl.TEXTURE_2D, this.depthTexture.texture, 0)
            } else a && !r && (this.depthBuffer = this.gl.createRenderbuffer(), this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.depthBuffer), this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, e, i), this.gl.framebufferRenderbuffer(this.target, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, this.depthBuffer)), r && !a && (this.stencilBuffer = this.gl.createRenderbuffer(), this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.stencilBuffer), this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.STENCIL_INDEX8, e, i), this.gl.framebufferRenderbuffer(this.target, this.gl.STENCIL_ATTACHMENT, this.gl.RENDERBUFFER, this.stencilBuffer)), a && r && (this.depthStencilBuffer = this.gl.createRenderbuffer(), this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.depthStencilBuffer), this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_STENCIL, e, i), this.gl.framebufferRenderbuffer(this.target, this.gl.DEPTH_STENCIL_ATTACHMENT, this.gl.RENDERBUFFER, this.depthStencilBuffer));
            this.gl.bindFramebuffer(this.target, null)
        }
    }

    function nW(t, e) {
        return t[0] = e[0], t[1] = e[1], t
    }

    function nH(t, e, i) {
        return t[0] = e, t[1] = i, t
    }

    function nj(t, e, i) {
        return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t
    }

    function nG(t, e, i) {
        return t[0] = e[0] * i, t[1] = e[1] * i, t
    }

    function nY(t, e, i, s) {
        return t[0] = e[0] + i[0] * s, t[1] = e[1] + i[1] * s, t
    }

    function nQ(t) {
        let e = t[0],
            i = t[1];
        return Math.sqrt(e * e + i * i)
    }

    function nX(t, e) {
        let i = e[0],
            s = e[1],
            n = i * i + s * s;
        return n > 0 && (n = 1 / Math.sqrt(n)), t[0] = e[0] * n, t[1] = e[1] * n, t
    }
    let nJ = "#version 300 es\nin vec2 uv;\nin vec2 position;\nout vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = vec4(position, 0.0, 1.0);\n}",
        nK, nZ, at, ae, ai, as, an = [0, 1, 0],
        aa = [0, 0, 0],
        ar = [0, 0, 0],
        al = [0, 0, 0],
        ao = [0, 0, 0],
        ac = [0, 0, 0],
        ad = [0, 0, 0],
        au = [0, 0, 0],
        a$ = [0, 0, 0, 0],
        ah = [0, 0],
        am = [0, 0],
        a_ = t => {
            as = t
        },
        af = 0,
        ap = t => af = t,
        ag = (t, e, i, s, n, a) => {
            nK = t, nZ = e, at = i, ae = s, ai = n
        },
        av = 0,
        ay = {
            string(t) {
                let e = aA(t);
                return ax(e) + e
            },
            varuint: t => ax(t),
            varint: t => aw(t),
            buffer8(t) {
                let e = t.length;
                return ax(e) + e
            },
            buffer16(t, e) {
                let i = 2 * t.length,
                    s = ax(i);
                return (e + s) % 2 == 1 && s++, s + i
            }
        },
        a0 = t => {
            let e = 0,
                i = 0,
                s = 0;
            do e |= (127 & (s = t[av++])) << 7 * i, i++; while (128 & s);
            return e
        },
        ab = (t, e) => {
            for (; e > 127;) t[av++] = 127 & e | 128, e >>= 7;
            t[av++] = 127 & e
        },
        ax = t => t <= 0 ? 1 : Math.floor(Math.log(t) / Math.log(128)) + 1,
        aw = t => ax(t << 1 ^ t >> 31),
        a1 = t => 128 & t[av] ? -1 * (255 - t[av] + 1) : t[av],
        a9 = (t, e) => {
            e < 0 && (e = 255 + e + 1), t[av] = 255 & e, av += 1
        },
        a3 = t => t[av],
        ak = (t, e) => {
            t[av] = e, av += 1
        },
        a2 = t => {
            let e = t[av] | t[av + 1] << 8;
            return 32768 & e ? 4294901760 | e : e
        },
        a4 = (t, e) => {
            t[av] = 255 & e, t[av + 1] = e >>> 8, av += 2
        },
        aC = t => t[av] | t[av + 1] << 8,
        aS = t => (t[av] | t[av + 1] << 8 | t[av + 2] << 16) + 16777216 * t[av + 3],
        a7 = (t, e) => {
            t[av] = 255 & e, t[av + 1] = e >>> 8, t[av + 2] = e >>> 16, t[av + 3] = e >>> 24, av += 4
        },
        aE = new ArrayBuffer(8),
        a6 = new Uint8Array(aE),
        aP = new Float32Array(aE),
        aM = t => (a6[0] = t[av], a6[1] = t[av + 1], a6[2] = t[av + 2], a6[3] = t[av + 3], aP[0]),
        a5 = (t, e) => {
            aP[0] = e, t[av] = a6[0], t[av + 1] = a6[1], t[av + 2] = a6[2], t[av + 3] = a6[3], av += 4
        },
        aD = (t, e) => {
            let i = 2 * e.length;
            ab(t, i), av % 2 == 1 && av++;
            let s = new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
            t.set(s, av), av += i
        },
        aT = t => {
            let e = a0(t);
            av % 2 == 1 && av++;
            let i = new Uint16Array(t.buffer, av, e / 2);
            return av += e, i
        },
        aA = t => {
            let e = t.length;
            for (let i = t.length - 1; i >= 0; i--) {
                let s = t.charCodeAt(i);
                s > 127 && s <= 2047 ? e++ : s > 2047 && s <= 65535 && (e += 2), s >= 56320 && s <= 57343 && i--
            }
            return e
        },
        a8 = (t, e) => {
            let i = aA(e);
            ab(t, i);
            for (let s = 0; s < e.length; s++) {
                let n = e.charCodeAt(s);
                n < 128 ? t[av++] = n : n < 2048 ? (t[av++] = n >> 6 | 192, t[av++] = 63 & n | 128) : 55296 == (64512 & n) && s + 1 < e.length && 56320 == (64512 & e.charCodeAt(s + 1)) ? (n = 65536 + ((1023 & n) << 10) + (1023 & e.charCodeAt(++s)), t[av++] = n >> 18 | 240, t[av++] = n >> 12 & 63 | 128, t[av++] = n >> 6 & 63 | 128, t[av++] = 63 & n | 128) : (t[av++] = n >> 12 | 224, t[av++] = n >> 6 & 63 | 128, t[av++] = 63 & n | 128)
            }
        },
        aR = t => {
            let e = a0(t),
                i = "",
                s = av + e;
            for (; av < s;) {
                let n = t[av++];
                if (n < 128) i += String.fromCharCode(n);
                else if (n > 191 && n < 224) {
                    let a = t[av++];
                    i += String.fromCharCode((31 & n) << 6 | 63 & a)
                } else if (n > 239 && n < 365) {
                    let r = ((7 & n) << 18 | (63 & t[av++]) << 12 | (63 & t[av++]) << 6 | 63 & t[av++]) - 65536;
                    i += String.fromCharCode(55296 + (r >> 10)), i += String.fromCharCode(56320 + (1023 & r))
                } else {
                    let l = t[av++],
                        o = t[av++];
                    i += String.fromCharCode((15 & n) << 12 | (63 & l) << 6 | 63 & o)
                }
            }
            return i
        },
        aF = {
            clientPlayerInput: {
                decode(t) {
                    let e = t,
                        i = {};
                    av = 0, i._header = a3(e), av += 1;
                    let s = [];
                    i.doubles = s;
                    let n = a0(e);
                    for (let a = 0; a < n; a++) s[a] = aM(e), av += 4;
                    let r = [];
                    i.int8s = r;
                    let l = a0(e);
                    for (let o = 0; o < l; o++) r[o] = a1(e), av += 1;
                    let c = [];
                    i.uint16s = c;
                    let d = a0(e);
                    for (let u = 0; u < d; u++) c[u] = aC(e), av += 2;
                    let $ = [];
                    i.uint8s = $;
                    let h = a0(e);
                    for (let m = 0; m < h; m++) $[m] = a3(e), av += 1;
                    return i
                },
                encode(t) {
                    let e = t,
                        i = e.doubles,
                        s = e.int8s,
                        n = e.uint16s,
                        a = e.uint8s,
                        r = 0;
                    r += 1, r += ax(i.length);
                    for (let l = 0; l < i.length; l++) r += 4;
                    r += ax(s.length);
                    for (let o = 0; o < s.length; o++) r += 1;
                    r += ax(n.length);
                    for (let c = 0; c < n.length; c++) r += 2;
                    r += ax(a.length);
                    for (let d = 0; d < a.length; d++) r += 1;
                    let u = new Uint8Array(r);
                    av = 0, ak(u, e._header), ab(u, i.length);
                    for (let $ = 0; $ < i.length; $++) a5(u, i[$]);
                    ab(u, s.length);
                    for (let h = 0; h < s.length; h++) a9(u, s[h]);
                    ab(u, n.length);
                    for (let m = 0; m < n.length; m++) a4(u, n[m]);
                    ab(u, a.length);
                    for (let _ = 0; _ < a.length; _++) ak(u, a[_]);
                    return u
                }
            },
            clientPlayerChangeTarget: {
                decode(t) {
                    let e = t,
                        i = {};
                    return av = 0, i._header = a3(e), av += 1, i.target = aC(e), av += 2, i
                },
                encode(t) {
                    let e = t,
                        i = 0;
                    i += 1, i += 2;
                    let s = new Uint8Array(i);
                    return av = 0, ak(s, e._header), a4(s, e.target), s
                }
            },
            clientPlayerSkill: {
                decode(t) {
                    let e = t,
                        i = {};
                    av = 0, i._header = a3(e), av += 1, i.id = aC(e), av += 2;
                    let s = [];
                    i.info = s;
                    let n = a0(e);
                    for (let a = 0; a < n; a++) s[a] = aS(e), av += 4;
                    return i
                },
                encode(t) {
                    let e = t,
                        i = e.info,
                        s = 0;
                    s += 1, s += 2, s += ax(i.length);
                    for (let n = 0; n < i.length; n++) s += 4;
                    let a = new Uint8Array(s);
                    av = 0, ak(a, e._header), a4(a, e.id), ab(a, i.length);
                    for (let r = 0; r < i.length; r++) a7(a, i[r]);
                    return a
                }
            },
            clientPlayerEnvSkill: {
                decode(t) {
                    let e = t,
                        i = {};
                    av = 0, i._header = a3(e), av += 1, i.id = aC(e), av += 2;
                    let s = [];
                    i.info = s;
                    let n = a0(e);
                    for (let a = 0; a < n; a++) s[a] = aS(e), av += 4;
                    let r = [];
                    i.pos = r;
                    let l = a0(e);
                    for (let o = 0; o < l; o++) r[o] = aM(e), av += 4;
                    return i
                },
                encode(t) {
                    let e = t,
                        i = e.info,
                        s = e.pos,
                        n = 0;
                    n += 1, n += 2, n += ax(i.length);
                    for (let a = 0; a < i.length; a++) n += 4;
                    n += ax(s.length);
                    for (let r = 0; r < s.length; r++) n += 4;
                    let l = new Uint8Array(n);
                    av = 0, ak(l, e._header), a4(l, e.id), ab(l, i.length);
                    for (let o = 0; o < i.length; o++) a7(l, i[o]);
                    ab(l, s.length);
                    for (let c = 0; c < s.length; c++) a5(l, s[c]);
                    return l
                }
            },
            clientPlayerInteract: {
                decode(t) {
                    let e = t,
                        i = {};
                    return av = 0, i._header = a3(e), av += 1, i.id = a3(e), av += 1, i
                },
                encode(t) {
                    let e = t,
                        i = 0;
                    i += 1, i += 1;
                    let s = new Uint8Array(i);
                    return av = 0, ak(s, e._header), ak(s, e.id), s
                }
            },
            clientCommand: {
                decode(t) {
                    let e = t,
                        i = {};
                    return av = 0, i._header = a3(e), av += 1, i.command = aR(e), i.string = aR(e), i
                },
                encode(t) {
                    let e = t,
                        i = 0;
                    i += 1, i += ay.string(e.command, i), i += ay.string(e.string, i);
                    let s = new Uint8Array(i);
                    return av = 0, ak(s, e._header), a8(s, e.command), a8(s, e.string), s
                }
            },
            serverOnClientConnect: {
                decode(t) {
                    let e = t,
                        i = {};
                    return av = 0, i._header = a3(e), av += 1, i.file = aR(e), i.playerId = aC(e), av += 2, i.tickId = aS(e), av += 4, i.world = aR(e), i
                },
                encode(t) {
                    let e = t,
                        i = 0;
                    i += 1, i += ay.string(e.file, i), i += 2, i += 4, i += ay.string(e.world, i);
                    let s = new Uint8Array(i);
                    return av = 0, ak(s, e._header), a8(s, e.file), a4(s, e.playerId), a7(s, e.tickId), a8(s, e.world), s
                }
            },
            serverEntityDelta: {
                decode(t) {
                    let e = t,
                        i = {};
                    av = 0, i._header = a3(e), av += 1;
                    let s = [];
                    i.inputs = s;
                    let n = a0(e);
                    for (let a = 0; a < n; a++) {
                        let r = {};
                        s[a] = r, r.id = aC(e), av += 2, r.jump = a3(e), av += 1, r.rot = aM(e), av += 4, r.speed = aC(e), av += 2;
                        let l = [];
                        r.steer = l, l[0] = a1(e), av += 1;
                        let o = a0(e);
                        for (let c = 1; c < o; c++) l[c] = a1(e), av += 1
                    }
                    let d = [];
                    i.log = d;
                    let u = a0(e);
                    for (let $ = 0; $ < u; $++) {
                        let h = {};
                        d[$] = h;
                        let m = [];
                        h.data = m, h.type = a3(e), av += 1;
                        let _ = a0(e);
                        for (let f = 0; f < _; f++) m[f] = a0(e)
                    }
                    let p = [];
                    i.logPersonal = p;
                    let g = a0(e);
                    for (let v = 0; v < g; v++) {
                        let y = {};
                        p[v] = y;
                        let b = [];
                        y.data = b, y.type = a3(e), av += 1;
                        let x = a0(e);
                        for (let w = 0; w < x; w++) b[w] = a0(e)
                    }
                    let k = [];
                    i.movements = k;
                    let C = a0(e);
                    for (let S = 0; S < C; S++) {
                        let E = {};
                        k[S] = E, E.id = aC(e), av += 2;
                        let P = [];
                        E.pos = P, P[0] = aM(e), av += 4, P[1] = aM(e), av += 4;
                        let M = [];
                        E.vel = M, M[0] = aM(e), av += 4, M[1] = aM(e), av += 4;
                        let D = a0(e);
                        for (let T = 2; T < D; T++) {
                            M[T] = aM(e), av += 4;
                            let A = a0(e);
                            for (let R = 2; R < A; R++) P[R] = aM(e), av += 4
                        }
                    }
                    return i.tickId = aS(e), av += 4, i
                },
                encode(t) {
                    let e = t,
                        i = e.inputs,
                        s = e.log,
                        n = e.logPersonal,
                        a = e.movements,
                        r = 0;
                    r += 1, r += ax(i.length);
                    for (let l = 0; l < i.length; l++) {
                        r += 2, r += 1, r += 4, r += 2;
                        let o = i[l].steer;
                        r += 1, r += ax(o.length);
                        for (let c = 1; c < o.length; c++) r += 1
                    }
                    r += ax(s.length);
                    for (let d = 0; d < s.length; d++) {
                        let u = s[d].data;
                        r += 1, r += ax(u.length);
                        for (let $ = 0; $ < u.length; $++) r += ay.varuint(u[$], r)
                    }
                    r += ax(n.length);
                    for (let h = 0; h < n.length; h++) {
                        let m = n[h].data;
                        r += 1, r += ax(m.length);
                        for (let _ = 0; _ < m.length; _++) r += ay.varuint(m[_], r)
                    }
                    r += ax(a.length);
                    for (let f = 0; f < a.length; f++) {
                        let p = a[f];
                        r += 2;
                        let g = p.pos;
                        r += 4, r += 4;
                        let v = p.vel;
                        r += 4, r += 4, r += ax(v.length);
                        for (let y = 2; y < v.length; y++) {
                            r += 4, r += ax(g.length);
                            for (let b = 2; b < g.length; b++) r += 4
                        }
                    }
                    r += 4;
                    let x = new Uint8Array(r);
                    av = 0, ak(x, e._header), ab(x, i.length);
                    for (let w = 0; w < i.length; w++) {
                        let k = i[w];
                        a4(x, k.id), ak(x, k.jump), a5(x, k.rot), a4(x, k.speed);
                        let C = k.steer;
                        a9(x, C[0]), ab(x, C.length);
                        for (let S = 1; S < C.length; S++) a9(x, C[S])
                    }
                    ab(x, s.length);
                    for (let E = 0; E < s.length; E++) {
                        let P = s[E],
                            M = P.data;
                        ak(x, P.type), ab(x, M.length);
                        for (let D = 0; D < M.length; D++) ab(x, M[D])
                    }
                    ab(x, n.length);
                    for (let T = 0; T < n.length; T++) {
                        let A = n[T],
                            R = A.data;
                        ak(x, A.type), ab(x, R.length);
                        for (let F = 0; F < R.length; F++) ab(x, R[F])
                    }
                    ab(x, a.length);
                    for (let N = 0; N < a.length; N++) {
                        let I = a[N];
                        a4(x, I.id);
                        let U = I.pos;
                        a5(x, U[0]), a5(x, U[1]);
                        let z = I.vel;
                        a5(x, z[0]), a5(x, z[1]), ab(x, z.length);
                        for (let O = 2; O < z.length; O++) {
                            a5(x, z[O]), ab(x, U.length);
                            for (let L = 2; L < U.length; L++) a5(x, U[L])
                        }
                    }
                    return a7(x, e.tickId), x
                }
            },
            serverPartyUpdate: {
                decode(t) {
                    let e = t,
                        i = {};
                    av = 0, i._header = a3(e), av += 1;
                    let s = [];
                    i.members = s;
                    let n = a0(e);
                    for (let a = 0; a < n; a++) {
                        let r = {};
                        s[a] = r, r.class = a3(e), av += 1, r.entityid = aC(e), av += 2, r.level = a3(e), av += 1, r.name = aR(e), r.role = aC(e), av += 2, r.world = aR(e)
                    }
                    let l = [];
                    i.queues = l;
                    let o = a0(e);
                    for (let c = 0; c < o; c++) l[c] = aR(e);
                    return i
                },
                encode(t) {
                    let e = t,
                        i = e.members,
                        s = e.queues,
                        n = 0;
                    n += 1, n += ax(i.length);
                    for (let a = 0; a < i.length; a++) {
                        let r = i[a];
                        n += 1, n += 2, n += 1, n += ay.string(r.name, n), n += 2, n += ay.string(r.world, n)
                    }
                    n += ax(s.length);
                    for (let l = 0; l < s.length; l++) n += ay.string(s[l], n);
                    let o = new Uint8Array(n);
                    av = 0, ak(o, e._header), ab(o, i.length);
                    for (let c = 0; c < i.length; c++) {
                        let d = i[c];
                        ak(o, d.class), a4(o, d.entityid), ak(o, d.level), a8(o, d.name), a4(o, d.role), a8(o, d.world)
                    }
                    ab(o, s.length);
                    for (let u = 0; u < s.length; u++) a8(o, s[u]);
                    return o
                }
            },
            serverWarUpdate: {
                decode(t) {
                    let e = t,
                        i = {};
                    av = 0, i._header = a3(e), av += 1, i.contrib = a0(e);
                    let s = [];
                    i.contributors = s;
                    let n = a0(e);
                    for (let a = 0; a < n; a++) {
                        let r = {};
                        s[a] = r, r.class = a3(e), av += 1, r.faction = a3(e), av += 1, r.level = a3(e), av += 1, r.name = aR(e);
                        let l = [];
                        r.stats = l;
                        let o = a0(e);
                        for (let c = 0; c < o; c++) l[c] = a0(e)
                    }
                    i.duration = a0(e);
                    let d = [];
                    i.kills = d, d[0] = a0(e);
                    let u = a0(e);
                    for (let $ = 1; $ < u; $++) d[$] = a0(e);
                    return i.level = a0(e), i.reward = a0(e), i.status = a3(e), av += 1, i
                },
                encode(t) {
                    let e = t,
                        i = e.contributors,
                        s = e.kills,
                        n = 0;
                    n += 1, n += ay.varuint(e.contrib, n), n += ax(i.length);
                    for (let a = 0; a < i.length; a++) {
                        let r = i[a];
                        n += 1, n += 1, n += 1, n += ay.string(r.name, n);
                        let l = r.stats;
                        n += ax(l.length);
                        for (let o = 0; o < l.length; o++) n += ay.varuint(l[o], n)
                    }
                    n += ay.varuint(e.duration, n), n += ay.varuint(s[0], n), n += ax(s.length);
                    for (let c = 1; c < s.length; c++) n += ay.varuint(s[c], n);
                    n += ay.varuint(e.level, n), n += ay.varuint(e.reward, n), n += 1;
                    let d = new Uint8Array(n);
                    av = 0, ak(d, e._header), ab(d, e.contrib), ab(d, i.length);
                    for (let u = 0; u < i.length; u++) {
                        let $ = i[u];
                        ak(d, $.class), ak(d, $.faction), ak(d, $.level), a8(d, $.name);
                        let h = $.stats;
                        ab(d, h.length);
                        for (let m = 0; m < h.length; m++) ab(d, h[m])
                    }
                    ab(d, e.duration), ab(d, s[0]), ab(d, s.length);
                    for (let _ = 1; _ < s.length; _++) ab(d, s[_]);
                    return ab(d, e.level), ab(d, e.reward), ak(d, e.status), d
                }
            },
            serverPartyPositions: {
                decode(t) {
                    let e = t,
                        i = {};
                    av = 0, i._header = a3(e), av += 1;
                    let s = [];
                    i.members = s;
                    let n = a0(e);
                    for (let a = 0; a < n; a++) {
                        let r = {};
                        s[a] = r, r.entityid = aC(e), av += 2;
                        let l = [];
                        r.pos = l;
                        let o = a0(e);
                        for (let c = 0; c < o; c++) l[c] = aC(e), av += 2
                    }
                    return i
                },
                encode(t) {
                    let e = t,
                        i = e.members,
                        s = 0;
                    s += 1, s += ax(i.length);
                    for (let n = 0; n < i.length; n++) {
                        s += 2;
                        let a = i[n].pos;
                        s += ax(a.length);
                        for (let r = 0; r < a.length; r++) s += 2
                    }
                    let l = new Uint8Array(s);
                    av = 0, ak(l, e._header), ab(l, i.length);
                    for (let o = 0; o < i.length; o++) {
                        let c = i[o];
                        a4(l, c.entityid);
                        let d = c.pos;
                        ab(l, d.length);
                        for (let u = 0; u < d.length; u++) a4(l, d[u])
                    }
                    return l
                }
            },
            serverChangeWorld: {
                decode(t) {
                    let e = t,
                        i = {};
                    return av = 0, i._header = a3(e), av += 1, i.world = aR(e), i
                },
                encode(t) {
                    let e = t,
                        i = 0;
                    i += 1, i += ay.string(e.world, i);
                    let s = new Uint8Array(i);
                    return av = 0, ak(s, e._header), a8(s, e.world), s
                }
            },
            serverMapUpdate: {
                decode(t) {
                    let e = t,
                        i = {};
                    av = 0, i._header = a3(e), av += 1;
                    let s = [];
                    i.icons = s;
                    let n = a0(e);
                    for (let a = 0; a < n; a++) {
                        let r = {};
                        s[a] = r, r.blink = !!a1(e), av += 1, r.id = a3(e), av += 1;
                        let l = [];
                        r.pos = l, l[0] = aC(e), av += 2;
                        let o = a0(e);
                        for (let c = 1; c < o; c++) l[c] = aC(e), av += 2
                    }
                    return i
                },
                encode(t) {
                    let e = t,
                        i = e.icons,
                        s = 0;
                    s += 1, s += ax(i.length);
                    for (let n = 0; n < i.length; n++) {
                        s += 1, s += 1;
                        let a = i[n].pos;
                        s += 2, s += ax(a.length);
                        for (let r = 1; r < a.length; r++) s += 2
                    }
                    let l = new Uint8Array(s);
                    av = 0, ak(l, e._header), ab(l, i.length);
                    for (let o = 0; o < i.length; o++) {
                        let c = i[o];
                        a9(l, c.blink ? 1 : 0), ak(l, c.id);
                        let d = c.pos;
                        a4(l, d[0]), ab(l, d.length);
                        for (let u = 1; u < d.length; u++) a4(l, d[u])
                    }
                    return l
                }
            },
            serverChat: {
                decode(t) {
                    let e = t,
                        i = {};
                    av = 0, i._header = a3(e), av += 1;
                    let s = [];
                    i.messages = s;
                    let n = a0(e);
                    for (let a = 0; a < n; a++) {
                        let r = {};
                        s[a] = r, r.channel = aR(e), r.clan = aR(e), r.class = a3(e), av += 1, r.faction = a3(e), av += 1, r.from = aR(e), r.id = aS(e), av += 4, r.level = a3(e), av += 1, r.message = aR(e), r.subscribed = a3(e), av += 1
                    }
                    return i
                },
                encode(t) {
                    let e = t,
                        i = e.messages,
                        s = 0;
                    s += 1, s += ax(i.length);
                    for (let n = 0; n < i.length; n++) {
                        let a = i[n];
                        s += ay.string(a.channel, s), s += ay.string(a.clan, s), s += 1, s += 1, s += ay.string(a.from, s), s += 4, s += 1, s += ay.string(a.message, s), s += 1
                    }
                    let r = new Uint8Array(s);
                    av = 0, ak(r, e._header), ab(r, i.length);
                    for (let l = 0; l < i.length; l++) {
                        let o = i[l];
                        a8(r, o.channel), a8(r, o.clan), ak(r, o.class), ak(r, o.faction), a8(r, o.from), a7(r, o.id), ak(r, o.level), a8(r, o.message), ak(r, o.subscribed)
                    }
                    return r
                }
            },
            serverSystemMessage: {
                decode(t) {
                    let e = t,
                        i = {};
                    av = 0, i._header = a3(e), av += 1;
                    let s = [];
                    i.messages = s;
                    let n = a0(e);
                    for (let a = 0; a < n; a++) {
                        let r = {};
                        s[a] = r, r.message = aR(e), r.type = aR(e)
                    }
                    return i
                },
                encode(t) {
                    let e = t,
                        i = e.messages,
                        s = 0;
                    s += 1, s += ax(i.length);
                    for (let n = 0; n < i.length; n++) {
                        let a = i[n];
                        s += ay.string(a.message, s), s += ay.string(a.type, s)
                    }
                    let r = new Uint8Array(s);
                    av = 0, ak(r, e._header), ab(r, i.length);
                    for (let l = 0; l < i.length; l++) {
                        let o = i[l];
                        a8(r, o.message), a8(r, o.type)
                    }
                    return r
                }
            },
            ping: {
                decode(t) {
                    let e = t,
                        i = {};
                    return av = 0, i._header = a3(e), av += 1, i.id = a3(e), av += 1, i
                },
                encode(t) {
                    let e = t,
                        i = 0;
                    i += 1, i += 1;
                    let s = new Uint8Array(i);
                    return av = 0, ak(s, e._header), ak(s, e.id), s
                }
            }
        },
        aN = {
            chunk: {
                decode(t) {
                    let e = t,
                        i = {};
                    av = 0, i.color = aT(e);
                    let s = [];
                    i.props = s;
                    let n = a0(e);
                    for (let a = 0; a < n; a++) {
                        let r = {};
                        s[a] = r, r.id = aS(e), av += 4, r.rx = a2(e), av += 2, r.ry = a2(e), av += 2, r.rz = a2(e), av += 2, r.scale = aC(e), av += 2, r.x = aC(e), av += 2, r.y = aS(e), av += 4, r.z = aC(e), av += 2
                    }
                    return i.terrain = aT(e), i
                },
                encode(t) {
                    let e = t,
                        i = e.props,
                        s = 0;
                    s += ay.buffer16(e.color, s), s += ax(i.length);
                    for (let n = 0; n < i.length; n++) i[n], s += 4, s += 2, s += 2, s += 2, s += 2, s += 2, s += 4, s += 2;
                    s += ay.buffer16(e.terrain, s);
                    let a = new Uint8Array(s);
                    av = 0, aD(a, e.color), ab(a, i.length);
                    for (let r = 0; r < i.length; r++) {
                        let l = i[r];
                        a7(a, l.id), a4(a, l.rx), a4(a, l.ry), a4(a, l.rz), a4(a, l.scale), a4(a, l.x), a7(a, l.y), a4(a, l.z)
                    }
                    return aD(a, e.terrain), a
                }
            },
            modelformat: {
                decode(t) {
                    let e = t,
                        i = {};
                    av = 0;
                    let s = [];
                    i.coll = s;
                    let n = a0(e);
                    for (let a = 0; a < n; a++) s[a] = a0(e);
                    let r = [];
                    i.index = r;
                    let l = a0(e);
                    for (let o = 0; o < l; o++) r[o] = a0(e);
                    let c = [];
                    i.normal = c;
                    let d = a0(e);
                    for (let u = 0; u < d; u++) c[u] = a1(e), av += 1;
                    let $ = [];
                    i.position = $;
                    let h = a0(e);
                    for (let m = 0; m < h; m++) $[m] = a1(e), av += 1;
                    i.sx = aS(e), av += 4, i.sy = aS(e), av += 4, i.sz = aS(e), av += 4;
                    let _ = [];
                    i.uv = _;
                    let f = a0(e);
                    for (let p = 0; p < f; p++) _[p] = a3(e), av += 1;
                    return i
                },
                encode(t) {
                    let e = t,
                        i = e.coll,
                        s = e.index,
                        n = e.normal,
                        a = e.position,
                        r = e.uv,
                        l = 0;
                    l += ax(i.length);
                    for (let o = 0; o < i.length; o++) l += ay.varuint(i[o], l);
                    l += ax(s.length);
                    for (let c = 0; c < s.length; c++) l += ay.varuint(s[c], l);
                    l += ax(n.length);
                    for (let d = 0; d < n.length; d++) l += 1;
                    l += ax(a.length);
                    for (let u = 0; u < a.length; u++) l += 1;
                    l += 4, l += 4, l += 4, l += ax(r.length);
                    for (let $ = 0; $ < r.length; $++) l += 1;
                    let h = new Uint8Array(l);
                    av = 0, ab(h, i.length);
                    for (let m = 0; m < i.length; m++) ab(h, i[m]);
                    ab(h, s.length);
                    for (let _ = 0; _ < s.length; _++) ab(h, s[_]);
                    ab(h, n.length);
                    for (let f = 0; f < n.length; f++) a9(h, n[f]);
                    ab(h, a.length);
                    for (let p = 0; p < a.length; p++) a9(h, a[p]);
                    a7(h, e.sx), a7(h, e.sy), a7(h, e.sz), ab(h, r.length);
                    for (let g = 0; g < r.length; g++) ak(h, r[g]);
                    return h
                }
            }
        },
        aI = [],
        aU = 0;
    for (let az in aF) aF[az] && (aF[az].header = aU++, aF[az].packData = function(t) {
        return this.prepareData && this.prepareData(t), t._header = this.header, this.encode(t)
    }, aI.push(aF[az]));
    let aO = t => {
            if (0 === t.length) return;
            let e = aI[t[0]];
            return e && e.maxSize < t.length ? void 0 : e
        },
        aL = (t, e, i) => Math.min(Math.max(t, e), i),
        aB = (t, e) => (t % e + e) % e,
        aq = (t, e, i) => {
            let s = aL((i - t) / (e - t), 0, 1);
            return s * s * (3 - 2 * s)
        },
        aV = {
            linear: t => t,
            easeInQuad: t => t * t,
            easeInQuart: t => t ** 4,
            easeOutQuad: t => t * (2 - t),
            easeOutExpo: t => 1 - Math.pow(2, -10 * t),
            easeOutFlick: t => 1 - Math.pow(1 - t, 10),
            sin: t => Math.sin(3.14 * t),
            sinReverse: t => 1 - Math.sin(3.14 * t),
            easeInOutCubic: t => t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,
            easeInOutQuint: t => t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t,
            easeBounce: t => t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375,
            anticipate: t => -1 / (1 + Math.exp(50 * (t - .5))) + 1.4 * Math.sin(6.2 * (t - .5)) * (1 - .5 * t) + 1,
            flicker: t => Math.sin(3.14 * t) * (1 + .3 * Math.sin(38 * t))
        },
        aW = [aV.linear, aV.easeInQuad, aV.easeInQuart, aV.easeOutQuad, aV.easeOutExpo, aV.easeOutFlick, aV.sin, aV.sinReverse, aV.easeInOutCubic, aV.easeInOutQuint, aV.easeBounce, aV.anticipate, aV.flicker];
    class aH {
        constructor(t = 0, e = 0) {
            this.start = t, this.end = t + e, this.duration = e
        }
        done(t) {
            return t > this.end
        }
        fraction(t) {
            return aL(1 - (this.end - t) / this.duration, 0, 1)
        }
        remaining(t) {
            return this.end - t
        }
        passed(t) {
            return t - this.start
        }
        reset(t, e = this.duration) {
            return this.start = t, this.end = t + e, this.duration = e, !0
        }
        set(t, e) {
            return this.start = t, this.end = e, this.duration = this.end - this.start, !0
        }
    }
    let aj = .016,
        aG = t => {
            aj = (10 * aj + t) / 11
        },
        aY = 0,
        aQ = 0,
        aX = t => {
            aY = t
        },
        aJ = 0,
        aK = t => {
            aJ = (2 * aJ + t) / 3
        },
        aZ = 0,
        rt = new aH(0, .05),
        re = t => {
            aG(t), sO.showFpsPing && rt.done(as.time) && (aQ = (10 * aQ + aY) / 11, aZ = (5 * aZ + as.netData.length) / 6, rt.reset(as.time), e9.update(t => (t[0] = aL(aJ >> 0, 1, 999), t[1] = (1 / aj).toFixed(1), t[2] = (aQ / 1e3).toFixed(1), t[3] = as.player ? `${~~as.player.pos[0]} ${~~as.player.pos[1]} ${~~as.player.pos[2]}` : "-", t[4] = aZ.toFixed(1), t)))
        },
        ri = t => {
            rt.reset(t.time)
        },
        rs = Object.freeze({
            __proto__: null,
            parseFrameDelta: aG,
            parseBandwidth: aX,
            parseLatency: aK,
            tick: re,
            onWorldEnter: ri
        }),
        rn = performance,
        ra = () => rn.now(),
        rr, rl = 0,
        ro = 0,
        rc = (t, e) => {
            rf(aF.serverOnClientConnect.header, e => {
                t(aF.serverOnClientConnect.decode(e))
            }), rf("close", t => {
                e(t.code)
            })
        },
        rd = {
            open: [],
            close: []
        };
    for (let ru in aF) rd[aF[ru].header] = [];
    let r$ = t => {},
        rh = t => {
            console.log("Connected"), rl = 1;
            for (let e = 0, i = rd.open.length; e < i; ++e) rd.open[e](t)
        },
        rm = t => {
            console.log("Connection closed:", t.reason, t.code), rl = 0, rr.close(), rr = void 0;
            for (let e = 0, i = rd.close.length; e < i; ++e) rd.close[e](t)
        },
        r_ = t => {
            r0(t.data.byteLength), t = new Uint8Array(t.data);
            let e = aO(t),
                i = e && rd[e.header];
            if (i)
                for (let s = 0, n = i.length; s < n; ++s) i[s](t)
        },
        rf = (t, e) => {
            rd[t].push(e)
        },
        rp = t => {
            void 0 !== rr && 1 === rl && rr.send(t)
        },
        rg = t => {
            void 0 === rr && ((rr = new WebSocket("wss://hordes.io:" + t + "/play")).binaryType = "arraybuffer", rr.onerror = r$, rr.onopen = rh, rr.onclose = rm, rr.onmessage = r_)
        },
        rv = 0,
        ry = 0,
        r0 = t => {
            ry += t, af - rv > 250 && (ro = 4 * ry, ry = 0, rv = af, aX(ro))
        },
        rb = () => {
            sO.showFpsPing && af - r1 > (r9.length < 10 ? 100 : 2e3) && (r1 = af, r3())
        },
        rx = t => {
            if (r9[t.id]) {
                let e = ra();
                if (r9[t.id] <= e) {
                    let i = e - r9[t.id];
                    aK(i)
                }
            }
        },
        rw = 0,
        r1 = 0,
        r9 = [],
        r3 = () => {
            rw > 254 && (rw = 0), r9[rw] = ra(), rp(aF.ping.packData({
                id: rw
            })), rw++
        },
        rk = (t, e, i) => i.items[t]["book" == t ? Math.floor(e / 5) : e],
        r2 = (t, e, i) => rk(t, e, i).name + ("book" == t ? " Lv. " + (e % 5 + 1) : ""),
        r4 = (t, e, i) => rk(t, e, i).description,
        rC;
    io.subscribe(async t => {
        await fetch(`/assets/loc/${t}.json?v=5699699`).then(async t => {
            rC = await t.json(), en.set(!0)
        })
    });
    let rS = (t, e) => r2(t, e, rC),
        r7 = (t, e) => r4(t, e, rC),
        rE = new Map,
        r6 = !1,
        rP = () => {
            fetch("/assets/ui/circlecooldowns/circlecooldowns.txt?v=5699699").then(async t => {
                let e = (await t.text()).split("\n");
                for (let i = 0; i < 3; ++i) {
                    let s = [];
                    for (let n = 0; n < 101; ++n) {
                        let a = new Image;
                        a.src = e.shift(), s.push([a])
                    }
                    rE.set([40, 31, 23][i], s)
                }
                r6 = !0
            })
        },
        rM = (t, e, i) => {
            r6 && e && t !== e.step && (void 0 !== e.cdimg && (rE.get(i)[e.step].push(e.removeChild(e.cdimg)), e.cdimg = void 0), (e.step = t) > 0 && (1 === rE.get(i)[e.step].length ? e.cdimg = rE.get(i)[e.step][0].cloneNode() : e.cdimg = rE.get(i)[e.step].pop(), e.appendChild(e.cdimg)))
        },
        r5 = Object.freeze({
            __proto__: null,
            init: rP,
            updateCd: rM
        }),
        rD = [1600, 1800, 2e3, 2200],
        rT = rD.length,
        rA = t => {
            for (let e = 0; e < rT; ++e)
                if (rD[e] > t) return e;
            return Math.max(0, rT)
        },
        r8 = t => 10 + Math.round(Math.max(t / 30, 240 * (1 - Math.exp(-.0015 * (t - 930))) - 100)),
        rR = "webp",
        rF = "webp",
        rN = [0, 0, 1, 1, 2, 3],
        rI = (t, e) => "book" + (void 0 !== e ? e : "") + rN[t % 5],
        rU = (t, e, i, s) => `/assets/items/${t}/${"book"==t?rI(e,i):t+e}_q${s}.${rF}?v=5699699`,
        rz = t => `/assets/ui/skills/${t}.${rF}?v=5699699`,
        rO = t => `/assets/ui/slotbg/${t}.${rR}?v=5699699`,
        rL = t => `/assets/ui/maps/${t}.${rF}?v=5699699`,
        rB = t => `/assets/ui/classes/${t}.${rR}?v=5699699`,
        rq = t => `/assets/ui/factions/${t}.${rR}?v=5699699`,
        rV = t => `/assets/ui/elo/${rA(t)}.svg?v=5699699`,
        rW = "/assets/ui/currency/prestige.svg?v=5699699",
        rH = "/assets/ui/currency/fame.svg?v=5699699",
        rj = t => `/assets/ui/rank/rank${t}.svg?v=5699699`,
        rG = t => {
            let e = (t || 0).toString().split("");
            return {
                c: e.splice(-2).join(""),
                s: e.splice(-2).join(""),
                g: e.join("")
            }
        },
        rY = (t, e = !0) => {
            let i = Object.entries(t);
            return i.forEach(t => {
                t[0] = parseInt(t[0]), e && "object" == typeof t[1] && (t[1] = rY(t[1]))
            }), new Map(i)
        },
        rQ = t => t >= 1e4 ? (t / 1e3).toFixed(1) + "k" : rX(t),
        rX = t => t < 1e3 ? t + "" : rX(~~(t / 1e3)) + "," + ("00" + ~~(t % 1e3)).substr(-3, 3),
        rJ = (t, e) => t.length > e ? t.slice(0, e - 2) + "..." : t,
        rK = rY({
            14: .1,
            13: .1,
            9: .1,
            8: .1,
            16: .1
        }),
        rZ = rY({
            14: "%",
            13: "%",
            16: "%",
            18: "%"
        }),
        lt = (t, e) => (rK.has(t) && (e = (e *= rK.get(t)).toFixed(e >= .1 ? 1 : 2)), e + (rZ.get(t) || "")),
        le = t => t.replace(/\$e(\d+)/g, (t, e) => lr(e)),
        li = t => t.replace(/\$g(\d+)/g, (t, e) => ln(e, !1)),
        ls = t => t.replace(/\$m(\d+)/g, (t, e) => la(e, !1)),
        ln = (t, e = !1) => {
            let {
                c: i,
                s: s,
                g: n
            } = rG(t), a = "<span/>";
            return "" != n && (a += `<span class=${e?"textred":"textgold"}>${n}</span> <img class=texticon src='/assets/ui/currency/gold.${rR}?v=5699699'/>`), "" != s && (a += `<span class=${e?"textred":"textsilver"}>${s}</span> <img class=texticon src='/assets/ui/currency/silver.${rR}?v=5699699'/>`), "" != i && (a += `<span class=${e?"textred":"textcopper"}>${i}</span> <img class=texticon src='/assets/ui/currency/copper.${rR}?v=5699699'/>`), a + "</span>"
        },
        la = (t, e = !1) => `<span class='${e?"textred":"textgold"}'><img class='svgicon' src='/assets/ui/currency/medal.svg?v=5699699'> ${rX(t)}</span>`,
        lr = t => `<span class='bold textpvp'><img class='svgicon' src='${rV(t)}'> ${rX(t)}</span>`,
        ll = (t, e) => `<span class='bold textprimary'><img class='svgicon' src='${rj(t)}'> ${e}</span>`,
        lo = [t => t.replace(/\$c(\d)/g, (t, e) => `<img class=texticon src='${rB(e)}'>`), t => t.replace(/\$l(\d+)/g, (t, e) => `<span class=textwhite>${e}</span>`), t => t.replace(/\$f(\d)(\w*)/g, (t, e, i) => `<span class=textf${e}>${i}</span>`), li, t => t.replace(/\$fm(\d+)/g, (t, e) => `<span class=textfame><img class=svgicon src='/assets/ui/currency/fame.svg?v=5699699'> ${e}</span>`), t => t.replace(/\$gt/g, (t, e) => '<img class="svgicon" src="/assets/ui/icons/check.svg?v=5699699">'), t => t.replace(/\$sp(\d+)/g, (t, e) => "<img class=texticon src=/assets/ui/icons/gem.svg?v=5699699/>" + e), ls, le],
        lc = t => lo.reduce((t, e) => e(t), t),
        ld = 4294967296 - 1,
        lu = t => {
            t = aN.modelformat.decode(t);
            let e = 127 / (ld / t.sx),
                i = 127 / (ld / t.sy),
                s = 127 / (ld / t.sz);
            for (let n = 0; n < t.position.length; n += 3) t.position[n + 0] = t.position[n + 0] / e, t.position[n + 1] = t.position[n + 1] / i, t.position[n + 2] = t.position[n + 2] / s;
            if (0 == t.uv.length) t.uv.length = t.position.length / 3 * 2, t.emptyUv = !0;
            else
                for (let a = 0; a < t.uv.length; ++a) t.uv[a] /= 254;
            for (let r = 0, l = t.position.length; r < l; r++) t.normal[r] = t.normal[r] / 127;
            return t
        },
        l$ = async (t, e, i, s, n, a = 3) => {
            switch (e.split(".").pop()) {
                case "jpg":
                case "png":
                case "webp": {
                    let r = new Image;
                    r.onload = () => {
                        i[e] = s(r), n(i[e], t + e), r.onload = void 0
                    }, r.src = t + e + "?v=5699699";
                    break
                }
                default:
                    fetch(t + e + "?v=5699699").then(a => {
                        if (!a.ok) throw Error();
                        a.arrayBuffer().then(async a => {
                            i[e] = await s(a), n(i[e], t + e)
                        })
                    }).catch(r => {
                        console.log(e + " fetch failed"), a > 1 && l$(t, e, i, s, n, --a)
                    })
            }
        }, lh = {}, lm = (t, e) => {
            for (let i = 0, s = lh[e].length; i < s; ++i) lh[e][i](...t);
            lh[e] = void 0
        }, l_ = async (t, e, i, s, n) => {
            i[e] ? n(...i[e]) : lh[t + e] ? lh[t + e].push(n) : (lh[t + e] = [], lh[t + e].push(n), l$(t, e, i, s, lm))
        }, lf = t => {
            let e = lu(new Uint8Array(t));
            return [{
                position: {
                    size: 3,
                    data: new Float32Array(e.position)
                },
                index: {
                    type: 5125,
                    data: new Uint32Array(e.index)
                },
                uv: {
                    size: 2,
                    data: new Float32Array(e.uv)
                },
                normal: {
                    size: 3,
                    data: new Float32Array(e.normal)
                }
            }, e]
        }, lp = {}, lg = (t, e) => {
            l_("assets/game/", k(t), lp, lf, e)
        }, lv, ly = {
            terrain: []
        }, l0, lb = () => {
            lv = new nU(ae.geometry, void 0, nK.TRIANGLES), fetch("/assets/items/atlas.json?v=5699699").then(async t => {
                for (let e in l0 = await t.json()) "s" != e && (l0[e] = l0[e].map(t => t / l0.s))
            })
        }, lx = t => {
            let e = new nq(nK, {
                wrapS: nK.REPEAT,
                wrapT: nK.REPEAT,
                minFilter: nK.LINEAR_MIPMAP_LINEAR
            });
            return e.image = t, [e]
        }, lw = {}, l1 = (t, e) => {
            l_("assets/game/", k(t, !0), lw, lx, e)
        }, l9 = (t, e, i) => {
            lv.program = new n$(i.gl, {
                vertex: nJ,
                fragment: t,
                uniforms: {
                    seed: {
                        value: Date.now() % 1e3
                    }
                }
            });
            let s = new nV(i.gl, {
                width: e,
                height: e,
                wrapT: i.gl.REPEAT,
                wrapS: i.gl.REPEAT
            });
            return i.render({
                scene: [lv.transform],
                target: s
            }), s.texture
        }, l3, lk = (t, e, i) => {
            l3 = e, l_("assets/game/", t + ".ogg", lw, l2, i)
        }, l2 = async t => [await l3.decodeAudioData(t)], l4 = (t, e) => t + Math.random() * (e - t), lC = (t, e) => Math.floor(Math.random() * (e - t + 1)) + t, lS = t => l7(t, Math.random()), l7 = (t, e) => t[Math.floor(e * t.length)], lE, l6 = [], lP = new Map, lM = new Map, l5 = new Set, lD = t => {
            lE && (lT(), lA(), l5.clear())
        }, lT = () => {
            l8(lE.listener, nZ.transform.worldMatrix), n0(a$, at.worldMatrix), sW(ar, 0, 0, 1), nn(ar, ar, a$), sW(al, 0, 1, 0), nn(al, al, a$), lE.listener.setOrientation(ar[0], ar[1], ar[2], al[0], al[1], al[2])
        }, lA = t => {
            let e = 0,
                i = 0;
            for (; i < l6.length;) {
                let s = l6[i];
                s.ended ? lF(s.id) : (l6[e] = s, e++), ++i
            }
            l6.length = e
        }, l8 = (t, e) => {
            t.setPosition(e[12], e[13], e[14])
        }, lR = function() {
            this.ended = !0
        }, lF = t => {
            lM.set(t, Math.max(0, lM.get(t) - 1))
        }, lN = (t, e) => {
            if (lM.has(t)) {
                if (lM.get(t) >= e) return !1;
                lM.set(t, lM.get(t) + 1)
            } else lM.set(t, 1);
            return !0
        }, lI = {}, lU = (t, e) => {
            let i = lS(t);
            void 0 !== lI[i] ? e.buffer = lI[i] : lk(i, lE, t => {
                lI[i] = t, e.buffer = t
            })
        }, lz = (t, e, i, s, n) => {
            if (void 0 === lE || "suspended" == lE.state || l5.has(t) > 0) return;
            if (0 === i) {
                if (l6.length > 35 || (sW(ar, e.worldMatrix[12], e.worldMatrix[13], e.worldMatrix[14]), 1 / ((lM.get(t) || 0) + 10 + sJ(at.position, ar)) * 1e3 / (l6.length + 20) ** 1.2 < .4) || !lN(t, 2)) return
            } else if (1 === i && !lN(t, 5)) return;
            let a = o.get(t);
            if (!a) return void console.log("unknown sound id:" + t);
            l5.add(t);
            let r = lE.createBufferSource();
            r.id = t, r.loop = s, r.playbackRate.value = n, lU(a.files, r);
            let l = lP.get(i).in;
            return r.panner = lE.createPanner(), r.panner.distanceModel = "exponential", r.panner.refDistance = a.distance, r.panner.rolloffFactor = 1, l8(r.panner, e.worldMatrix), r.connect(r.panner), r.panner.connect(l), r.start(0, 0), r.onended = lR, l6.push(r), r
        }, lO = (t, e, i, s) => {
            if (void 0 === lE || "suspended" == lE.state) return;
            let n = o.get(t);
            if (!n) return void console.log("unknown sound id:" + t);
            let a = lE.createBufferSource();
            a.id = t, a.loop = i, lU(n.files, a);
            let r = lP.get(e).in;
            return s && (a.gain = lE.createGain(), a.gain.connect(r), r = a.gain), a.connect(r), a.start(0, i ? l4(0, 1) : 0), a.onended = lR, a
        }, lL = (t, e) => {
            let i = lO(t, 1, !1, void 0 !== e);
            void 0 !== e && (i.gain.gain.value = e)
        }, lB = (t, e) => lO(t, e, !0, !0), lq = t => {
            lE = new(window.AudioContext || window.webkitAudioContext), ["ambience", "music"].forEach((t, e) => {
                let i = lE.createGain();
                i.connect(lE.destination), lP.set(2 + e, {
                    gain: i,
                    in: i
                }), sB[t + "Volume"].subscribe(t => {
                    lP.get(2 + e).gain.gain.value = (t / 100) ** 2
                })
            });
            let e = lE.createDynamicsCompressor(),
                i = lE.createGain();
            e.threshold.value = 0, e.knee.value = 0, e.ratio.value = 15, e.attack.value = .005, e.release.value = .05, e.connect(i), i.connect(lE.destination);
            let s = lE.createGain();
            s.gain.value = 2, s.connect(e);
            let n = lE.createGain();
            n.gain.value = .4, n.connect(e), lP.set(1, {
                gain: i,
                in: s
            }), lP.set(0, {
                gain: i,
                in: n
            }), ia.subscribe(t => {
                lP.get(1).gain.gain.value = (t / 150) ** 2
            }), ir.subscribe(t => {
                lP.get(0).in.gain.value = t / 100
            }), er.set(!0), document.removeEventListener("click", lq)
        }, lV = !1, lW = (t, e) => {
            lV || (lV = !0, document.addEventListener("click", lq))
        }, lH = t => {
            l6.length = 0, lM.clear(), l5.clear()
        }, lj = 0, lG = new aH(0, 10), lY = (t, e, i = !1, s, n, a, r, l, o = 0) => {
            eo.update(c => {
                c.length > 100 && c.shift(), i && (e = lc(e)), "from" === t && (lG.done(as.time) && lL(97), lG.reset(as.time));
                let d = new Date;
                return c.push({
                    channel: t,
                    time: `${String(d.getHours()).padStart(2,"0")}.${String(d.getMinutes()).padStart(2,"0")}`,
                    text: e,
                    key: ++lj,
                    sender: s,
                    sub: l,
                    faction: n,
                    cclass: a,
                    level: r,
                    interpolate: i,
                    id: o
                }), c
            })
        }, lQ = {
            report: {
                client: !0
            },
            partyleave: {},
            partyinvite: {
                a: 1
            },
            partycreate: {},
            time: {},
            bosslog: {},
            global: {
                a: 1,
                chat: !0
            },
            party: {
                a: 1,
                chat: !0
            },
            clan: {
                a: 1,
                chat: !0
            },
            faction: {
                a: 1,
                chat: !0
            }
        }, lX = {
            itemmove: {
                a: 2
            },
            itemdrop: {
                a: 1
            },
            itemauctionpost: {
                a: 2
            },
            itemauctionfind: {
                a: 5
            },
            itemauctionbuy: {
                a: 1
            },
            itemauctioncancel: {
                a: 1
            },
            itemstash: {
                a: 1
            },
            itemunstash: {
                a: 1
            },
            itemsplithalf: {
                a: 1
            },
            itemsplitone: {
                a: 1
            },
            goldunstash: {
                a: 1
            },
            goldstash: {
                a: 1
            },
            itemtradersell: {
                a: 1
            },
            itemtraderbuy: {
                a: 1
            },
            itemblacksmithupgrade: {
                a: 1
            },
            petlootid: {
                a: 1
            },
            statincrease: {
                a: 2
            },
            skillconfig: {
                a: 1
            },
            respawn: {},
            startqueue: {
                a: 1
            },
            stopqueue: {
                a: 1
            },
            partyaccept: {
                a: 1
            },
            partydecline: {
                a: 1
            },
            partykick: {
                a: 1
            },
            partysetrole: {
                a: 2
            },
            summonaccept: {
                a: 1
            },
            whisper: {
                a: 2,
                chat: !0
            },
            ...lQ
        };
    lX.report.fun = t => {
        t.length >= 3 ? e3.set({
            name: t,
            reason: 0,
            reasonfixed: !1
        }) : lY("error", "Enter a player name to report", !0)
    };
    let lJ = new Map,
        lK = new aH(0, .5),
        lZ = () => {
            lJ.clear(), lK.reset(0)
        },
        ot = t => {
            if (sO.dpsmeterOpen && lK.done(as.time)) {
                if (lK.reset(as.time), lJ.forEach((t, e) => {
                        if (t.ooc) return void(as.time - t.start > 5 && lJ.delete(e));
                        !as.entity(t.id) || as.time - t.last > 5 ? (t.ooc = !0, t.start = as.time) : t.dps = Math.ceil(t.amount / Math.max(5, as.time - t.start))
                    }), sO.dpsmeterTarget) {
                    let e = lJ.get(sO.dpsmeterTarget);
                    e ? eU.set(Array.from(e.skills).sort((t, e) => e[1].amount - t[1].amount).map(t => (t[1].dps = Math.ceil(t[1].amount / Math.max(5, as.time - t[1].start)), t)).slice(0, 10)) : iw.set(0)
                } else eU.set(Array.from(lJ).sort((t, e) => e[1].amount - t[1].amount).slice(0, 10))
            }
        },
        oe = (t, e, i) => {
            if (void 0 === t.name || !sO.dpsmeterOpen || 0 !== t.type || sO.dpsmeterParty && (0 === as.player.party && t !== as.player || t.party !== as.player.party)) return;
            let s;
            lJ.has(t.name) ? s = lJ.get(t.name) : (lJ.set(t.name, s = {}), s.amount = 0, s.start = 0, s.class = t.class, s.dps = 0, s.id = t.id, s.ooc = !0, s.skills = new Map), s.ooc ? (s.start = as.time, s.ooc = !1, s.amount = e) : s.amount += e;
            let n = rC.items.book[i] ? rC.items.book[i].name : "Unknown";
            s.skills.has(n) || s.skills.set(n, {
                id: i,
                class: t.class,
                amount: 0,
                start: as.time
            }), s.skills.get(n).amount += e, s.last = as.time
        },
        oi = Object.freeze({
            __proto__: null,
            values: lJ,
            init: lZ,
            onWorldEnter: lZ,
            tick: ot,
            add: oe
        }),
        os = 2 * Math.PI,
        on = 3 * Math.PI,
        oa = t => t < 0 || t > os ? (t % os + os) % os : t,
        or = (t, e, i, s) => (sY(al, s, i), sY(ar, e, i), ne(al, al, ar), sZ(t, al)),
        ol = (t, e) => {
            let i = Math.sin(t[1]),
                s = Math.cos(t[1]);
            t[0] = e[2] * s + e[0] * i, t[2] = e[2] * i - e[0] * s
        },
        oo = t => {
            let e = Math.atan2(t[0], t[1]);
            return e < 0 && (e += 2 * Math.PI), e
        },
        oc = t => {
            let e = Math.atan2(t[0], t[2]);
            return e < 0 && (e += 2 * Math.PI), e
        },
        od = (t, e) => (e - t + on) % os - Math.PI,
        ou = (t, e, i, s) => {
            sQ(ar, e, 1 - s), sQ(al, i, s), sj(t, ar, al)
        },
        o$ = (t, e, i) => {
            sY(ar, i, t);
            let s = nt(ar, e);
            return sX(ar, t, e, s)
        },
        oh = (t, e, i, s, n) => {
            let a = sY(ar, i, e),
                r = sY(al, s, e),
                l = sY(ao, n, e),
                o = nt(a, a),
                c = nt(a, r),
                d = nt(r, r),
                u = -nt(l, a),
                $ = -nt(l, r),
                h = o * d - c * c,
                m = c * $ - d * u,
                _ = c * u - o * $;
            if (m + _ <= h) {
                if (m < 0) _ < 0 && u < 0 ? (_ = 0, m = -u >= o ? 1 : -u / o) : (m = 0, _ = $ >= 0 ? 0 : -$ >= d ? 1 : -$ / d);
                else if (_ < 0) _ = 0, m = u >= 0 ? 0 : -u >= o ? 1 : -u / o;
                else {
                    let f = 1 / h;
                    m *= f, _ *= f
                }
            } else if (m < 0) {
                let p = c + u,
                    g = d + $;
                if (g > p) {
                    let v = g - p,
                        y = o - 2 * c + d;
                    v >= y ? (m = 1, _ = 0) : _ = 1 - (m = v / y)
                } else m = 0, _ = g <= 0 ? 1 : $ >= 0 ? 0 : -$ / d
            } else if (_ < 0) {
                let b = c + $,
                    x = o + u;
                if (x > b) {
                    let w = x - b,
                        k = o - 2 * c + d;
                    w >= k ? (_ = 1, m = 0) : m = 1 - (_ = w / k)
                } else _ = 0, m = x <= 0 ? 1 : u >= 0 ? 0 : -u / o
            } else {
                let C = d + $ - c - u;
                if (C <= 0) m = 0, _ = 1;
                else {
                    let S = o - 2 * c + d;
                    C >= S ? (m = 1, _ = 0) : _ = 1 - (m = C / S)
                }
            }
            return sQ(t, r, _), sX(t, t, a, m), sj(t, e, t)
        },
        om = (t, e) => (t[0] = e[0], t[1] = e[2], t),
        o_ = (t, e, i) => (t[0] = e[0] + i[0], t[2] = e[2] + i[1], t),
        of = (t, e, i, s, n) => {
            sY(ar, e, s);
            let a = 2 * nt(i, ar),
                r = a * a - 4 * (nt(ar, ar) - n * n);
            r > 0 ? (t[0] = (-a - Math.sqrt(r)) / 2, t[1] = (-a + Math.sqrt(r)) / 2) : t[0] = t[1] = -1
        },
        op = (t, e, i, s, n, a) => {
            sY(ar, e, t), sY(al, i, t), ne(ao, ar, al);
            let r, l = nt(n, ao);
            if (l > 0) {
                if (!a) return 1 / 0;
                r = 1
            } else {
                if (!(l < 0)) return 1 / 0;
                r = -1, l = -l
            }
            sY(ac, s, t);
            let o = r * nt(n, ne(al, ac, al));
            if (o < 0) return 1 / 0;
            let c = r * nt(n, ne(ar, ar, ac));
            if (c < 0 || o + c > l) return 1 / 0;
            let d = -r * nt(ac, ao);
            return d < 0 ? 1 / 0 : d / l
        },
        og = (t, e, i, s) => {
            let n = 0,
                a = 0,
                r = 1;
            return e.length > 2 && ((n = s.findIndex(t => t >= i)) < 0 && (n = s.length), a = n > 0 ? s[n - 1] : 0, r = n >= s.length ? 1 : s[n]),
                function t(e, i, s, n) {
                    let a = i[0],
                        r = i[1],
                        l = i[2];
                    return e[0] = a + n * (s[0] - a), e[1] = r + n * (s[1] - r), e[2] = l + n * (s[2] - l), e
                }(t, e[n], e[n + 1], (i - a) / (r - a)), n
        },
        ov = [0, 0],
        oy = [0, 0],
        o0 = [0, 0],
        ob = {},
        ox = {},
        ow = function(t) {
            return this.press.push(t), t
        },
        o1 = function(t) {
            return this.release.push(t), t
        },
        o9 = (t, e) => (e.press || (e.down = !1, e.onPress = ow, e.onRelease = o1, e.press = [], e.release = [], e.mappings = [], e.store || (e.store = tX(!1))), (t = Array.isArray(t) ? t : [t]).forEach(t => {
            ox[t] = e, e.mappings.push(t)
        }), ea.set(ob), e),
        o3 = () => {
            o9(sO.kbForward, ob.fwd = {}), o9(sO.kbLeft, ob.left = {}), o9(sO.kbBack, ob.back = {}), o9(sO.kbRight, ob.right = {}), o9(sO.kbNextTarget, ob.nextTarget = {}), o9(sO.kbUntarget, ob.untarget = {}), o9(" ", ob.jump = {}), o9(sO.kbAltForward, ob.fwd), o9(sO.kbAltBack, ob.back), o9(sO.kbTurnRight, ob.turnright = {}), o9(sO.kbTurnLeft, ob.turnleft = {}), o9("shift", ob.shift = {}), o9("m0", ob.lmb = {}), o9("m2", ob.rmb = {}), o9("control", ob.ctrl = {}), o9("alt", ob.alt = {}), o9(sO.kbMap, ob.map = {}), o9(sO.kbSkills, ob.skills = {}).onPress(() => {
                i_.update(t => !t), lL(89)
            }), o9(sO.kbCharacter, ob.char = {}).onPress(() => {
                i1.update(t => !t), lL(89)
            }), o9(sO.kbInventory, ob.inventory = {}).onPress(() => {
                ih.update(t => !t), lL(90)
            }), o9(sO.kbClan, ob.clan = {}).onPress(() => {
                iy.update(t => !t), lL(90)
            }), o9(sO.kbPvp, ob.pvp = {}).onPress(() => {
                i0.update(t => !t), lL(90)
            }), document.addEventListener("wheel", oP, {
                passive: !0
            }), document.addEventListener("keydown", oD, !1), document.addEventListener("keyup", oT, !1), document.addEventListener("contextmenu", oM, !1), document.addEventListener("mousedown", oE, !1), document.addEventListener("mouseup", o6, !1), document.addEventListener("mousemove", o4, !1)
        },
        ok = t => {
            o7 && (o7 = !1, !sO.pointerlock || ob.lmb.down || ob.rmb.down || (document.exitPointerLock(), oS = !1))
        },
        o2 = 0,
        o4 = t => {
            if (nH(ov, t.x * sO.resolutionScale / nK.canvas.width * 2 - 1, 2 * (1 - t.y * sO.resolutionScale / nK.canvas.height) - 1), nH(oy, t.x, t.y), ob.rmb.down || ob.lmb.down) {
                let e = aL(t.movementX, -100, 100),
                    i = aL(t.movementY, -100, 100);
                o0[1] = o0[1] + .004 * i * (sO.invertMouseY ? -sO.mouseSensitivity : sO.mouseSensitivity), o0[0] = oa(o0[0] - .005 * e * (sO.invertMouseX ? -sO.mouseSensitivity : sO.mouseSensitivity)), o2 += Math.abs(i) + Math.abs(e)
            }
        },
        oC = !1;
    eh.subscribe(t => {
        oC = void 0 !== t
    });
    let oS = !1,
        o7 = !1,
        oE = t => {
            t.target != nK.canvas && "chat" != t.target.id || (sO.pointerlock && (oS = !0, nK.canvas.requestPointerLock()), o5("m" + t.button, !0), oC && eh.update(t => {
                t && t.discard && t.discard()
            }))
        },
        o6 = t => {
            o5("m" + t.button, !1), o2 = 0, o7 = !0
        },
        oP = t => {
            t.target == nK.canvas && ik.update(e => aL(e + (t.deltaY > 0 ? 1 : -1), 2, 18))
        },
        oM = t => {
            t.preventDefault()
        },
        o5 = (t, e, i) => {
            let s = ox[t];
            return void 0 !== s && (s.down != e && (s.down = e, s[e ? "press" : "release"].forEach(t => {
                t(i)
            }), s.store.set(s.down)), i && i.preventDefault(), !0)
        },
        oD = t => {
            if (!oA(t)) return;
            let e = t.key.toLowerCase();
            t.ctrlKey && o5("ctrl+" + e, !0, t) || t.shiftKey && o5("shift+" + e, !0, t) || o5(e, !0, t)
        },
        oT = t => {
            if (!oA(t)) return;
            let e = t.key.toLowerCase();
            o5("ctrl+" + e, !1), o5("shift+" + e, !1), o5(e, !1)
        },
        oA = t => {
            let e = t.target.tagName.toLowerCase();
            return "input" !== e && "textarea" !== e
        },
        o8, oR = {},
        oF = t => (void 0 === o8 && (o8 = getComputedStyle(document.body)), void 0 !== oR[t] ? oR[t] : oR[t] = o8.getPropertyValue("--" + t)),
        oN, oI = () => {
            (oN = ai.canvas2dContext).font = "bold 18px hordes", oN.fillText("Hordes", 0, 0)
        },
        oU = (t, e, i = 1, s = 1, n = 1, a = 1, r = 0, l = 0, o = .5, c = .5) => {
            oN.globalAlpha = sO.nameplateShowTransparency ? i : 1;
            let d = t.width * s,
                u = t.height * s,
                $ = Math.round(d * n),
                h = Math.round(u * a);
            return 0 === $ || 0 === h || oN.drawImage(t, 0, 0, Math.round(t.width * n), Math.round(t.height * a), Math.round(e[0] - d * o + r * s), Math.round(e[1] - u * c + l * s), $, h), $
        },
        oz = (t, e, i, s, n, a = 0, r = 0, l = .5, o = .5) => oU(oW(e, i), t, s, n, 1, 1, a, r, l, o),
        oO = (t, e, i, s, n = 0, a = 0, r = .5, l = .5) => oU(e, t, i, s, 1, 1, n, a, r, l),
        oL = (t, e, i = !1) => (i ? (e[0] = t[0], e[1] = t[1]) : ni(e, t, nZ.projectionViewMatrix), !!(i || e[2] < 1 && e[0] > -1 && e[0] < 1) && (e[1] = Math.max(-1, Math.min(e[1], 1)), e[0] = Math.round((.5 * e[0] + .5) * ai.canvas2dElement.width), e[1] = Math.round((-.5 * e[1] + .5) * ai.canvas2dElement.height), e[1] = Math.max(30, e[1]), e)),
        oB = (t, e, i) => {
            t.font = "bold " + e + "px hordes", t.shadowColor = "#000", t.shadowOffsetX = 1, t.shadowOffsetY = 1, t.fillStyle = i
        },
        oq = {
            name: {
                fill: oF("name"),
                size: 17
            },
            enemy: {
                fill: oF("enemy"),
                size: 17
            },
            pvp: {
                fill: oF("pvp"),
                size: 17
            },
            nameSmall: {
                fill: oF("name"),
                size: 13
            },
            enemySmall: {
                fill: oF("enemy"),
                size: 13
            },
            pvpSmall: {
                fill: oF("pvp"),
                size: 13
            },
            chatGlobal: {
                fill: oF("global"),
                size: 13,
                wrap: 150
            },
            chatClan: {
                fill: oF("clan"),
                size: 13,
                wrap: 150
            },
            chatParty: {
                fill: oF("party"),
                size: 13,
                wrap: 150
            },
            chatWhisper: {
                fill: oF("pvp"),
                size: 13,
                wrap: 150
            },
            lev0: {
                fill: "#919191",
                size: 13
            },
            lev1: {
                fill: oF("name"),
                size: 13
            },
            lev2: {
                fill: "#EEA303",
                size: 13
            },
            lev3: {
                fill: oF("enemy"),
                size: 13
            },
            clan: {
                fill: oF("clan"),
                size: 17
            },
            faction0: {
                fill: oF("f0"),
                size: 17
            },
            faction1: {
                fill: oF("f1"),
                size: 17
            },
            faction0small: {
                fill: oF("f0"),
                size: 13
            },
            faction1small: {
                fill: oF("f1"),
                size: 13
            },
            phys: {
                fill: oF("name"),
                size: 18
            },
            physCrit: {
                fill: oF("name"),
                size: 24
            },
            spell: {
                fill: "#FFE404",
                size: 28
            },
            spellCrit: {
                fill: "#FFE404",
                size: 40
            },
            heal: {
                fill: "#12F027",
                size: 28
            },
            mana: {
                fill: oF("mana"),
                size: 20
            },
            exp: {
                fill: oF("exp"),
                size: 20
            },
            fame: {
                fill: oF("fame"),
                size: 20
            },
            gold: {
                fill: "#EEDDA3",
                size: 16
            },
            misc: {
                fill: "#A6EBFA",
                size: 16
            },
            book: {
                fill: "#749DEF",
                size: 20
            },
            rune: {
                fill: "#DC9A4D",
                size: 20
            },
            itemgrey: {
                fill: "#747474",
                size: 16
            },
            common: {
                fill: "#dddddd",
                size: 20
            },
            uncommon: {
                fill: oF("green"),
                size: 20
            },
            rare: {
                fill: oF("blue"),
                size: 20
            },
            epic: {
                fill: oF("purp"),
                size: 20
            },
            pheal: {
                fill: "#12F027",
                size: 20
            },
            pdmg: {
                fill: oF("enemy"),
                size: 20
            }
        },
        oV = {},
        oW = (t, {
            fill: e,
            size: i,
            wrap: s = 0
        }) => {
            let n = t + e + i;
            if (oV[n]) return oV[n];
            let a = document.createElement("canvas"),
                r = a.getContext("2d");
            return r.font = "bold " + i + "px hordes", s > 0 ? oj(a, r, t, 0, 0, s, i, e) : (a.width = Math.max(1, Math.ceil(r.measureText(t).width)) + 5, a.height = Math.ceil(1.2 * i + 5), oB(r, i, e), r.fillText(t, 0, a.height - 6)), oV[n] = a, a
        },
        oH = (t, e, i, s, n, a, r) => {
            t || ((t = document.createElement("canvas")).width = i, t.height = s);
            let l = t.getContext("2d");
            return l.fillStyle = e, l.beginPath(), l.moveTo(n + r, a), l.arcTo(n + i, a, n + i, a + s, r), l.arcTo(n + i, a + s, n, a + s, r), l.arcTo(n, a + s, n, a, r), l.arcTo(n, a, n + i, a, r), l.closePath(), l.fill(), t
        },
        oj = (t, e, i, s, n, a, r, l) => {
            let o = i.split(" "),
                c = [],
                d = 0,
                u = "";
            for (let $ = 0; $ < o.length; ++$) {
                let h = u + o[$] + " ",
                    m = e.measureText(h);
                m.width > a ? (c.push(u), u = o[$] + " ") : (d = Math.max(d, m.width), u = h)
            }
            c.push(u), t.width = Math.ceil(d + 5), t.height = Math.ceil(c.length * r + 10), oH(t, "#00000099", t.width, t.height, 0, 0, 5), oB(e, r, l);
            for (let _ = 0; _ < c.length; ++_) e.fillText(c[_], s + 5, (_ + 1) * r + 3)
        },
        oG = [],
        oY = 0,
        oQ = t => {
            oY += t;
            let e = [];
            for (let i = 0; i < oG.length; i++) {
                let s = oG[i];
                if (s.timer.done(oY)) ca(s), oG.splice(i--, 1);
                else if (oY >= s.timer.start) {
                    let n = s.timer.fraction(oY);
                    sV(s.screenPos, s.pos);
                    let a = oL(s.screenPos, s.screenPos, s.flat);
                    if (a) {
                        let r = s.timer.remaining(oY);
                        if (s.alpha = r < .3 ? r / .3 : 1, s.crit) {
                            let l = Math.min(1, 6 * n);
                            s.scale = 1 + 1.6 * (l > .5 ? 2 - 2 * l : 2 * l)
                        } else a[1] -= 50 - (1 - n) ** 2 * 50, s.scale = 1;
                        e.push(s)
                    }
                }
            }
            if (e.sort((t, e) => e.timer.start - t.timer.start), sO.combatTextPush) {
                let o = 0,
                    c = !0,
                    d = [0, 0],
                    u = [0, 0];
                for (; o < 10 && c;) {
                    ++o, c = !1;
                    for (let $ = 0; $ < e.length; ++$) {
                        let h = e[$],
                            m = h.width * h.scale,
                            _ = h.height * h.scale;
                        d[0] = h.screenPos[0] + h.screenOffset[0], d[1] = h.screenPos[1] + h.screenOffset[1];
                        for (let f = 0; f < e.length; ++f) {
                            if (f === $) continue;
                            let p = e[f],
                                g = p.width * p.scale;
                            if (p.flat !== h.flat || g < m || g === m && $ < f) continue;
                            let v = p.height * p.scale;
                            u[0] = p.screenPos[0] + p.screenOffset[0], u[1] = p.screenPos[1] + p.screenOffset[1];
                            let y = u[0] - d[0],
                                b = u[1] - d[1],
                                x = g / 2 + m / 2,
                                w = v / 2 + _ / 2;
                            if (Math.abs(y) < x && Math.abs(b) < w) {
                                let k = y < 0 ? y + x : y - x,
                                    C = b < 0 ? b + w : b - w;
                                Math.abs(k) < 1.2 * Math.abs(C) ? h.screenOffset[0] += k : h.screenOffset[1] += C, c = !0, d[0] = h.screenPos[0] + h.screenOffset[0], d[1] = h.screenPos[1] + h.screenOffset[1]
                            }
                        }
                    }
                }
            }
            let S = [0, 0];
            for (let E = 0; E < e.length; ++E) {
                let P = e[E];
                P.screenOffset[0] *= Math.max(0, 1 - 3 * t), P.screenOffset[1] *= Math.max(0, 1 - 3 * t), S[0] = P.screenPos[0] + P.screenOffset[0], S[1] = P.screenPos[1] + P.screenOffset[1], oO(S, P.img, P.alpha, P.scale)
            }
        },
        oX = (t, e, i, s, n = !1, a) => {
            let r = 3 === i;
            ci(t, n, r, n || !r, 0 === i ? "Miss" : rX(e) + (1 === i ? "\uD83D\uDEE1" : ""), n ? oq.pdmg : 1 === s ? r ? oq.spellCrit : oq.spell : r ? oq.physCrit : oq.phys, a, oY, r ? 1.2 : .9)
        },
        oJ = (t, e, i, s = !1, n) => {
            ci(t, s, 3 === i, s || 3 !== i, rX(e), s ? oq.pheal : oq.heal, n, oY, 1.3)
        },
        oK = (t, e, i) => {
            ci(t, i, !1, !0, "Immune", i ? oq.mana : oq.spell, e, oY, 2)
        },
        oZ = (t, e, i, s = !1) => {
            ci(t, s, 3 === i, s || 3 !== i, e, oq.mana, 0, oY, 1.3)
        },
        ct = (t, e) => {
            ci(t, !1, !1, !0, `+${e} EXP`, oq.exp, 4, oY, 1.5)
        },
        ce = (t, e) => {
            ci(t, !1, !1, !0, `+${e} Fame`, oq.fame, 5.5, oY, 1.5)
        },
        ci = (t, e = !1, i = !1, s = !1, n, a, r, l, o) => {
            let c = cn();
            sV(c.pos, t), c.pos[1] += r || 0, c.side = Math.sin(2.3 * oG.length), c.flat = e, c.crit = i, c.float = s, c.timer.reset(l, o), sW(c.screenPos, 0, 0, 0), nH(c.screenOffset, 0, 0), c.scale = 0, c.alpha = 0, c.img = oW(n, a), c.width = c.img.width, c.height = c.img.height, oG.push(c)
        },
        cs = [],
        cn = () => cs.length ? cs.pop() : {
            pos: [0, 0, 0],
            flat: !0,
            crit: !0,
            float: !0,
            yoffset: 0,
            timer: new aH(0, 1),
            screenPos: [0, 0, 0],
            screenOffset: [0, 0],
            scale: 0,
            alpha: 0,
            img: void 0,
            width: 0,
            height: 0
        },
        ca = t => {
            cs.push(t)
        },
        cr = () => [-0, -0, -0, -0, -0, -0],
        cl = cr(),
        co = (t, e) => !(t[3] < e[0] || t[0] > e[3] || t[4] < e[1] || t[1] > e[4] || t[5] < e[2] || t[2] > e[5]),
        cc = (t, e, i, s, n) => (t[0] = e[0], t[3] = e[0] + i, t[1] = e[1], t[4] = e[1] + s, t[2] = e[2], t[5] = e[2] + n, t),
        cd = (t, e) => {
            t[0] = t[1] = t[2] = 1 / 0, t[3] = t[4] = t[5] = -1 / 0;
            for (let i = 0; i < e.length; ++i) {
                let s = e[i];
                t[0] = Math.min(t[0], s[0]), t[3] = Math.max(t[3], s[0]), t[1] = Math.min(t[1], s[1]), t[4] = Math.max(t[4], s[1]), t[2] = Math.min(t[2], s[2]), t[5] = Math.max(t[5], s[2])
            }
            return t
        },
        cu = (t, e, i, s, n) => (sW(ar, e[0] - i / 2, e[1] - s / 2, e[2] - n / 2), cc(t, ar, i, s, n)),
        c$ = (t, e, i, s, n) => {
            let a = (t[0] - e[0]) * i[0],
                r = (t[1] - e[1]) * i[1],
                l = (t[2] - e[2]) * i[2],
                o = (t[3] - e[0]) * i[0],
                c = (t[4] - e[1]) * i[1],
                d = (t[5] - e[2]) * i[2],
                u = Math.min(n, Math.max(a, o), Math.max(r, c), Math.max(l, d));
            return !(u < 0 || Math.max(s, Math.min(a, o), Math.min(r, c), Math.min(l, d)) > u)
        },
        ch = (t, e, i, s) => {
            window.gtag && window.gtag("event", t, {
                event_category: e,
                event_label: i,
                value: s
            })
        },
        cm = [30, 60, 130, 260, 470, 700, 1030, 1500, 2100, 2900, 3900, 5400, 7200, 9600, 12600, 17400, 23700, 31900, 42600, 58300, 78900, 106e3, 14e4, 184e3, 247e3, 33e4, 43e4, 56e4, 73e4, 96e4, 125e4, 162e4, 209e4, 268e4, 4e6, 62e5, 97e5, 15e6, 229e5, 325e5, 451e5, 615e5, 827e5, 11e7, 1203e5],
        c_ = t => cm[aL(t, 1, 45) - 1];
    class cf {
        constructor(t) {
            this.id = t.id, this.cd = void 0 !== t.cd ? t.cd : 0, this.costMp = t.costMp, this.targetMode = t.targetMode || 0, this.onCast = t.onCast, this.onPermanent = t.onPermanent, this.range = t.range || 0, this.graceRange = this.range + Math.min(.2 * this.range, 10), this.auto = t.auto || !1, this.engineOnly = t.engineOnly || !1, this.minlevel = t.minlevel || 0, this.castLen = t.castLen || 0, this.gcd = void 0 !== t.gcd ? t.gcd : 1.5, this.custom = t.custom, this.skilllevels = Math.min(5, t.skilllevels || 5), this.goldValue = t.goldValue || 0, this.noReward = t.noReward || !1, this.outOfCombat = t.outOfCombat || !1, this.pvpBoundsAdd = t.pvpBoundsAdd || 0, this.ignoreGcd = t.ignoreGcd || !1, this.ignoreIncapacitated = t.ignoreIncapacitated || !1, this.disablingBuffs = t.disablingBuffs || [], this.hasteAffected = void 0 === t.hasteAffected || t.hasteAffected, this.skillpoints = void 0 !== t.skillpoints ? t.skillpoints : 1, this.envCast = t.envCast || 0
        }
        can(t, e, i = 0, s) {
            if (this.outOfCombat && !t.stats.combatTimer.done(as.time)) return 11;
            if (void 0 !== this.costMp && t.stats.getResource(7) < this.costMp(e)) return 5;
            if (1 !== this.targetMode) {
                let n = as.getEntityById(i),
                    a = void 0 === n || n.stats.alive,
                    r = void 0 === n ? -1 : t.hostility(n);
                if (4096 === this.targetMode) {
                    if ((-1 === r || 0 === r) && a) return 3;
                    if (!t.canCombatInteract(n)) return 13
                } else if (256 === this.targetMode) {
                    if ((-1 === r || 0 !== r) && a) return 4
                } else if (16 === this.targetMode) n = t;
                else if (17 === this.targetMode && (void 0 === n || n === t)) return 3;
                if (void 0 !== n && !n.stats.alive) return 10;
                if (n && i !== t.id && n !== t && this.range > 0 && !t.combatRangeCheck(n, s ? this.range : this.graceRange)) return 6
            }
            return this.disablingBuffs.some(e => t.buffs.tags.get(e).size > 0) ? 12 : 0
        }
    }
    class cp extends cf {
        constructor(t) {
            super(t), this.fx = t.fx || {}, this.autoSkillbar = !1 !== t.autoSkillBar
        }
    }
    let cg = (t, e, i, s) => ({
            id: t,
            minlevel: i,
            engineOnly: !1,
            cd: 0,
            custom: s,
            autoSkillBar: !1,
            onPermanent: (t, i) => ({
                id: e,
                mode: 4,
                caster: t.id,
                target: t.id,
                duration: -1,
                stacks: 1,
                level: i
            })
        }),
        cv = (t, e, i, s, n, a, r, l) => ({
            id: t,
            targetMode: 16,
            minlevel: i,
            cd: n,
            costMp: r,
            fx: l,
            onCast: (t, i, n) => ({
                id: e,
                mode: 4,
                stacks: 1,
                duration: s,
                caster: t.id,
                target: t.id,
                aoe: {
                    faction: !0,
                    limit: a,
                    circleRadius: 30,
                    circleHeight: 20
                },
                level: i
            })
        }),
        cy = (t, e, i, s, n, a, r, l = 5, o) => ({
            id: t,
            targetMode: 256,
            range: 30,
            minlevel: i,
            cd: n,
            castLen: s,
            costMp: r,
            fx: o,
            onCast: (t, i, s) => ({
                id: e,
                mode: l,
                stacks: 1,
                caster: t.id,
                target: s,
                refresh: !0,
                duration: a,
                level: i
            })
        }),
        c0 = (t, e, i = 0, s = !0, n, a = !1, r = !1, l) => ({
            id: t,
            targetMode: 16,
            cd: e,
            gcd: 0,
            hasteAffected: !1,
            ignoreIncapacitated: a,
            ignoreGcd: !0,
            castLen: i,
            engineOnly: !0,
            outOfCombat: n,
            fx: l
        }),
        cb = new cp(cg(21, 76, 1)),
        cx = new cp({
            id: 2,
            targetMode: 16,
            minlevel: 5,
            cd: 30,
            gcd: 0,
            costMp: t => 3 + 5 * t,
            fx: {
                animCast: 6
            },
            custom: [
                [t => 7 + 12 * t, " heal on block"]
            ],
            onCast: (t, e, i) => ({
                id: 58,
                mode: 4,
                stacks: 1,
                duration: 9,
                caster: t.id,
                target: t.id,
                level: e
            })
        }),
        cw = t => .7 + .2 * t,
        c1 = t => cw(t) + 2.4,
        c9 = new cp({
            id: 33,
            targetMode: 17,
            skilllevels: 1,
            minlevel: 11,
            cd: 15,
            range: 30,
            disablingBuffs: [4],
            costMp: t => 12,
            custom: [
                [cw, "s stunned at min range"],
                [c1, "s stunned at max range"]
            ],
            onCast(t, e, i) {}
        }),
        c3 = new cp(cv(20, 75, 15, 300, 150, 20, t => 8 * t, {
            animCast: 6
        })),
        ck = new cp({
            id: 18,
            cd: 0,
            minlevel: 8,
            autoSkillBar: !1,
            fx: {},
            onPermanent: (t, e) => ({
                id: 72,
                mode: 4,
                caster: t.id,
                target: t.id,
                duration: -1,
                stacks: 1,
                level: e
            })
        }),
        c2 = new cp({
            id: 3,
            targetMode: 1,
            minlevel: 3,
            cd: 6,
            costMp: t => 2 + 2 * t,
            fx: {
                animCast: 5,
                effectDirImpact: 9
            },
            onCast: (t, e, i) => ({
                id: 3,
                mode: 0,
                caster: t.id,
                dmg: t.stats.getDamageRoll() * (1 + .18 * e),
                type: 1,
                aoe: {
                    faction: !1,
                    circleRadius: 2 + 5 * t.size
                }
            })
        }),
        c4 = new cp({
            id: 17,
            targetMode: 16,
            minlevel: 13,
            cd: 50,
            gcd: 0,
            costMp: t => 8 * t,
            fx: {
                animCast: 6
            },
            onCast: (t, e, i) => ({
                id: 71,
                mode: 4,
                stacks: 1,
                duration: 17,
                caster: t.id,
                target: t.id,
                level: e
            })
        }),
        cC = new cp({
            id: 50,
            targetMode: 1,
            minlevel: 7,
            cd: 30,
            costMp: t => 4 * t,
            fx: {
                animCast: 40
            },
            custom: [
                [t => 20 + 5 * t, " % missing + 100 HP recovered"]
            ],
            onCast: (t, e, i) => ({
                id: 121,
                mode: 4,
                stacks: 1,
                caster: t.id,
                buffdata: [0],
                sendBuffData: !0,
                duration: 1 + e,
                level: e,
                aoe: {
                    faction: !1,
                    circleRadius: 8
                }
            })
        }),
        cS = new cp({
            id: 1,
            targetMode: 4096,
            minlevel: 1,
            cd: 1,
            range: 2,
            custom: [
                [t => 8 * t, "% chance to daze target for 3 seconds"]
            ],
            costMp: t => 1 + t,
            fx: {
                animImpact: 3
            },
            onCast(t, e, i) {
                let s = 5 + t.stats.getDamageRoll() * (.38 + .39 * e);
                return {
                    id: 1,
                    mode: 0,
                    caster: t.id,
                    target: i,
                    dmg: s,
                    type: 1
                }
            }
        }),
        c7 = t => 1e4 + 1e4 * t,
        cE = (t, e) => {
            1 === e.type && (e.aggroValues.forEach((t, i) => {
                e.aggroValues.set(i, 1e-4 * t)
            }), e.addAggro(t.caster, c7(t.level)), e.buffs.buffs.has(122) && add({
                id: 123,
                mode: 5,
                stacks: t.level,
                caster: e.id,
                target: t.caster,
                refresh: !0,
                duration: 60,
                level: 1
            }))
        },
        c6 = new cp({
            id: 34,
            targetMode: 1,
            minlevel: 6,
            cd: 15,
            costMp: t => 4 * t,
            fx: {
                animCast: 7
            },
            custom: [
                [c7, " aggro generation"]
            ],
            onCast: (t, e, i) => ({
                custom: cE,
                id: 88,
                mode: 4,
                stacks: 1,
                caster: t.id,
                duration: 2 + e,
                level: e,
                aoe: {
                    faction: !1,
                    circleRadius: 10
                }
            })
        }),
        cP = new cp({
            id: 41,
            targetMode: 16,
            minlevel: 25,
            cd: 30,
            skilllevels: 1,
            gcd: 0,
            costMp: t => 3 + 5 * t,
            onCast(t, e, i) {}
        }),
        cM = new cp(cv(19, 74, 18, 300, 150, 20, t => 8 * t, {
            animCast: 6
        })),
        c5 = new cp({
            id: 46,
            targetMode: 1,
            range: 30,
            minlevel: 4,
            cd: 30,
            castLen: 0,
            costMp: t => 10 + 3 * t,
            fx: {
                effectTarget: 106
            },
            onCast(t, e, i) {}
        }),
        cD = new cp(cv(22, 77, 17, 300, 120, 20, t => 5 + 10 * t, {
            animCast: 6
        })),
        cT = new cp(cy(24, 79, 15, 1.5, 0, 300, t => 2 + 3 * t, 4, {
            animCast: 9,
            animChannel: 18
        })),
        cA = new cp({
            id: 52,
            targetMode: 1,
            minlevel: 7,
            envCast: 7,
            cd: 6,
            range: 20,
            costMp: t => 3 * t,
            fx: {
                effectMissile: 107,
                effectTarget: 111
            },
            onCast(t, e, i, s, n, a) {}
        }),
        c8 = new cp({
            id: 14,
            targetMode: 1,
            minlevel: 3,
            cd: 25,
            costMp: t => 4 * t,
            fx: {
                animCast: 31
            },
            onCast: (t, e, i) => ({
                id: 68,
                mode: 4,
                stacks: 1,
                caster: t.id,
                duration: 5.5 + .5 * e,
                level: e,
                aoe: {
                    faction: !1,
                    circleRadius: 8
                }
            })
        }),
        cR = new cp({
            id: 16,
            targetMode: 16,
            minlevel: 13,
            cd: 45,
            gcd: 0,
            fx: {
                animCast: 6
            },
            onCast: (t, e, i) => ({
                id: 70,
                mode: 4,
                stacks: 1,
                duration: 12,
                caster: t.id,
                target: t.id,
                level: e
            })
        }),
        cF = new cp({
            id: 53,
            targetMode: 16,
            minlevel: 9,
            cd: 80,
            gcd: 0,
            ignoreIncapacitated: !0,
            ignoreGcd: !0,
            costMp: t => 5 * t,
            onCast: (t, e, i) => ({
                id: 117,
                mode: 4,
                duration: 5,
                stacks: 1,
                caster: t.id,
                target: t.id,
                level: e
            })
        }),
        cN = new cp({
            id: 4,
            targetMode: 4096,
            range: 30,
            minlevel: 1,
            cd: 0,
            castLen: 1.5,
            custom: [
                [t => 100 + 10 * t, "% frozen buff multiplier"]
            ],
            costMp: t => 1 + 2 * t,
            fx: {
                animCast: 29,
                effectDirImpact: 30,
                animChannel: 30,
                effectMissile: 27
            },
            onCast: (t, e, i) => ({
                id: 4,
                mode: 6,
                speed: 25,
                caster: t.id,
                target: i,
                dmg: 5 + t.stats.getDamageRoll() * (.3 + .32 * e),
                type: 1
            }),
            onPermanent: (t, e, i) => ({
                id: 100,
                mode: 4,
                stacks: 1,
                duration: -1,
                caster: t.id,
                target: t.id,
                level: e
            })
        }),
        cI = t => 3 + t,
        cU = new cp({
            id: 23,
            targetMode: 16,
            minlevel: 5,
            cd: 60,
            gcd: 0,
            costMp: t => 5 * t,
            custom: [
                [cI, " attacks blocked"]
            ],
            fx: {
                animCast: 6
            },
            onCast: (t, e, i) => ({
                id: 78,
                mode: 4,
                stacks: cI(e),
                duration: 60,
                caster: t.id,
                target: t.id,
                level: e
            })
        }),
        cz = new cp({
            id: 15,
            targetMode: 1,
            range: 30,
            minlevel: 8,
            cd: 8,
            castLen: 1.5,
            costMp: t => 5 + 5 * t,
            fx: {
                animCast: 29,
                animChannel: 30,
                effectDirImpact: 31,
                effectMissile: 28
            },
            onCast: (t, e, i) => ({
                id: 15,
                mode: 6,
                speed: 10,
                timeout: 2.5,
                caster: t.id,
                rot: t.rot,
                dmg: 10 + t.stats.getDamageRoll() * (.51 + .56 * e),
                type: 1,
                aoe: {
                    circleRadius: 4 + .5 * e,
                    faction: !1,
                    onlyOnce: []
                }
            })
        }),
        cO = new cp({
            id: 51,
            targetMode: 4096,
            range: 30,
            minlevel: 4,
            cd: 10,
            castLen: 2.8,
            costMp: t => 1 + 2 * t,
            fx: {
                animCast: 37,
                effectDirImpact: 119,
                animChannel: 30,
                effectMissile: 118
            },
            onCast: (t, e, i) => ({
                id: 51,
                mode: 6,
                speed: 20,
                caster: t.id,
                target: i,
                dmg: 5 + t.stats.getDamageRoll() * (1.25 + 1.33 * e),
                type: 1,
                noblock: !0
            })
        }),
        cL = new cp({
            id: 32,
            targetMode: 1,
            skilllevels: 1,
            minlevel: 5,
            gcd: .7,
            cd: 12,
            disablingBuffs: [4],
            costMp: t => 4 * t,
            fx: {
                animCast: 32
            },
            custom: [
                [() => 12, "m distance"]
            ],
            onCast(t, e, i) {}
        }),
        cB = new cp({
            id: 37,
            targetMode: 4096,
            range: 30,
            minlevel: 15,
            cd: 40,
            castLen: 2.3,
            costMp: t => 5 + 5 * t,
            fx: {
                animCast: 9,
                effectImpact: 50,
                animChannel: 16
            },
            onCast: (t, e, i) => ({
                id: 90,
                mode: 4,
                stacks: 1,
                caster: t.id,
                target: i,
                duration: 2.4 + 1 * e,
                level: e
            })
        }),
        cq = new cp(cv(28, 83, 12, 15, 60, 15, t => 1 + 3 * t, {
            animCast: 6
        })),
        cV = new cp({
            id: 12,
            targetMode: 4096,
            range: 25,
            minlevel: 1,
            castLen: 0,
            cd: 3,
            costMp: t => Math.round(1 + 4.5 * t),
            fx: {
                animCast: 10,
                effectMissile: 48
            },
            onCast: (t, e, i) => ({
                id: 12,
                mode: 6,
                dmg: 5 + t.stats.getDamageRoll() * (.03 + .13 * e),
                type: 1,
                speed: 15,
                caster: t.id,
                target: i,
                level: e
            })
        }),
        cW = new cp({
            id: 30,
            targetMode: 1,
            range: 30,
            minlevel: 18,
            cd: 60,
            castLen: 2.3,
            costMp: t => 10 + 8 * t,
            fx: {
                effectImpact: 70,
                animCast: 14,
                animChannel: 15,
                effectMissile: 69
            },
            onCast: (t, e, i) => ({
                id: 30,
                mode: 6,
                speed: 0,
                timeout: 30,
                caster: t.id,
                rot: t.rot,
                interval: new aH(0, 2),
                heal: t.stats.getDamageRoll() * (.08 + .05 * e),
                type: 1,
                aoe: {
                    circleRadius: 30,
                    circleHeight: 30,
                    faction: !0,
                    limit: 15
                }
            })
        }),
        cH = new cp(cv(13, 67, 6, 15, 90, 15, void 0, {
            animCast: 22
        })),
        cj = new cp({
            id: 6,
            targetMode: 256,
            range: 30,
            minlevel: 8,
            cd: 0,
            castLen: 1.7,
            costMp: t => 4 + 4 * t,
            fx: {
                animCast: 11,
                effectImpact: 36,
                animChannel: 12
            },
            onCast: (t, e, i) => ({
                id: 6,
                mode: 2,
                caster: t.id,
                target: i,
                heal: 15 + t.stats.getDamageRoll() * (.2 + .18 * e)
            })
        }),
        cG = new cp({
            id: 47,
            targetMode: 256,
            range: 30,
            minlevel: 14,
            cd: 12,
            castLen: 0,
            costMp: t => 4 + 4 * t,
            fx: {
                animCast: 9,
                effectTarget: 112
            },
            custom: [
                [t => t, " effects removed"]
            ],
            onCast: (t, e, i) => ({
                id: 47,
                mode: 2,
                caster: t.id,
                target: i,
                heal: 1 * (15 + .25 * t.stats.getDamageRoll())
            })
        }),
        cY = new cp(cg(43, 106, 3, [
            [t => 1 + 2 * t, "% haste per stack"],
            [t => 1 + 2 * t, " jumps"]
        ])),
        cQ = new cp(cy(7, 59, 3, 0, 0, 12, t => 2 + 2 * t, 5, {
            animCast: 9
        })),
        cX = new cp({
            id: 42,
            targetMode: 1,
            minlevel: 8,
            cd: 8,
            castLen: 0,
            range: 25,
            custom: [
                [t => Math.round(1.3 * t), " mana gained per soul"],
                [t => 2 * t, " extended Decay duration"]
            ],
            costMp: t => 1 + 3 * t,
            fx: {
                animCast: 13,
                effectImpact: 46
            },
            onCast: (t, e, i) => ({
                id: 42,
                mode: 1,
                caster: t.id,
                target: 0,
                type: 1,
                dmg: 4 + t.stats.getDamageRoll() * (.25 + .4 * e),
                level: e
            })
        }),
        cJ = new cp({
            id: 105,
            engineOnly: !0,
            cd: 0,
            fx: {
                effectImpact: 47,
                effectMissile: 45
            }
        }),
        cK = new cp({
            id: 36,
            targetMode: 16,
            minlevel: 10,
            cd: 30,
            gcd: 0,
            costMp: t => 8 + 2 * t,
            onCast: (t, e, i) => ({
                id: 89,
                mode: 4,
                stacks: 1,
                duration: 5 + 5 * e,
                caster: t.id,
                target: t.id,
                level: e
            })
        }),
        cZ = new cp({
            id: 35,
            targetMode: 1,
            skilllevels: 1,
            minlevel: 5,
            cd: 120,
            skillpoints: 0,
            castLen: 5,
            outOfCombat: !0,
            hasteAffected: !1,
            pvpBoundsAdd: 5,
            costMp: t => 20 + 5 * t,
            fx: {
                animCast: 20,
                animChannel: 21
            },
            onCast(t, e, i) {}
        }),
        dt = new cp({
            id: 49,
            targetMode: 4096,
            range: 30,
            minlevel: 13,
            cd: 25,
            costMp: t => 1 + 1 * t,
            fx: {
                animCast: 38,
                effectMissile: 123,
                animChannel: 28
            },
            onCast: (t, e, i) => ({
                id: 49,
                buffid: 119,
                mode: 7,
                speed: 60,
                caster: t.id,
                level: e,
                stacks: 1,
                duration: 1 + 2 * e,
                refresh: !0,
                target: i
            })
        }),
        de = new cp({
            id: 54,
            targetMode: 4096,
            range: 30,
            minlevel: 8,
            cd: 10,
            castLen: 2.8,
            costMp: t => 8 + 3 * t,
            fx: {
                animCast: 39,
                effectDirImpact: 121,
                animChannel: 25,
                effectMissile: 114
            },
            onCast: (t, e, i) => ({
                id: 54,
                mode: 6,
                speed: 60,
                caster: t.id,
                target: i,
                dmg: 5 + t.stats.getDamageRoll() * (1.25 + 1.33 * e),
                type: 1,
                noblock: !0
            })
        }),
        di = new cp(cg(26, 81, 15)),
        ds = new cp({
            id: 11,
            targetMode: 16,
            minlevel: 7,
            cd: 50,
            gcd: 0,
            fx: {
                animCast: 6
            },
            custom: [
                [t => 3 + 5 * t, "% of max mp recovered"]
            ],
            onCast: (t, e, i) => ({
                id: 65,
                mode: 4,
                stacks: 1,
                duration: 17,
                caster: t.id,
                target: t.id,
                level: e
            })
        }),
        dn = new cp(cv(27, 82, 12, 10, 100, 20, t => 5 + 7 * t, {
            animCast: 6
        })),
        da = new cp({
            id: 29,
            cd: 0,
            minlevel: 9,
            autoSkillBar: !1,
            onPermanent: (t, e) => ({
                id: 84,
                mode: 4,
                caster: t.id,
                target: t.id,
                duration: -1,
                stacks: 1,
                level: e
            })
        }),
        dr = new cp({
            id: 9,
            targetMode: 4096,
            range: 30,
            minlevel: 3,
            cd: 6,
            castLen: 1.7,
            costMp: t => 2 + 3 * t,
            fx: {
                animCast: 24,
                effectDirImpact: 85,
                animChannel: 25,
                effectMissile: 33
            },
            onCast: (t, e, i) => ({
                id: 9,
                mode: 6,
                speed: 120,
                caster: t.id,
                target: i,
                dmg: 5 + t.stats.getDamageRoll() * (.48 + .41 * e),
                type: 1
            })
        }),
        dl = new cp({
            id: 10,
            targetMode: 16,
            minlevel: 5,
            cd: 0,
            autoSkillBar: !1,
            onPermanent: (t, e, i) => ({
                id: 64,
                mode: 4,
                stacks: 1,
                duration: -1,
                caster: t.id,
                target: t.id,
                level: e
            })
        }),
        dc = new cp({
            id: 38,
            targetMode: 16,
            minlevel: 5,
            skilllevels: 1,
            cd: 10,
            gcd: 0,
            disablingBuffs: [4],
            costMp: t => 6,
            fx: {
                animCast: 23
            },
            onCast: (t, e, i) => !0
        }),
        dd = new cp({
            id: 31,
            targetMode: 4096,
            range: 30,
            minlevel: 1,
            cd: 0,
            castLen: 1.5,
            costMp: t => 1 + 1 * t,
            fx: {
                animCast: 27,
                effectDirImpact: 84,
                effectMissile: 34,
                animChannel: 28
            },
            onCast: (t, e, i) => ({
                id: 31,
                mode: 6,
                speed: 60,
                caster: t.id,
                target: i,
                dmg: 5 + t.stats.getDamageRoll() * (.24 + .25 * e),
                type: 1
            })
        }),
        du = new cp(cv(25, 80, 18, 300, 120, 20, t => 5 + 5 * t, {
            animCast: 6
        })),
        d$ = new cp({
            id: 48,
            targetMode: 4096,
            range: 30,
            minlevel: 6,
            cd: 15,
            ignoreGcd: !0,
            costMp: t => 1 + 1 * t,
            fx: {
                animCast: 36,
                effectDirImpact: 115,
                effectMissile: 113,
                animChannel: 28
            },
            custom: [
                [t => 120 * t, " HP recovered"]
            ],
            onCast: (t, e, i) => ({
                id: 48,
                mode: 6,
                speed: 80,
                caster: t.id,
                target: i,
                dmg: 5 + t.stats.getDamageRoll() * (.28 + .28 * e),
                type: 1
            })
        }),
        dh = new cp({
            id: 106,
            engineOnly: !0,
            cd: 0,
            fx: {
                effectMissile: 116,
                effectImpact: 117
            }
        }),
        dm = new cp({
            id: 45,
            targetMode: 1,
            range: 30,
            minlevel: 4,
            cd: 26,
            castLen: 0,
            costMp: t => 18 + 3 * t,
            fx: {
                effectDirImpact: 11,
                effectMissile: 103
            },
            onCast(t, e, i) {}
        }),
        d_ = {
            medalValue: 1e3,
            goldValue: 5e4,
            buyElo: 1600,
            quality: 90,
            level: 45,
            gs: 30,
            uniqueEquipped: !0
        },
        df = [{
            id: 0,
            custom: ["Use: Removes all movement limiting effects."],
            useCd: 60,
            incap: !0,
            animCast: 45,
            use(t, e, i, s) {}
        }, {
            id: 1,
            custom: ["Use: Protects you against 30% of incoming damage for 10 seconds."],
            useCd: 60,
            animCast: 6,
            incap: !1,
            use(t, e, i, s) {}
        }, {
            id: 2,
            custom: ["Use: Increases your damage by 20% for 10 seconds."],
            useCd: 80,
            incap: !1,
            animCast: 6,
            use(t, e, i, s) {}
        }, {
            id: 3,
            custom: ["Use: Speeds up your movement by 45 for 8 seconds."],
            useCd: 50,
            incap: !1,
            animCast: 6,
            use(t, e, i, s) {}
        }, {
            id: 4,
            custom: ["Use: Attacks made against you grant 20 MP (up to 200) for 20 seconds."],
            useCd: 60,
            incap: !1,
            animCast: 6,
            use(t, e, i, s) {}
        }],
        dp = new cp(c0(100, 30, 0, !0, !0, !1, !1, {
            animCast: 17
        })),
        dg = new cp(c0(101, 1.5, 0, !0, !1, !1, !1)),
        dv = new cp(c0(104, 1.5, 0, !1, !1, !1, !1)),
        dy = new cp(c0(103, 1.5, 3, !0, !1, !1, !1, {
            animCast: 19,
            animChannel: 18
        })),
        d0 = new cp(c0(102, 1.5, 1.5, !1, !0, !1, !1, {
            animCast: 9,
            animChannel: 18
        })),
        db = df.map((t, e) => new cp(c0(107 + e, t.useCd, 0, !1, !1, t.incap, !0, {
            animCast: t.animCast
        }))).reduce((t, e) => ({
            ...t,
            ["charm" + e.id]: e
        }), {}),
        dx = new cp({
            id: 5,
            targetMode: 4096,
            range: 30,
            engineOnly: !0,
            auto: !0,
            cd: t => 100 / t.stats.getStat(17),
            fx: {
                animCast: 26,
                effectDirImpact: 11,
                effectMissile: 32
            },
            onCast: (t, e, i) => ({
                id: 5,
                mode: 6,
                speed: 45,
                caster: t.id,
                target: i,
                dmg: t.stats.getDamageRoll(),
                type: 0
            })
        }),
        dw = new cp({
            id: 56,
            targetMode: 1,
            range: 50,
            cd: 10,
            engineOnly: !0,
            castLen: 2,
            fx: {
                animCast: 41,
                animChannel: 42
            }
        }),
        d1 = new cp({
            id: 44,
            targetMode: 1,
            range: 50,
            minlevel: 3,
            cd: 5,
            engineOnly: !0,
            castLen: 1.5,
            costMp: t => 4 * t
        }),
        d9 = new cp({
            id: 55,
            targetMode: 1,
            range: 50,
            minlevel: 3,
            cd: 20,
            engineOnly: !0,
            castLen: 2,
            fx: {
                effectMissile: 131,
                animCast: 43,
                animChannel: 42
            }
        }),
        d3 = new cp({
            id: 57,
            targetMode: 1,
            range: 10,
            cd: 2,
            engineOnly: !0,
            hasteAffected: !1,
            castLen: 30,
            fx: {
                animCast: 9,
                animChannel: 44
            }
        }),
        dk = new cp({
            id: 0,
            targetMode: 4096,
            engineOnly: !0,
            auto: !0,
            range: 2,
            cd: t => 100 / t.stats.getStat(17),
            fx: {
                animImpact: 4
            },
            onCast: (t, e, i) => ({
                id: 0,
                mode: 0,
                caster: t.id,
                target: i,
                dmg: t.stats.getDamageRoll(),
                type: 0
            })
        }),
        d2 = new cp({
            id: 39,
            engineOnly: !1,
            skilllevels: 1,
            minlevel: 30,
            cd: 0,
            goldValue: 25e3,
            skillpoints: 0,
            noReward: !0,
            autoSkillBar: !1
        }),
        d4 = {
            ...db,
            conjurer_obeliskport: d3,
            boss_bigaoe: dw,
            boss_puddledot: d9,
            recall: new cp({
                id: 40,
                targetMode: 1,
                engineOnly: !0,
                cd: 300,
                castLen: 5,
                outOfCombat: !0,
                hasteAffected: !1,
                costMp: t => 20 + 5 * t,
                fx: {
                    animCast: 9,
                    animChannel: 8
                },
                onCast(t, e, i) {}
            }),
            arrow: dx,
            melee: dk,
            potion: dp,
            book: dg,
            specialization: new cp({
                id: 8,
                engineOnly: !0,
                cd: 0,
                onPermanent: (t, e) => ({
                    id: t.class + 60,
                    mode: 4,
                    caster: t.id,
                    target: t.id,
                    duration: -1,
                    stacks: 1,
                    level: e
                })
            }),
            mount: d2,
            activatemount: d0,
            container: dy,
            boss_flamepits: d1,
            useGeneric: dv
        },
        dC = new Map;
    [{
        relentlessCry: cC,
        whirlwind: c5,
        temper: cP,
        taunt: c6,
        charge: c9,
        warcry: cM,
        courage: c3,
        armorreinforcement: cb,
        enrage: c4,
        slash: cS,
        blockBuff: cx,
        crescentStrike: c2,
        crescentBleed: ck
    }, {
        frostcall: cA,
        iceblock: cF,
        shatterfrost: cO,
        teleport: cL,
        enchantment: cT,
        arcticaura: cD,
        iceshield: cU,
        hypothermic: cR,
        frostnova: c8,
        icebolt: cN,
        icicle: cz
    }, {
        vampiricarrowReturn: dh,
        boneshot: de,
        blindingshot: dt,
        vampiricarrow: d$,
        volley: dm,
        snipe: dc,
        poisonarrows: da,
        temporaldilation: du,
        pathfinding: dn,
        preciseShot: dr,
        serpentArrows: dl,
        invigorate: ds,
        swiftshot: dd,
        cranialpunctures: di
    }, {
        mimirscleanse: cG,
        soulharvestReturn: cJ,
        plaguespreader: cY,
        soulharvest: cX,
        agonize: cB,
        caninehowl: cq,
        mana: cH,
        mend: cj,
        revitalize: cQ,
        decay: cV,
        healingtotem: cW,
        summon: cZ,
        spiritanimal: cK
    }, d4].forEach((t, e) => {
        for (let i in t) e <= 3 && (t[i].class = e), dC.set(t[i].id, t[i])
    }), dC.set(59, new cp({
        id: 59,
        engineOnly: !0
    }));
    let dS = (t, e, i) => {},
        d7 = {
            hammer: {
                sound: 119,
                rot: 1
            },
            bow: {
                sound: 120,
                rot: 1
            },
            staff: {
                sound: 120,
                rot: 1
            },
            sword: {
                sound: 119,
                rot: 1
            },
            armlet: {
                sound: 121
            },
            armor: {
                sound: 122
            },
            bag: {
                sound: 121
            },
            boot: {
                sound: 121
            },
            glove: {
                sound: 121
            },
            ring: {
                sound: 123
            },
            amulet: {
                sound: 123
            },
            quiver: {
                sound: 121,
                rot: 1
            },
            shield: {
                sound: 122
            },
            totem: {
                sound: 122,
                rot: 1
            },
            orb: {
                sound: 122
            },
            rune: {
                sound: 123,
                rot: 0
            },
            misc: {
                sound: 124,
                rot: 1
            },
            book: {
                sound: 121
            },
            mount: {
                sound: 121,
                rot: 0
            },
            pet: {
                sound: 121,
                rot: 0
            },
            box: {
                sound: 125,
                rot: 0
            },
            gold: {
                sound: 126
            },
            charm: {
                sound: 123
            }
        },
        dE = {
            hammer: {
                baselvl: 0,
                slot: [101],
                tiers: 17,
                drop: .4,
                weight: 1,
                class: 3,
                stats: {
                    10: {
                        base: 1,
                        min: .6,
                        max: 1
                    },
                    11: {
                        base: 3,
                        min: .8,
                        max: 1.7
                    },
                    17: {
                        base: 15,
                        min: .05,
                        max: .1
                    }
                }
            },
            bow: {
                baselvl: 0,
                slot: [101],
                tiers: 17,
                drop: .4,
                weight: 1,
                class: 2,
                stats: {
                    10: {
                        base: 1,
                        min: .6,
                        max: 1
                    },
                    11: {
                        base: 3,
                        min: .8,
                        max: 1.7
                    },
                    17: {
                        base: 10,
                        min: .05,
                        max: .1
                    }
                }
            },
            staff: {
                baselvl: 0,
                slot: [101],
                tiers: 17,
                drop: .4,
                weight: 1,
                class: 1,
                stats: {
                    10: {
                        base: 1,
                        min: .6,
                        max: 1
                    },
                    11: {
                        base: 3,
                        min: .8,
                        max: 1.7
                    },
                    17: {
                        base: 10,
                        min: .05,
                        max: .1
                    }
                }
            },
            sword: {
                baselvl: 0,
                slot: [101],
                tiers: 17,
                drop: .4,
                weight: 1,
                class: 0,
                stats: {
                    10: {
                        base: 1,
                        min: .6,
                        max: 1
                    },
                    11: {
                        base: 3,
                        min: .8,
                        max: 1.7
                    },
                    17: {
                        base: 20,
                        min: .05,
                        max: .1
                    }
                }
            },
            armlet: {
                baselvl: 1,
                slot: [102],
                tiers: 13,
                drop: 1,
                weight: .3,
                stats: {
                    6: {
                        base: 10,
                        min: .5,
                        max: .9
                    },
                    12: {
                        base: 7,
                        min: .5,
                        max: .8
                    }
                }
            },
            armor: {
                baselvl: 2,
                slot: [103],
                tiers: 11,
                drop: 1,
                weight: 1,
                stats: {
                    12: {
                        base: 10,
                        min: 1.4,
                        max: 2.8
                    },
                    6: {
                        base: 20,
                        min: 1,
                        max: 2
                    }
                }
            },
            bag: {
                baselvl: 5,
                slot: [104],
                tiers: 5,
                drop: 1,
                weight: .1,
                stats: {
                    19: {
                        base: 1,
                        min: .1,
                        max: .3
                    }
                }
            },
            boot: {
                baselvl: 2,
                slot: [105],
                tiers: 13,
                drop: 1,
                weight: .4,
                stats: {
                    6: {
                        base: 10,
                        min: .6,
                        max: 1
                    },
                    12: {
                        base: 8,
                        min: .6,
                        max: 1.1
                    },
                    15: {
                        base: 3,
                        min: .03,
                        max: .1
                    }
                }
            },
            glove: {
                baselvl: 2,
                slot: [106],
                tiers: 13,
                drop: 1,
                weight: .4,
                stats: {
                    6: {
                        base: 10,
                        min: .6,
                        max: 1
                    },
                    12: {
                        base: 8,
                        min: .7,
                        max: 1.1
                    },
                    14: {
                        base: 1,
                        min: .1,
                        max: 1.5
                    }
                }
            },
            ring: {
                baselvl: 5,
                slot: [107],
                tiers: 12,
                drop: .8,
                weight: .2,
                stats: {
                    6: {
                        base: 10,
                        min: .5,
                        max: .9
                    },
                    7: {
                        base: 5,
                        min: .6,
                        max: 1
                    }
                }
            },
            amulet: {
                baselvl: 7,
                slot: [108],
                tiers: 12,
                drop: .8,
                weight: .3,
                stats: {
                    7: {
                        base: 10,
                        min: 1,
                        max: 1.8
                    },
                    9: {
                        base: 1,
                        min: .2,
                        max: .3
                    }
                }
            },
            quiver: {
                baselvl: 2,
                slot: [109],
                tiers: 10,
                drop: .7,
                weight: .5,
                class: 2,
                stats: {
                    14: {
                        base: 5,
                        min: .1,
                        max: .9
                    },
                    9: {
                        base: 1,
                        min: .1,
                        max: .3
                    }
                }
            },
            shield: {
                baselvl: 2,
                slot: [109],
                tiers: 10,
                drop: .7,
                weight: .5,
                class: 0,
                stats: {
                    12: {
                        base: 20,
                        min: .8,
                        max: 1.4
                    },
                    13: {
                        base: 4,
                        min: 1,
                        max: 2.8
                    }
                }
            },
            totem: {
                baselvl: 2,
                slot: [109],
                tiers: 10,
                drop: .7,
                weight: .5,
                class: 3,
                stats: {
                    12: {
                        base: 10,
                        min: .4,
                        max: .9
                    },
                    9: {
                        base: 1,
                        min: .1,
                        max: .4
                    }
                }
            },
            orb: {
                baselvl: 2,
                slot: [109],
                tiers: 10,
                drop: .7,
                weight: .5,
                class: 1,
                stats: {
                    3: {
                        base: 10,
                        min: .3,
                        max: .7
                    },
                    9: {
                        base: 1,
                        min: .1,
                        max: .3
                    }
                }
            },
            rune: {
                baselvl: 1,
                tiers: 11,
                drop: .8,
                quality: 70
            },
            misc: {
                drop: 8,
                weight: .1
            },
            book: {
                drop: .9,
                weight: .5
            },
            charm: {
                slot: [110, 111],
                noupgrade: !0,
                undroppable: !0,
                drop: 0,
                stackable: !1
            },
            mount: {
                noupgrade: !0,
                undroppable: !0,
                drop: 0,
                stackable: !1
            },
            box: {
                noupgrade: !0,
                undroppable: !0,
                drop: 0,
                stackable: !1
            },
            pet: {
                noupgrade: !0,
                undroppable: !0,
                drop: 0,
                stackable: !1
            },
            gold: {
                drop: 20
            }
        },
        d6 = Object.keys(dE),
        dP = {
            6: {
                min: .2,
                max: .8,
                round: !0
            },
            7: {
                min: .2,
                max: .5,
                round: !0
            },
            8: {
                min: .1,
                max: 1
            },
            9: {
                min: .1,
                max: .5
            },
            10: {
                min: .03,
                max: .13,
                round: !0
            },
            11: {
                min: .1,
                max: .2,
                round: !0
            },
            12: {
                min: .1,
                max: .8,
                round: !0
            },
            13: {
                min: .1,
                max: .4
            },
            14: {
                min: .1,
                max: .5
            },
            16: {
                min: .1,
                max: .4
            },
            2: {
                min: .08,
                max: .45,
                round: !0
            },
            0: {
                min: .08,
                max: .45,
                round: !0
            },
            3: {
                min: .08,
                max: .45,
                round: !0
            },
            4: {
                min: .08,
                max: .45,
                round: !0
            },
            1: {
                min: .08,
                max: .45,
                round: !0
            },
            5: {
                min: .08,
                max: .45,
                round: !0
            },
            18: {
                min: .01,
                max: .15,
                round: !0
            }
        },
        dM = Object.keys(dP),
        d5 = {
            6: 4,
            7: 3,
            8: 5,
            9: 4,
            10: 1,
            11: 1,
            12: 5,
            13: 5,
            14: 5,
            15: .3,
            16: 5,
            17: 0,
            2: 2,
            0: 2,
            3: 2,
            4: 2,
            1: 2,
            5: 2,
            19: 1,
            18: 3
        },
        dD = (t, e) => dE[t].baselvl + Math.floor(e / dE[t].tiers * 100),
        dT = (t, e) => {
            let i = {
                level: t.level,
                type: t.type,
                tier: t.tier,
                stats: t.stats ? new Map : void 0,
                class: t.class,
                quality: t.quality
            };
            t.stats && Object.keys(t.stats).sort((t, e) => t - e).forEach(e => {
                let s = t.stats[e];
                i.stats.set(parseInt(e), {
                    min: s.base + t.level * s.min,
                    max: s.base + (t.level + 10) * s.max
                })
            }), e[t.type + t.tier] = i
        },
        dA = (t, e) => {
            let i = [(t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255];
            return void 0 !== e && i.push(e), i
        },
        d8 = [
            ["white", "common"],
            ["green", "uncommon"],
            ["blue", "rare"],
            ["purp", "epic"]
        ],
        dR = t => t >= 90 ? 3 : t >= 70 ? 2 : t >= 50 ? 1 : 0,
        dF = t => d8[dR(t)],
        dN = {
            black: dA(0, 0),
            white: dA(16777215, 0),
            deadgrey: dA(3355443, 0),
            teal: dA(3384995, 0),
            magicblue: dA(3362252, 0),
            paleskin: dA(14267315, 0),
            darkskin: dA(8411481, 0),
            slimegreen: dA(2542694, 0),
            mushgreen: dA(2077529, 0),
            linen: dA(13408614, 0),
            woodbrown: dA(4859433, 0),
            woodbrown2: dA(10250315, 0),
            tealsteel: dA(3358797, .5),
            darksteel: dA(3355443, .5),
            greysteel: dA(5066061, .5),
            blacksteel: dA(988178, .5),
            leather: dA(4337198, 0),
            emerald: dA(22866, -.1),
            gold: dA(16751616, .9),
            darkgold: dA(16747008, .9),
            paper: dA(15129011, 0),
            richpurple: dA(7484623, 0),
            fireorange: dA(14715686, -.7),
            archergreen: dA(10471258, 0),
            warbrown: dA(15172191, 0),
            bronze: dA(9258571, .5),
            silver: dA(11583679, .6),
            shamanblue: dA(3687924, 0),
            mageblue: dA(6607340, 0),
            bone: dA(14535066, .2),
            bone2: dA(11836267, .2),
            ice: dA(14610164, -.2),
            vanguard: dA(2848511, 0),
            bloodlust: dA(14289947, 0),
            pink: dA(16711935, 0),
            warden: dA(14755623, 0),
            evilred: dA(13239043, 0),
            ruby: dA(15733030, 1),
            moss: dA(2925637, .2),
            rock: dA(5006687, .4),
            death: dA(3750201, .8),
            diamond: dA(3076559, .9)
        },
        dI = [dN.woodbrown, dN.bronze, dN.greysteel, dN.silver, dN.gold],
        dU = [dN.diamond, dN.ruby],
        dz = [dN.leather, dN.greysteel, dN.silver, dN.gold, dN.diamond],
        dO = [
            [30, 1e4, 50, 0, 6, {}],
            [30, 2e4, 50, 0, 21, {}],
            [30, 5e4, 80, 300, 21, {
                colEyes: dA(11332842, 0),
                colPrim: dA(4772165, -.2),
                colSec: dA(1351204, -.2)
            }],
            [30, 5e4, 80, 300, 21, {
                colEyes: dA(16751284, 0),
                colPrim: dA(15737892, .5),
                colSec: dA(15737892, .5)
            }],
            [30, 5e4, 95, 1200, 22, {
                colEyes: dA(14292553, 0),
                colPrim: dA(4075311, .1),
                colSec: dA(1970198, .1)
            }],
            [30, 5e4, 90, 600, 23, {
                colEyes: dA(2029122, 0),
                colPrim: dA(2565674, .3),
                colSec: dA(2236197, .3)
            }],
            [30, 5e4, 80, 300, 24, {
                colEyes: dA(12825266, 0),
                colPrim: dA(11313312, .1),
                colSec: dA(8221555, .1)
            }],
            [30, 5e4, 90, 600, 25, {}],
            [30, 5e4, 95, 1200, 27, {
                colEyes: dA(12451327, 0),
                colPrim: dA(3950066, -.4),
                colSec: dA(3511541, -.4)
            }],
            [30, 5e4, 95, 1200, 28, {
                colEyes: dA(2747996, 0),
                colPrim: dA(1907231, .4)
            }],
            [30, 5e4, 80, 300, 30, {
                colEyes: dA(16758891, 0),
                colPrim: dA(15448667, .1),
                colSec: dA(11370036, .1)
            }],
            [30, 5e4, 95, 1200, 31, {
                colEyes: dA(16777215, -.8),
                colPrim: dN.darksteel,
                colSec: dN.gold
            }],
            [30, 5e4, 95, 1200, 32, {}],
            [30, 5e4, 85, 400, 29, {
                colEyes: dN.fireorange,
                colPrim: dN.darksteel
            }],
            [30, 5e4, 95, 1200, 33, {}]
        ].map(t => ({
            level: t[0],
            goldValue: t[1],
            storeValue: t[3],
            bindOnUse: 1,
            bindOnMerchant: t[3] > 0 ? 1 : 0,
            quality: t[2],
            visual: t[4],
            visualData: t[5]
        })),
        dL = {};
    (t => {
        for (let e in dE)
            if (dE[e].tiers) {
                let i = dE[e];
                for (let s = 0; s < i.tiers; ++s) dT({
                    type: e,
                    tier: s,
                    stats: i.stats,
                    level: dD(e, s),
                    class: i.class,
                    quality: i.quality
                }, t)
            }
    })(dL), (t => {
        let e = [250, 100, 500, 200, 1e3, 300];
        for (let i = 0; i < 6; ++i) {
            let s = Math.floor(i / 2),
                n = i % 2 == 0;
            t["misc" + i] = {
                type: "misc",
                tier: i,
                level: 1 + 20 * s,
                goldvalue: 5 ** s,
                quality: 15,
                custom: [e[i] + (n ? " HP recovered" : " MP recovered")],
                useSkill: 100,
                use(t, e, i, s) {}
            }
        }
    })(dL), t = dL, dC.forEach(e => {
        if (!e.engineOnly)
            for (let i = 0; i < e.skilllevels; ++i) {
                let s = 5 * e.id + i;
                t["book" + s] = {
                    type: "book",
                    tier: s,
                    level: e.minlevel + 8 * i,
                    skillid: e.id,
                    skilllevel: i,
                    class: e.class,
                    noReward: e.noReward || !1,
                    goldValue: e.goldValue || (e.minlevel + 5 * i < 5 ? 4 : 0),
                    quality: Math.round(Math.min(99, 30 + i / 5 * 70)),
                    art: rI(s, e.class),
                    useSkill: 101,
                    use(t, i, s, n) {
                        dS(t, e.id)
                    }
                }
            }
    }), e = dL, dO.forEach((t, i) => {
        e["mount" + i] = {
            ...t,
            type: "mount",
            tier: i,
            requiredSkill: 39,
            useSkill: 102,
            use: (t, e, s, n, a) => ({
                id: 92,
                mode: 4,
                stacks: 1,
                duration: 600,
                caster: t.id,
                target: t.id,
                buffdata: [i],
                sendBuffData: !0,
                level: e
            })
        }
    }), i = dL, df.forEach((t, e) => {
        i["charm" + t.id] = {
            ...d_,
            ...t,
            type: "charm",
            tier: t.id,
            useSkill: 107 + e
        }
    }), s = dL, [1919, 1920].forEach((t, e) => {
        s["pet" + e] = {
            level: 10,
            unsellable: !0,
            storeValue: 900,
            quality: 90,
            bindOnUse: 1,
            bindOnMerchant: 1,
            type: "pet",
            tier: e,
            useSkill: 104,
            use: (t, e, i, s, n) => !0
        }
    }), n = dL, [{
        id: 0,
        storeValue: 300,
        quality: 90,
        level: 1,
        custom: ["Contains random mount (account bound) of rare or epic quality"],
        bindOnPurchase: 1,
        use(t, e, i, s) {}
    }, {
        id: 1,
        storeValue: 900,
        quality: 90,
        level: 1,
        custom: ["Adds one month of Elixir to your account"],
        bindOnMerchant: 1,
        use(t, e, i, s) {}
    }].forEach(t => {
        n["box" + t.id] = {
            ...t,
            type: "box",
            tier: t.id,
            unsellable: !0,
            useSkill: 103
        }
    });
    let dB = Object.values(dL),
        dq = [{
            step: 10,
            fun: () => ob.fwd.down || ob.left.down || ob.right.down
        }, {
            step: 10,
            fun: () => ob.lmb.down || ob.rmb.down,
            click: !0
        }, {
            click: !0
        }, {
            element: "ufplayer",
            click: !0
        }, {}, {
            element: "uftarget",
            click: !0
        }, {
            element: "sk1"
        }, {}, {
            click: !0
        }, {
            element: "expbar",
            click: !0
        }, {}, {
            element: "sysbag",
            step: 100,
            fun: () => sO.inventoryOpen
        }, {
            element: "bag2",
            click: !0
        }, {
            click: !0
        }, {
            element: "syschar",
            step: 100,
            fun: () => sO.charpanelOpen
        }, {
            element: "equipslots",
            click: !0
        }, {
            fixed: () => as.player.stats.getStat(22) > 0 ? 100 : Math.round(as.player.exp / c_(as.player.level) * 100)
        }, {
            element: "syschar",
            step: 100,
            fun: () => sO.charpanelOpen
        }, {
            element: "statpoints"
        }, {
            step: 100,
            fixed: () => Math.round(as.player.exp / c_(as.player.level) * 100),
            fun: () => as.player.level > 3
        }, {
            click: !0
        }, {
            fixed: () => Math.round(as.player.inventory.gold / 32 * 100)
        }, {
            fun: () => sO.traderWindow
        }, {
            element() {
                let t = 0;
                return y.forEach(e => {
                    let i = dL[e.type + e.tier];
                    "book" === i.type && 3 === i.level && i.class === as.player.class && (t = e.id)
                }), "trader" + t
            }
        }, {
            element: "bag0",
            click: !0
        }, {
            element: "sysbook",
            step: 100,
            fun: () => sO.skillmenuOpen
        }, {
            element: "skilllist",
            click: !0
        }, {
            element: "tutsetskillpoint",
            click: !0
        }, {
            element: "tutapplyskills",
            click: !0
        }, {
            element: "skillbar",
            click: !0
        }, {
            click: !0
        }, {
            click: !0
        }, {
            click: !0
        }, {
            click: !0,
            element: "partybtn"
        }, {
            click: !0
        }, {
            click: !0
        }, {
            click: !0
        }, {
            click: !0
        }, {
            click: !0
        }, {
            click: !0
        }, {
            element: "chat"
        }, {
            element: "chatinput"
        }, {
            element: "syscog",
            step: 100,
            click: !0,
            fun: () => sO.settingsOpen
        }, {
            click: !0
        }, {
            step: 100,
            fun: () => !sO.settingsOpen
        }, {
            click: !0
        }, {
            click: !0
        }, {
            gate: () => as.player.level >= 25,
            click: !0
        }],
        dV = !1,
        dW = () => {
            dj.reset(as.smoothtime), dV || (dV = !0, iR.subscribe(t => {
                let e = dq[t];
                e && (void 0 === e.gate || e.gate()) ? e7.set(dH(t)) : e7.set()
            }))
        },
        dH = t => (lL(91), {
            ...dq[t],
            msg: rC.ui.tutorial.msg[t],
            progress: 0
        }),
        dj = new aH(0, .2),
        dG = () => {
            let t = dq[sO.tutprogress];
            t && dj.done(as.smoothtime) && (dj.reset(as.smoothtime), (void 0 === t.gate || t.gate()) && (t.gate && t.gate() && dY(sO.tutprogress, void 0, 1), t.fun && t.fun() && dY(sO.tutprogress, t.step), t.fixed && dY(sO.tutprogress, void 0, t.fixed())))
        },
        dY = (t, e, i) => !(!(i || e > 0) || -1 !== t && sO.tutprogress !== t) && (e7.update(s => s ? (s.progress = Math.min(100, i || s.progress + e), s.complete = s.progress >= 100, s.complete && !s.closing && (s.closing = !0, lL(92), setTimeout(() => {
            e7.set(), setTimeout(() => {
                iR.update(t => (ch("tutorial", "completestep", t, Math.round(performance.now() / 1e3)), dq[t + 1] && dq[t + 1].element && "string" != typeof dq[t + 1].element && (dq[t + 1].element = dq[t + 1].element()), t + 1))
            }, 100)
        }, 1e3)), s) : dH(t)), !0),
        dQ = Object.freeze({
            __proto__: null,
            steps: dq,
            onWorldEnter: dW,
            postTick: dG,
            tut: dY
        }),
        dX = 0,
        dJ = 0,
        dK = [0, 0, 0],
        dZ = !1,
        ut = {},
        ue = {},
        ui = [0, 0, 0],
        us = [256, 512, 1024, 2048, 4096][sO.shadowmapResolution] || 1024,
        un = {},
        ua = () => {
            for (let t in un.shadow = new nN, un.water = new nN, ut.shadowStatic = new nV(nK, {
                    width: us,
                    height: us,
                    color: 0,
                    depthTexture: !0,
                    depthCompareMode: nK.COMPARE_REF_TO_TEXTURE
                }), ut.shadow = new nV(nK, {
                    width: us,
                    height: us,
                    color: 0,
                    depthTexture: !0,
                    depthCompareMode: nK.COMPARE_REF_TO_TEXTURE
                }), ut.water = new nV(nK, {
                    width: us,
                    height: us,
                    color: 0,
                    depthTexture: !0
                }), ut) ue[t] = new Set([ut[t]])
        },
        ur = t => {
            let e = nZ.far;
            if (dX != e)
                for (let i in dX = e, dZ = !0, un) un[i].orthographic({
                    near: .1,
                    far: "shadow" == i ? 2 * e : 200,
                    left: -e,
                    right: e,
                    bottom: -e,
                    top: e
                }), un[i].updateMatrixWorldCamView(!0);
            if (sO.realtimeShadows || dZ || t - dJ > 10 || sJ(at.position, dK) > 15) {
                for (let s in sV(un.shadow.transform.position, ui), sQ(un.shadow.transform.position, un.shadow.transform.position, e), un.shadow.lookAt(aa, an), sj(un.shadow.transform.position, un.shadow.transform.position, at.position), sW(un.water.transform.position, 1e-4, 100, 0), un.water.lookAt(aa, an), sj(un.water.transform.position, un.water.transform.position, at.position), un.water.transform.position[1] = 200, sV(dK, at.position), un) un[s].updateMatrixWorldCamView(!1);
                dZ = !0, dJ = t
            }
        },
        ul = t => {
            dZ = t
        },
        uo = t => {
            sV(ui, t)
        },
        uc = {},
        ud = () => {
            uc = {
                resolution: {
                    c: u$,
                    value: [0, 0]
                },
                time: {
                    c: uu,
                    value: 0
                },
                daycycle: {
                    c: uu,
                    value: 0
                },
                ambientColor: {
                    c: uh,
                    value: [0, 0, 0]
                },
                skyColor: {
                    c: uh,
                    value: [0, 0, 0]
                },
                directionalDir: {
                    c: uh,
                    value: [0, 0, 0]
                },
                directionalColor: {
                    c: uh,
                    value: [0, 0, 0]
                },
                fogNear: {
                    c: uu,
                    value: 0
                },
                fogFar: {
                    c: uu,
                    value: 0
                },
                fogColor: {
                    c: uh,
                    value: [0, 0, 0]
                },
                cameraPosition: {
                    c: uh,
                    value: nZ.worldPosition
                },
                shadow: {
                    c: null,
                    value: ut.shadow.depthTexture
                },
                shadowPVMatrix: {
                    c: u_,
                    value: un.shadow.projectionViewMatrix
                },
                waterPVMatrix: {
                    c: u_,
                    value: un.water.projectionViewMatrix
                },
                waterDepth: {
                    c: null,
                    value: ut.water.depthTexture
                },
                waterDiffuse: {
                    c: null
                },
                waterDiffuse2: {
                    c: null
                },
                lightCols: {
                    c: null,
                    value: [0, 0, 0, 0]
                },
                lightPos: {
                    c: null,
                    value: [0, 0, 0]
                },
                lightCount: {
                    c: uu,
                    value: 0
                },
                particleDiffuse: {
                    c: null
                },
                foliageDiffuse: {
                    c: null
                },
                rocksDiffuse: {
                    c: null
                },
                terrainDiffuse: {
                    c: null,
                    value: ly.terrain
                },
                viewMatrix: {
                    c: null,
                    value: nZ.viewMatrix
                },
                projectionMatrix: {
                    c: null,
                    value: nZ.projectionMatrix
                },
                projectionViewMatrix: {
                    c: null,
                    value: nZ.projectionViewMatrix
                },
                skyDiffuse: {
                    c: null
                },
                cloudDiffuse: {
                    c: null
                },
                mouse: {
                    c: um,
                    value: [0, 0, 0, 0]
                },
                circleInfo: {
                    c: um,
                    value: [0, 1, 0, 1]
                }
            };
            for (let t = 0; t < 8; ++t) uc["tinf" + t] = {
                c: null,
                value: [0, 0, 0, 0]
            };
            for (let e in uc) uc[e].state = 0
        },
        uu = t => {
            t.value !== t.cacheValue && (t.state++, t.cacheValue = t.value)
        },
        u$ = t => {
            var e, i;
            t.cacheArray && (e = t.value, i = t.cacheArray, e[0] === i[0] && e[1] === i[1]) || (t.state++, t.cacheArray ? nW(t.cacheArray, t.value) : t.cacheArray = t.value.slice())
        },
        uh = t => {
            var e, i;
            t.cacheArray && (e = t.value, i = t.cacheArray, e[0] === i[0] && e[1] === i[1] && e[2] === i[2]) || (t.state++, t.cacheArray ? sV(t.cacheArray, t.value) : t.cacheArray = t.value.slice())
        },
        um = t => {
            var e, i;
            t.cacheArray && (e = t.value, i = t.cacheArray, e[0] === i[0] && e[1] === i[1] && e[2] === i[2] && e[3] === i[3]) || (t.state++, t.cacheArray ? n9(t.cacheArray, t.value) : t.cacheArray = t.value.slice())
        },
        u_ = t => {
            var e, i;
            t.cacheArray && (e = t.value, i = t.cacheArray, e[0] === i[0] && e[1] === i[1] && e[2] === i[2] && e[3] === i[3] && e[4] === i[4] && e[5] === i[5] && e[6] === i[6] && e[7] === i[7] && e[8] === i[8] && e[9] === i[9] && e[10] === i[10] && e[11] === i[11] && e[12] === i[12] && e[13] === i[13] && e[14] === i[14] && e[15] === i[15]) || (t.state++, t.cacheArray ? nf(t.cacheArray, t.value) : t.cacheArray = t.value.slice())
        },
        uf = t => {
            for (let e in uc.time.value = t % 600, uc) {
                let i = uc[e];
                null !== i.c && i.c(i)
            }
        },
        up, ug = (t, e) => {
            (t !== up || e) && (up = t, uc.viewMatrix.value = t.viewMatrix, uc.projectionMatrix.value = t.projectionMatrix, uc.projectionViewMatrix.value = t.projectionViewMatrix, uc.viewMatrix.state++, uc.projectionMatrix.state++, uc.projectionViewMatrix.state++)
        },
        uv = (t, e) => {
            nH(uc.resolution.value, t, e), uc.resolution.state++
        },
        uy = [0, 0, 0],
        u0 = {
            enemy: [1, 0, 0],
            friendly: [0, 1, 0],
            dead: [.6, .6, .6]
        },
        ub = t => {
            if (as && as.player) {
                let e = aF.clientPlayerChangeTarget.packData({
                    target: t
                });
                if (t !== as.player.target) {
                    if (t > 0) {
                        let i = as.entity(t);
                        void 0 !== i && (3 === i.type ? i.canBePickedUpBy(as.player) && lL(95) : (lL(93), 2 === i.faction && dY(4, 100)))
                    } else 0 === t && lL(94)
                }
                u9 = as.player.target, u1.reset(as.time), as.player.setTarget(t), rp(e)
            }
        },
        ux = 0,
        uw = !1,
        u1 = new aH(0, 1),
        u9 = 0,
        u3 = t => {
            u9 !== t && (u9 = t, u1.done(as.time) ? as.player.setTarget(t) : u1.reset(as.time, aL(u1.passed(as.time) + .5, .5, 2)))
        },
        uk = 0,
        u2 = () => {
            ob.lmb.onPress(t => {
                uk = as.time
            }), ob.lmb.onRelease(t => {
                uA > 0 ? uI() : ux > 0 && o2 < 20 && as.time - uk < .3 && ub(ux)
            }), ob.nextTarget.onPress(t => {
                uD = t.shiftKey ? 1 : 2
            }), ob.untarget.onPress(t => {
                ub(0)
            })
        },
        u4 = (t, e = !0) => {
            ux = t, uw = e && ux > 0, em.set(uw ? "pointer" : "auto"), e1.set(ux)
        },
        uC = () => {
            sW(uy, ov[0], ov[1], .5), nZ.unproject(uy), sY(uy, uy, nZ.worldPosition), sZ(uy, uy);
            let t = ux;
            ux = 0;
            let e = 1 / 0,
                i = !1;
            for (let s = 0, n = as.entities.array.length; s < n; ++s) {
                let a = as.entities.array[s];
                if (a.visual && a.visual.transform.visible) {
                    let r = sV(ao, a.visual.transform.position);
                    r[1] += .3 * a.size;
                    let l = sK(r, o$(nZ.worldPosition, uy, r));
                    l < e && l < (a.size + .7) ** 2 && a.hudPos[2] < 1 && (void 0 === a.stats || a.stats.alive) && (e = l, ux = a.id, i = 3 !== a.type || a.canBePickedUpBy(as.player))
                }
            }
            t == ux && i === uw || u4(ux, i)
        },
        uS = () => {
            let t = [0, 0, 0];
            nv(uF, nZ.transform.worldMatrix), sW(t, ov[0], ov[1], .5), nZ.unproject(t), sY(t, t, uF), sZ(t, t);
            let e = [0, 0];
            of(e, uF, t, as.player.pos, u8);
            let i = e[1] - Math.max(0, e[0]);
            if (i < 5 || -1 === e[0] && -1 === e[0]) {
                let s = o$(uF, t, as.player.pos),
                    n = s[0] - as.player.pos[0],
                    a = s[2] - as.player.pos[2],
                    r = 1 / Math.sqrt(n * n + a * a);
                sV(uF, as.player.pos), uF[0] += n * r * u8, uF[1] += 10, uF[2] += a * r * u8, sW(t, 0, -1, 0), i = 20
            } else e[0] > 0 && sX(uF, uF, t, e[0]);
            sQ(t, t, i);
            let l = as.raycastEnvironmentClosest(uF[0], uF[1], uF[2], t[0], t[1], t[2]);
            return sX(uF, uF, t, l), 1 === l && (uF[1] = as.getHeight(uF[0], uF[2])), uF
        },
        u7 = t => {
            if (u1.done(as.time) && as.player.target !== u9 && as.player.setTarget(u9), ob.shift.down);
            else {
                if (oS) return void(ux > 0 && (o2 >= 20 || as.time - uk > .3) && u4(0, !1));
                uC()
            }
        },
        uE, u6 = 0,
        uP = 0,
        uM = [1, 1, 1, .3],
        u5 = t => {
            if (!as.player) return;
            let e = as.player.target,
                i = ux > 0 ? as.getEntityById(ux) : void 0;
            if (void 0 !== i ? i !== uE && (void 0 !== uE && void 0 !== uE.visual && 3 !== uE.type && uE.visual.removeColor(uM), void 0 !== i.visual && 3 !== i.type && i.visual.addColor(uM), uE = i) : void 0 !== uE && void 0 !== uE.visual && (3 !== uE.type && uE.visual.removeColor(uM), uE = void 0), uA > 0) {
                let s = uS();
                n3(uc.circleInfo.value, ...u0.friendly, 1), n3(uc.mouse.value, s[0], s[1], s[2], uR)
            } else if (e !== u6 ? (u6 = e, uP = 1) : uP = Math.max(uP * (1 - 10 * t), 0), e > 0) {
                let n = as.getEntityById(e);
                if (void 0 !== n) {
                    n3(uc.mouse.value, n.pos[0], n.pos[1] - n.radius, n.pos[2], n.size + uP);
                    let a = n.stats && n.stats.alive ? as.player.hostility(n) > 0 ? u0.enemy : u0.friendly : u0.dead;
                    n3(uc.circleInfo.value, ...a, 1 - uP)
                }
            } else n3(uc.mouse.value, 0, 0, 0, 0)
        },
        uD = 0,
        uT = t => {
            if (uD > 0) {
                let e = 0,
                    i = 0;
                t = t.filter(t => void 0 !== t.visual && void 0 !== t.stats && t.stats.alive && t !== as.player && as.player.canCombatInteract(t) && .7 > Math.abs(od(as.player.rot, as.player.rotationToV3(t.pos))));
                let s = 0 === as.player.target;
                for (let n = t.length - 1; n >= 0; --n) {
                    let a = t[n];
                    1 === uD != as.player.hostility(a) > 0 && (s && (e = a.id), as.player.target === a.id && (s = !0), i || (i = a.id), 0 !== e && (n = 0))
                }
                0 === e && 0 !== i && (e = i), ub(e), uD = 0
            }
        },
        uA = 0,
        u8 = 0,
        uR = 0,
        uF = [0, 0, 0],
        uN = (t, e, i) => {
            uA = t, u8 = e, uR = i
        },
        uI = () => {
            0 !== uA && (rp(aF.clientPlayerEnvSkill.packData({
                id: uA,
                info: [],
                pos: uF
            })), uN(0, 0, 0))
        },
        uU = () => {
            u9 = 0, u1.reset(0), uE = void 0, u6 = 0, uP = 0
        },
        uz = Object.freeze({
            __proto__: null,
            ray: uy,
            setTarget: ub,
            get hovertarget() {
                return ux
            },
            get hoverinteractive() {
                return uw
            },
            targetSwitchNetTimer: u1,
            targetSwitchConciliate: u3,
            init: u2,
            setHoverTarget: u4,
            preTick: u7,
            tick: u5,
            parseHudTargets: uT,
            get envSkillId() {
                return uA
            },
            setEnvCast: uN,
            onWorldDestroy: uU
        }),
        uO = sO.itemTypeFilter.toLowerCase().replace(/\s/g, "").split(","),
        uL = new Set,
        uB = (t, e, i) => {
            for (let s = i.length - 1; s >= 0; s--) {
                let n = i[s];
                (n == e || 25 > sK(e.pos, n.pos)) && (t.push(n), sj(t.pos, t.pos, n.pos), i.splice(s, 1))
            }
        },
        uq = (t, e) => {
            sV(t.hudPos, t.visualPosition || t.pos), oL(t.hudPos, t.hudPos) && t.hudPos[2] < .997 && e.push(t)
        },
        uV = t => {
            let e = [];
            as.entities.array.forEach(t => {
                3 !== t.type || !t.visual.transform.visible || t.quality < sO.itemQualityFilter || uO.includes(t.droptype) || uq(t, e)
            }), uL.forEach(t => {
                t.uiTimeout < as.time ? uL.delete(t) : uq(t, e)
            }), e = e.sort((t, e) => e.id - t.id);
            let i = new Set;
            for (; e.length;) {
                let s = e[0],
                    n = [];
                n.pos = [0, 0, 0], uB(n, s, e), sQ(n.pos, n.pos, 1 / n.length), sW(n.pos, Math.round(n.pos[0]), Math.round(n.pos[1]), Math.round(n.pos[2])), oL(n.pos, n.pos) ? i.add(n.sort((t, e) => t.hudPos[2] - e.hudPos[2])) : i.delete(n)
            }
            let a = 0;
            Array.from(i).sort((t, e) => e.pos[2] - t.pos[2]).forEach(t => {
                let e = t.length / 5 * 100,
                    i = 0,
                    s = 0;
                t.forEach((n, r) => {
                    n.hudTextImg || (n.hudTextImg = oW(n.name, oq[n.color]));
                    let l = n.hudTextImg.width,
                        o = Math.round(t.pos[0] + s - .5 * e) - 2,
                        c = Math.round(t.pos[1] - 20 * i) - 8;
                    if (0 === n.uiTimeout) {
                        let d = n.canBePickedUpBy(as.player),
                            u = n.partyTimeoutCheck(as.player);
                        d && !(oy[0] > o + l || oy[1] > c + 20 || oy[0] < o || oy[1] < c) ? (a = n.id, oN.globalAlpha = 1) : oN.globalAlpha = d ? .4 : .1, oN.fillStyle = "#000000", oN.beginPath(), oN.rect(o, c, l, 20), oN.fill(), oz(nH(ah, o + 2, c + 8), n.name, u ? oq[n.color] : oq.itemgrey, d ? 1 : .8, 1, 0, 0, 0)
                    }(s += l + 3) > e && (i++, s = 0)
                })
            }), a !== ux && u4(a)
        },
        uW = [],
        uH, uj, uG = () => {
            let t = Math.ceil(100),
                e = Math.max(7, Math.ceil(9)),
                i = t - 4,
                s = e - 4;
            uW.push(oH(null, oF("panel"), t, e, 0, 0, Math.max(1, Math.ceil(2)))), oH(uW[0], oF("grey"), i, s, 2, 2, 1), uW.push(oH(null, oF("health"), i, s, 0, 0, 1)), uW.push(oH(null, oF("enemy"), i, s, 0, 0, 1)), uW.push(oH(null, oF("party"), i, s, 0, 0, 1)), uW.push(oH(null, oF("pvp"), i, s, 0, 0, 1)), uW.push(oH(null, "#555555", i, s, 0, 0, 1)), uW.push(oH(null, oF("spell"), i, s, 0, 0, 1));
            for (let n = 0; n <= 3; ++n) uW.push(oH(null, oF("c" + n), i, s, 0, 0, 1));
            uH = oH(null, "#ffffff", 104, 13, 0, 0, 3), uj = oH(null, "#ffffff", 104, 20, 0, 0, 3)
        },
        uY = () => {
            let t = [];
            return as.entities.array.forEach((e, i) => {
                !e.visual || !e.visual.transform.visible || e.stats && !e.stats.alive || e.id !== as.player.target && e.visual.cDist && e.visual.cDist > 60 || 3 === e.type && e.id !== ux || (sV(e.hudPos, e.visualPosition || e.pos), 3 !== e.type && (e.hudPos[1] += e.visual.getTopAbsolute()), oL(e.hudPos, e.hudPos) && (e === as.player && (e.hudPos[0] = Math.round(.5 * ai.canvas2dElement.width), e.hudPos[1] = Math.round(.5 * ai.canvas2dElement.height)), t.push(e)))
            }), t.sort((t, e) => e.hudPos[2] - t.hudPos[2])
        },
        uQ = (t, e) => {
            let i = t.visual && t.visual.cDist;
            if (i > sO.nameplateViewRange) return;
            i ? i /= 70 : i = 0;
            let s = t.party > 0 && t.party === as.player.party,
                n = t.id === as.player.target,
                a = t === as.player,
                r = void 0 !== t.faction ? as.player.hostility(t) : 0,
                l = t.id === ux;
            if (3 !== t.type && t.stats && t.stats.alive) {
                t.namePlateScale = aL(t.namePlateScale + .25 * ((n ? 1 : 0) - t.namePlateScale), .5, 1);
                let o = n ? 1 : .7 * Math.max(.1, Math.min(1, 1 - i)),
                    c = n || s ? 1 : Math.min(.8, l ? .9 : .75 * o + .2),
                    d = void 0 !== t.skills.timedSkill;
                !a && n && oU(d ? uj : uH, t.hudPos, 1, t.namePlateScale, 1, d ? 2 : 1, 0, d ? 4 : 0);
                let u = n || 0 === r && sO.nameplateShowFriendlyPlayers || 1 === r && sO.nameplateShowMonsters || 2 === r && sO.nameplateShowEnemyPlayers;
                if (d && u) {
                    let $ = uW[0].height - 2,
                        h = aL(t.skills.timedCast.fraction(as.smoothtime), 0, 1);
                    oU(uW[0], t.hudPos, c, t.namePlateScale, 1, 1, 0, $), h > 0 && oU(uW[6], t.hudPos, c, t.namePlateScale, h, 1, 0, $)
                }
                if (!a && u && (oU(uW[0], t.hudPos, c, t.namePlateScale, 1, d ? 2 : 1), oU(s ? uW[3] : 0 === r ? uW[sO.classColorBars && 0 === t.type ? 7 + t.class : 1] : as.player.canCombatInteract(t) ? r > 1 ? uW[sO.classColorBars ? 7 + t.class : 4] : uW[2] : uW[5], t.hudPos, c, t.namePlateScale, t.stats.getResource(6) / t.stats.getStat(6), 1), t.clan && oz(nH(ah, t.hudPos[0] - (uW[0].width / 2 + 2) * t.namePlateScale, t.hudPos[1]), t.clan, t.clan == as.player.clan ? oq.clan : 0 === t.faction ? oq.faction0small : oq.faction1small, c, 1, 2, 0, 1), t.level && (sO.alwaysShowLevel || n))) {
                    let m = oq.lev1;
                    r > 0 && (t.level - as.player.level > 4 ? m = oq.lev3 : t.level - as.player.level > 1 ? m = oq.lev2 : t.level - as.player.level < -5 && (m = oq.lev0)), oz(nH(ah, t.hudPos[0] + (uW[0].width / 2 + 2) * t.namePlateScale, t.hudPos[1]), t.level, m, c, 1, 0, 0, 0)
                }
            }
            if (a || n || t.faction < 2 || l) {
                let _ = 3 === t.type && l && !t.canBePickedUpBy(as.player) ? .5 : n || 3 === t.type ? 1 : l ? .9 : .7 * Math.max(.1, Math.min(1, 1 - i)),
                    f, p = !1;
                if (3 === t.type ? (f = t.partyTimeoutCheck(as.player) ? oq[t.color] : oq.itemgrey, p = !0) : 0 === r ? (f = n ? oq.name : oq.nameSmall, p = sO.nameShowFriendlyPlayers) : 1 === r ? (f = n ? oq.enemy : oq.enemySmall, p = sO.nameShowMonsters) : 2 === r && (f = n ? oq.pvp : oq.pvpSmall, p = sO.nameShowEnemyPlayers), n || p) {
                    let g = n ? -16 : -9,
                        v = a && t.clan ? 5 * t.clan.length : 0,
                        y = oz(t.hudPos, t.name, f, _, 1, v, g);
                    t.clan && a && oz(nH(ah, t.hudPos[0] - y / 2 + 2, t.hudPos[1]), t.clan, 0 === t.faction ? n ? oq.faction0 : oq.faction0small : n ? oq.faction1 : oq.faction1small, _, 1, 5 * t.clan.length, g, 1)
                }
            }
            t.speechText && oz(t.hudPos, t.speechText, t.speechStyle, 1, 1, 0, n ? -30 : -20, .5, 1)
        },
        uX = t => {
            uL.clear();
            let e = uY();
            uT(e), e = e.sort((t, e) => t.id === as.player.target || t.id === ux ? 1 : e.id === as.player.target || e.id === ux ? -1 : e.hudPos[2] - t.hudPos[2]), n3(a$, 0, 0, 0, 0), e.forEach(uQ)
        },
        uJ = () => {
            oI(), uG()
        },
        uK = t => {
            ai.canvas2dContext.clearRect(0, 0, ai.canvas2dElement.width, ai.canvas2dElement.height), ob.shift.down ? uV() : uX(), oQ(t)
        },
        uZ = Object.freeze({
            __proto__: null,
            init: uJ,
            postTick: uK
        }),
        $t = 0,
        $e = 0,
        $i = 0,
        $s = 0,
        $n = 0,
        $a = 0,
        $r = .6,
        $l = !1,
        $o = !1,
        $c = document.createElement("canvas"),
        $d, $u = [0, 0, 0, 30],
        $$ = $c.getContext("2d"),
        $h = document.createElement("img");
    $h.onload = function() {
        $o = !0
    }, $c.addEventListener("wheel", t => {
        $r = aL($r + (t.deltaY < 0 ? .1 : -.1), .35, 1.5)
    }, {
        passive: !0
    });
    let $m = {
            player: "#fff",
            monster: "#D53434",
            pvp: oF("pvp"),
            friendly: oF("health"),
            party: oF("party")
        },
        $_ = () => {
            ob.map.onPress(() => {
                $f($l = !$l)
            }), $d = [1265, 1266, 1817, 1812].map(t => {
                let e = document.createElement("img");
                return e.src = "assets/game/" + k(t, !0), e
            })
        },
        $f = t => {
            let e = $c.parentElement.parentElement.parentElement,
                i = Math.min(e.offsetWidth, e.offsetHeight),
                s = Math.round(t ? .8 * i : Math.max(150, Math.min(200, .2 * i)));
            s % 2 != 0 && (s += 1), $s = ($c.width = s) / 2, $i = ($c.height = s) / 2, $c.parentElement.style.height = $c.parentElement.style.width = 2 * $s + "px"
        },
        $p = 0,
        $g = t => {
            if ($p++, !$o || !as.player || sO.mapLowQuality && $p % 10 != 0) return;
            if ($l) $t = $e = 0, $$.drawImage($h, 0, 0, $c.width, $c.height);
            else {
                $n = $h.width * $r, $a = $h.height * $r;
                let e = ~~Math.max($s, $n * as.player.pos[0] / as.bounds);
                $t = e - Math.max($s, $s + ($s - ($n - e)));
                let i = ~~Math.max($i, $a * as.player.pos[2] / as.bounds);
                $e = i - Math.max($i, $i + ($i - ($a - i))), $$.drawImage($h, Math.max($s - $n, -$t), Math.max($i - $a, -$e), $n, $a)
            }
            let s = !1;
            as.mapinfo.icons.forEach(t => {
                s = s || t.blink, $v(t.pos[0], t.pos[1], $d[t.id], t.blink, $u[t.id])
            }), s && ($$.globalAlpha = 1), as.entities.array.forEach(t => {
                t.stats && t.stats.alive && $y(t.pos[0], t.pos[2], t.type, as.player.hostility(t), t.party > 0 && t.party === as.player.party, t === as.player)
            }), as.party.forEach(t => {
                t.local && void 0 !== t.pos && !as.isEntityIdTaken(t.id) && $y(t.pos[0], t.pos[1], 0, 0, as.player.party, !1)
            })
        },
        $v = (t, e, i, s, n) => {
            let a = $0(t, e);
            if (a[0] < 1 || a[1] < 1 || a[0] >= $c.width || a[1] >= $c.height) return;
            !s || as.smoothtime % 1 < .5 ? $$.globalAlpha = s ? .6 : .8 : $$.globalAlpha = 1;
            let r = n > 0 ? n : i.width,
                l = n > 0 ? n * i.height / i.width : i.height;
            $$.drawImage(i, ~~(a[0] - r / 2), ~~(a[1] - l / 2), ~~r, ~~l)
        },
        $y = (t, e, i, s, n, a) => {
            if (!sO.mapShowMonsters && 1 === i) return;
            let r = $0(t, e);
            if (!(r[0] < 1 || r[1] < 1 || r[0] >= $c.width || r[1] >= $c.height)) {
                if (0 === i) {
                    if ($l && n && as.smoothtime % 1 > .5) return;
                    $$.fillStyle = 0 === s ? a ? $m.player : n ? $m.party : $m.friendly : $m.pvp, $$.fillRect(...r, 5, 5)
                } else $$.fillStyle = s > 0 ? $m.monster : $m.friendly, $$.fillRect(...r, 3, 3)
            }
        },
        $0 = (t, e) => [Math.round(t / as.bounds * ($l ? $c.width : $n) - $t), Math.round(e / as.bounds * ($l ? $c.height : $a) - $e)],
        $b = t => {
            $h.src = rL(t.file), $o = !1
        },
        $x = t => {
            $o = !1
        },
        $w = Object.freeze({
            __proto__: null,
            canvas: $c,
            init: $_,
            changeCanvas: $f,
            postTick: $g,
            onWorldEnter: $b,
            onWorldDestroy: $x
        }),
        $1 = (t, e = "") => {
            rp(aF.clientCommand.packData({
                command: t,
                string: e + ""
            }))
        },
        $9 = new aH(0, 2),
        $3 = (t, e) => {
            if ($9.done(e.time) && void 0 !== e.player) {
                $9.reset(e.time);
                let i = void 0 === e.player.inventory.findFirstEmpty(),
                    s = e.entities.array.filter(t => 3 === t.type && t.visual.transform.visible && t.quality >= sO.itemQualityFilter && (e.player.id === t.party || e.player.party === t.party) && t.canBePickedUpBy(e.player, 900) && !uO.includes(t.droptype) && (!i || "gold" === t.droptype || t.stackable && void 0 !== e.player.inventory.findFirstUnmaxedStackableOfType(t.droptype, t.tier)));
                s.length > 0 && (s.sort((t, e) => e.lootquality - t.lootquality), s.length = Math.min(s.length, 8), $1("petlootid", s.map(t => t.id).join(",")))
            }
        },
        $k = () => {
            $9.reset(0)
        },
        $2 = Object.freeze({
            __proto__: null,
            postTick: $3,
            onWorldEnter: $k
        }),
        $4 = new aH(0, 1),
        $C = [],
        $S = (t, e) => {
            $4.done(e.time) && ($4.reset(e.time), $C.length && ($C.forEach(t => {
                $P(t, 1)
            }), ee.set($C)))
        },
        $7 = t => {
            $4.reset(0)
        },
        $E = t => {
            $C.length = 0, ee.set($C)
        },
        $6 = (t, e, i) => {
            let s = {
                title: t,
                text: e,
                choices: i
            };
            $C.push(s), $P(s, 0), ee.set($C)
        },
        $P = (t, e) => {
            for (let i = 0; i < t.choices.length; ++i) {
                let s = t.choices[i];
                if (void 0 !== s.blockedTime) s.blockedTime > 1 ? (s.blockedTime -= e, s.unavailable = `(${s.blockedTime} s)`) : s.unavailable = void 0;
                else if (s.nocombat && as && as.player && as.player.stats) {
                    let n = ~~as.player.stats.combatTimer.remaining(as.time);
                    s.unavailable = n > 0 ? `(Combat - ${n}s)` : void 0
                }
                void 0 !== s.remaining && (s.remaining > 1 ? (s.remaining -= e, s.additional = `(${~~s.remaining}s remaining)`) : (s.additional = void 0, s.unavailable = "(Timed out)"))
            }
        },
        $M = () => {
            $C.length && ($C.shift(), ee.set($C))
        },
        $5 = !0,
        $D = (t, e, i, s) => {
            t ? $5 && ($6(i, s, [{
                text: i,
                fun() {
                    $5 = !0, e()
                }
            }, {
                text: rC.ui.decline,
                fun() {
                    $5 = !0
                }
            }]), $5 = !1) : e()
        },
        $T = Object.freeze({
            __proto__: null,
            postTick: $S,
            onWorldEnter: $7,
            onWorldDestroy: $E,
            addRequest: $6,
            removeTopRequest: $M,
            confirmationBasedCallback: $D
        });
    class $A extends tY {
        constructor(t) {
            super(), tG(this, t, null, function t(e) {
                let i;
                return {
                    c() {
                        (i = J("div")).innerHTML = '<div class="bounce1 svelte-twvoek"></div><div class="bounce2 svelte-twvoek"></div><div class="bounce3 svelte-twvoek"></div>', ti(i, "class", "spinner svelte-twvoek")
                    },
                    m(t, e) {
                        Y(t, i, e)
                    },
                    p: C,
                    i: C,
                    o: C,
                    d(t) {
                        t && Q(i)
                    }
                }
            }, R, {})
        }
    }

    function $8(t, {
        delay: e = 0,
        duration: i = 400,
        easing: s = S
    }) {
        let n = +getComputedStyle(t).opacity;
        return {
            delay: e,
            duration: i,
            easing: s,
            css: t => "opacity: " + t * n
        }
    }

    function $R(t) {
        let e, i, s, n, a, r;
        return i = new $A({}), {
            c() {
                e = J("div"), tW(i.$$.fragment), s = J("h5"), n = K(t[0]), a = K("  0.42.5699 Live"), ti(s, "class", "version textgrey svelte-1mq2czx"), ti(e, "class", "l-ui container svelte-1mq2czx")
            },
            m(t, l) {
                Y(t, e, l), tH(i, e, null), G(e, s), G(s, n), G(s, a), r = !0
            },
            p(t, e) {
                (!r || 1 & e) && tn(n, t[0])
            },
            i(t) {
                r || (tR(i.$$.fragment, t), r = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), r = !1
            },
            d(t) {
                t && Q(e), tj(i)
            }
        }
    }
    class $F extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let {
                    active: n
                } = i;
                return e.$$set = t => {
                    "active" in t && s(0, n = t.active)
                }, [n]
            }, function t(e) {
                let i, s, n = e[0] && $R(e);
                return {
                    c() {
                        n && n.c(), i = tt()
                    },
                    m(t, e) {
                        n && n.m(t, e), Y(t, i, e), s = !0
                    },
                    p(t, [e]) {
                        t[0] ? n ? (n.p(t, e), 1 & e && tR(n, 1)) : ((n = $R(t)).c(), tR(n, 1), n.m(i.parentNode, i)) : n && (tA(), tF(n, 1, 1, () => {
                            n = null
                        }), t8())
                    },
                    i(t) {
                        s || (tR(n), s = !0)
                    },
                    o(t) {
                        tF(n), s = !1
                    },
                    d(t) {
                        n && n.d(t), t && Q(i)
                    }
                }
            }, A, {
                active: 0
            })
        }
    }
    let $N = {
            frag: "snippet version;out vec4 fragColor;in vec2 vUv;in vec3 vPos;snippet uniformsEnvironment;uniform float time;uniform float daycycle;uniform sampler2D cloudDiffuse;void main(){gl_FragDepth=0.999997;vec2 pos=vec2(vUv.x+time*0.005,vUv.y);float cloud=texture(cloudDiffuse,pos).r;cloud+=sin(daycycle*6.28)*0.04-0.035;if(cloud<0.17){discard;}cloud=smoothstep(0.3,0.6,cloud);cloud*=smoothstep(0.0,0.3,vPos.y);float sunAngle=max(dot(directionalDir,normalize(vPos)),0.0);float sunPower=max(0.0,pow(sunAngle,6.0))*0.3;vec3 base=mix(fogColor+sunPower+vec3(0.3),fogColor+sunPower+vec3(0.1),cloud);fragColor=vec4(base,cloud);}"
        },
        $I = {
            frag: "snippet version;in vec2 vUv;uniform float seed;snippet noiseHash;snippet noise2d;out vec4 fragColor;void main(){vec2 pos=vec2(vUv.x*0.7+seed,vUv.y)*1.5;float cloud=0.0;const int amt=8;for(int i=1;i<amt;++i){float mul=float(i);cloud+=noise(pos*pow(mul,1.2+mul*0.05)+vec2(pow(mul,3.5)*0.0002,mul))/mul;}cloud+=noise(pos*25.0)/15.0;cloud+=noise(pos*40.0)/35.0;cloud=cloud/(float(amt)-5.0)*0.8+0.05;cloud-=pow(max(0.0,abs(vUv.x-0.5)),5.0)*18.0;fragColor.rgb+=cloud;}"
        },
        $U = {
            frag: "snippet version;out vec4 fragColor;snippet uniformsEnvironment;uniform sampler2D diffuse;uniform float time;in vec2 vUv;in float vShine;void main(){snippet discardInFog;vec4 result=texture(diffuse,vUv);if(result.a<0.25)discard;result.rgb=mix(result.rgb*ambientColor,result.rgb*1.1,smoothstep(-0.7,0.7,sin(time*6.0+vShine)));snippet applyFog;fragColor=result;}",
            vert: "snippet version;snippet uniformsEnvironment;in vec2 uv;in vec3 position;in vec3 normal;in mat4 worldMatrix;in vec4 uvshift;in float shine;uniform mat4 projectionViewMatrix;out float vShine;out vec2 vUv;void main(){vShine=shine;vWorldPos=worldMatrix*vec4(position,1.0);vUv=uvshift.zw-uv*uvshift.xy;snippet calculateCameraDistance;gl_Position=projectionViewMatrix*worldMatrix*vec4(position,1.0);}"
        },
        $z = {
            frag: "snippet version;snippet uniformsEnvironment;uniform float time;uniform sampler2D foliageDiffuse;in vec3 vLight;in float lightValue;in vec2 vOffset;in float direction;in float wind;out vec4 fragColor;const float CUTOFF=1.0/(128.0/4.0);void main(){vec2 uv=vec2(gl_PointCoord.x+wind*(1.0-gl_PointCoord.y)*0.08,gl_PointCoord.y);if(uv.x<CUTOFF||uv.x>1.0-CUTOFF||uv.y>1.0-CUTOFF||uv.y<CUTOFF){discard;}uv.x=mod(direction*uv.x,1.0)*0.25;uv.y=1.0-uv.y*0.25;uv+=vOffset;vec4 result=texture(foliageDiffuse,uv);if(result.a<0.1)discard;result.a=min(1.0,result.a*2.0);result.rgb=result.rgb*vLight+result.rgb*directionalColor*lightValue+result.rgb*ambientColor;snippet applyFog;fragColor=result;}",
            vert: "snippet version;precision highp sampler2DShadow;snippet uniformsEnvironment;snippet uniformsPointlights;snippet shadowsEnabled;uniform mat4 projectionViewMatrix;uniform mat4 shadowPVMatrix;uniform sampler2DShadow shadow;uniform vec2 resolution;in vec4 posOffset;in vec2 info;out vec2 vOffset;out float lightValue;out float direction;out float wind;snippet transformShadowPos;uniform float time;void main(){vOffset=vec2(fract(info[0]*0.25),-floor(info[0]/4.0)*0.25);direction=info[1];vCameraDistance=length(cameraPosition-posOffset.xyz);float scale=clamp(1.0-(vCameraDistance-min(fogFar/2.0,100.0))/20.0,0.0,1.0);if(scale<=0.0){gl_PointSize=0.;gl_Position.w=0.0;}else{wind=cos(time*0.5+posOffset.x*0.2)*sin(time*4.0+posOffset.z*0.5);if(shadowsEnabled==1){vec4 shadowPos=transformShadowPos(shadowPVMatrix*vec4(posOffset.xyz,1));vec3 shadowCoord=(shadowPos.xyz/shadowPos.w)*0.5+0.5;lightValue=texture(shadow,shadowCoord);}else{lightValue=1.0;}lightValue*=0.65;vec3 light=vec3(0.0);for(int i=0;i<lightCount;++i){vec3 lightDir=lightPos[i]-posOffset.xyz;float strenght=lightCols[i].w-dot(lightDir,lightDir);if(strenght>0.0){strenght/=(lightCols[i].w);strenght=strenght*strenght;light+=0.5*lightCols[i].rgb*strenght;;}}vLight=light;gl_Position=projectionViewMatrix*vec4(posOffset.xyz,1);gl_PointSize=(1.0/gl_Position.w)*resolution[1]*scale*posOffset.w;}}"
        },
        $O = {
            frag: "snippet version;snippet uniformsEnvironment;uniform sampler2D diffuse;in vec3 vNormal;in vec2 vUv;in vec4 vCol;in vec2 vYcutoff;in vec4 vUvshift;out vec4 fragColor;void main(){snippet discardInFog;vec2 uv=vec2((vUv.x+vUvshift.x)*vUvshift.z,(vUv.y+vUvshift.y)*vUvshift.w);vec4 result=vec4(1.0,1.0,1.0,texture(diffuse,uv).r)*vCol;result.a*=min(1.0,max(0.0,vUv.y/vYcutoff[0]));result.a*=min(1.0,max(0.0,(vYcutoff[1]-vUv.y)/(1.0-vYcutoff[1])));if(result.a<0.01){discard;}snippet applyFog;fragColor=result;fragColor.rgb*=fragColor.a;}",
            vert: "snippet version;snippet uniformsEnvironment;uniform mat4 projectionViewMatrix;in vec2 uv;in vec3 position;in vec3 normal;in mat4 worldMatrix;in vec4 uvshift;in vec2 ycutoff;in vec4 color;out vec3 vNormal;out vec2 vUv;out vec4 vCol;out vec2 vYcutoff;out vec4 vUvshift;void main(){vNormal=normalize(mat3(worldMatrix)*normal);vUv=uv;vUvshift=uvshift;vCol=color;vYcutoff=ycutoff;vWorldPos=worldMatrix*vec4(position,1.0);snippet calculateCameraDistance;gl_Position=projectionViewMatrix*vWorldPos;}"
        },
        $L = {
            frag: "snippet version;precision highp sampler2DShadow;snippet uniformsEnvironment;snippet shadowsEnabled;uniform sampler2DShadow shadow;uniform int shadowActive;in vec3 vLight;in vec4 vColor;in vec3 vNormal;in vec3 vShadowCoord;out vec4 fragColor;\n#define RECIPROCAL_PI 0.31830988618\n#define LOG2 1.442695\n#define PI 3.14159265359\nvoid main(){snippet discardInFog;float facing=(float(gl_FrontFacing)*2.0-1.0);float lambertian=clamp(dot(vNormal*facing,directionalDir),0.0,1.0);float shadowMask=1.0;if(shadowsEnabled==1&&shadowActive==1&&lambertian>0.0){shadowMask=texture(shadow,vShadowCoord);}vec3 reflectDir=reflect(directionalDir,vNormal);float specular=max(0.0,dot(normalize(cameraPosition-vWorldPos.xyz),-reflectDir));specular=pow(specular*max(0.0,min(1.0,vColor[3]*2.0))*1.5,5.0);vec3 diffuse=vColor.rgb;vec3 ambient=ambientColor*PI;ambient*=RECIPROCAL_PI*diffuse;vec3 directional=PI*vLight+(lambertian*(PI*directionalColor)+specular)*shadowMask;directional*=RECIPROCAL_PI*diffuse;vec3 specColor=vColor.rgb*max(vColor[3]*0.5-0.5,-vColor[3]);vec4 result=vec4(directional+ambient+specColor,1.0);snippet applyFog;fragColor=result;}",
            vert: "snippet version;snippet uniformsPointlights;snippet uniformsEnvironment;snippet shadowsEnabled;in vec3 position;in vec3 normal;in vec4 color;in mat4 worldMatrix;uniform mat4 projectionViewMatrix;uniform mat4 shadowPVMatrix;out vec4 vColor;out vec3 vNormal;out vec3 vShadowCoord;snippet transformShadowPos;void main(){vNormal=normalize(mat3(worldMatrix)*normal);vWorldPos=worldMatrix*vec4(position,1.0);vColor=color;snippet calculateCameraDistance;snippet calculatePointlights;if(shadowsEnabled==1){vec4 vShadowPos=transformShadowPos(shadowPVMatrix*(vWorldPos+vec4(vNormal*0.1,0.0)));vShadowCoord=(vShadowPos.xyz/vShadowPos.w)*0.5+0.5;}gl_Position=projectionViewMatrix*vWorldPos;}"
        },
        $B = {
            frag: "snippet version;in vec4 vColor;out vec4 fragColor;void main(){fragColor=vColor;fragColor.a=1.0;}",
            vert: "snippet version;in vec3 position;in vec4 color;in mat4 worldMatrix;uniform mat4 projectionViewMatrix;out vec4 vColor;void main(){vColor=color;gl_Position=projectionViewMatrix*worldMatrix*vec4(position,1.0);;}"
        },
        $q = {
            frag: "snippet version;precision highp sampler2DShadow;snippet uniformsEnvironment;snippet shadowsEnabled;in vec3 vLight;uniform sampler2D diffuse;uniform sampler2DShadow shadow;uniform int shadowActive;uniform vec4 mouse;uniform vec4 circleInfo;in vec3 vNormal;in vec3 vShadowCoord;in vec2 vUv;out vec4 fragColor;void main(){snippet discardInFog;vec4 result=texture(diffuse,vUv);if(result.a<0.5)discard;float facing=(float(gl_FrontFacing)*2.0-1.0);float lambertian=max(dot(vNormal*facing,directionalDir),0.0);if(shadowsEnabled==1&&shadowActive==1&&lambertian>0.0){float shadowValue=texture(shadow,vShadowCoord);snippet shadowFogMax;lambertian*=max(shadowValue,shadowFogMax);}result.rgb=result.rgb*vLight+result.rgb*directionalColor*lambertian+result.rgb*ambientColor;snippet applyFog;float circle=distance(vWorldPos.xz,mouse.xz);float vertical=min(1.0,max(0.0,4.0-abs(vWorldPos.y-mouse.y)));if(circle<mouse.w+0.1&&vertical>0.0){result.rgb=mix(result.rgb,circleInfo.rgb,vertical*circleInfo.a*((circle<mouse.w ? circle/mouse.w*0.5 : 0.0)+max(0.,(0.1-abs(mouse.w-circle))/0.1)));}fragColor=result;}",
            vert: "snippet version;snippet uniformsPointlights;snippet uniformsEnvironment;snippet shadowsEnabled;in vec2 uv;in vec3 position;in vec3 normal;in mat4 worldMatrix;uniform mat4 projectionViewMatrix;uniform mat4 shadowPVMatrix;out vec3 vNormal;out vec2 vUv;out vec3 vShadowCoord;snippet transformShadowPos;void main(){vNormal=normalize(mat3(worldMatrix)*normal);vUv=uv;vWorldPos=worldMatrix*vec4(position,1.0);snippet calculateCameraDistance;snippet calculatePointlights;if(shadowsEnabled==1){vec4 vShadowPos=transformShadowPos(shadowPVMatrix*(vWorldPos+vec4(vNormal*0.2,0.0)));vShadowCoord=(vShadowPos.xyz/vShadowPos.w)*0.5+0.5;}gl_Position=projectionViewMatrix*vWorldPos;}"
        },
        $V = {
            vert: "snippet version;snippet uniformsPointlights;snippet uniformsEnvironment;snippet shadowsEnabled;in vec2 uv;in vec3 position;in vec3 normal;in float tile;in mat4 worldMatrix;uniform mat4 projectionViewMatrix;uniform mat4 shadowPVMatrix;out vec3 vNormal;out vec2 vUv;out vec3 vShadowCoord;snippet transformShadowPos;void main(){vNormal=normalize(mat3(worldMatrix)*normal);vUv=uv*tile;vWorldPos=worldMatrix*vec4(position,1.0);snippet calculateCameraDistance;snippet calculatePointlights;if(shadowsEnabled==1){vec4 vShadowPos=transformShadowPos(shadowPVMatrix*(vWorldPos+vec4(vNormal*0.2,0.0)));vShadowCoord=(vShadowPos.xyz/vShadowPos.w)*0.5+0.5;}gl_Position=projectionViewMatrix*vWorldPos;}"
        },
        $W = {
            frag: "snippet version;precision highp sampler2DShadow;snippet uniformsEnvironment;snippet shadowsEnabled;in vec3 vLight;uniform sampler2D diffuse;uniform sampler2DShadow shadow;uniform int shadowActive;in vec3 vNormal;in vec3 vShadowCoord;in vec2 vUv;out vec4 fragColor;void main(){snippet discardInFog;vec4 result=texture(diffuse,vUv);if(result.a<0.5)discard;float lambertian=max(dot(vNormal,directionalDir),0.0);if(shadowsEnabled==1&&shadowActive==1&&lambertian>0.0){float shadowValue=texture(shadow,vShadowCoord+vec3(0.0,0.0,-0.001));snippet shadowFogMax;lambertian*=max(shadowValue,shadowFogMax);}result.rgb=result.rgb*vLight+result.rgb*directionalColor*lambertian+result.rgb*ambientColor;snippet applyFog;fragColor=result;}"
        },
        $H = {
            vert: "snippet version;in vec3 pos;uniform mat4 viewMatrix;uniform mat4 projectionMatrix;uniform vec2 resolution;in vec4 info;in vec2 progress;in vec4 scaleRota;in vec4 colStart;in vec4 colEnd;out vec4 vCol;out float vRotationCos;out float vRotationSin;out vec2 vOffset;void main(){float id=min(info[3]-1.0,floor(mix(info[2],info[3],mod(info[0]*progress[0],1.0))));vOffset=vec2(fract(id*0.125),-floor(id/8.0)*0.125);vCol=mix(colStart,colEnd,progress[1]);float rot=mix(scaleRota[2],scaleRota[3],progress[0]);vRotationCos=cos(rot);vRotationSin=sin(rot);float size=mix(scaleRota[0],scaleRota[1],progress[1])*(abs(vRotationSin)+abs(vRotationCos));vec4 vWorldPos=viewMatrix*vec4(pos,1.0);gl_PointSize=(resolution[1]*size)/length(vWorldPos.xyz);gl_Position=projectionMatrix*vWorldPos;}"
        },
        $j = {
            frag: "snippet version;uniform sampler2D particleDiffuse;in vec4 vCol;in vec2 vOffset;in float vRotationCos;in float vRotationSin;out vec4 fragColor;const float CUTOFF=1.0/(1024.0/8.0);void main(){float mid=0.5;float rotScale=abs(vRotationSin)+abs(vRotationCos);vec2 uv=vec2(gl_PointCoord.x-mid,gl_PointCoord.y-mid)*rotScale;vec2 cosv=uv*vRotationCos;vec2 sinv=uv*vRotationSin;uv=vec2(cosv.x+sinv.y+mid,cosv.y-sinv.x+mid);if(uv.x<CUTOFF||uv.x>1.0-CUTOFF||uv.y>1.0-CUTOFF||uv.y<CUTOFF){discard;}uv.x*=0.125;uv.y=1.0-uv.y*0.125;vec4 result=vec4(1.0,1.0,1.0,texture(particleDiffuse,uv+vOffset).r);result*=vCol;if(result.a<0.01){discard;}fragColor=result;fragColor.rgb*=fragColor.a;fragColor.a*=0.33;}"
        },
        $G = {
            frag: "snippet version;snippet uniformsEnvironment;uniform sampler2D particleDiffuse;in vec4 vCol;in vec2 vOffset;in float vRotationCos;in float vRotationSin;out vec4 fragColor;const float CUTOFF=1.0/(1024.0/8.0);void main(){float mid=0.5;float rotScale=abs(vRotationSin)+abs(vRotationCos);vec2 uv=vec2(gl_PointCoord.x-mid,gl_PointCoord.y-mid)*rotScale;vec2 cosv=uv*vRotationCos;vec2 sinv=uv*vRotationSin;uv=vec2(cosv.x+sinv.y+mid,cosv.y-sinv.x+mid);if(uv.x<CUTOFF||uv.x>1.0-CUTOFF||uv.y>1.0-CUTOFF||uv.y<CUTOFF){discard;}uv.x*=0.125;uv.y=1.0-uv.y*0.125;vec3 tex=texture(particleDiffuse,uv+vOffset).rgb;if((tex.r+tex.g+tex.b)<0.05){discard;}fragColor=vec4(tex.rgb,1.0);}"
        },
        $Y = {
            frag: "snippet version;uniform sampler2D tMap;uniform sampler2D tOrig;uniform vec2 resolution;in vec2 vUv;uniform int step;float weight[8]=float[8](0.118,0.113,0.100,0.082,0.061,0.042,0.027,0.016);out vec4 fragColor;void main(){vec2 tex_offset=1.0/resolution;vec3 result=vec3(1.0);if(step==0){result=texture(tOrig,vUv).rgb*weight[0];for(int i=1;i<8;++i){result+=texture(tOrig,vUv+vec2(tex_offset.x*float(i),0.0)).rgb*weight[i];result+=texture(tOrig,vUv-vec2(tex_offset.x*float(i),0.0)).rgb*weight[i];}result=smoothstep(vec3(0.4),vec3(0.75),result);result*=0.18;}else{result=texture(tMap,vUv).rgb*weight[0];for(int i=1;i<8;++i){result+=texture(tMap,vUv+vec2(0.0,tex_offset.y*float(i))).rgb*weight[i];result+=texture(tMap,vUv-vec2(0.0,tex_offset.y*float(i))).rgb*weight[i];}}if(step==1)result=result+texture(tOrig,vUv).rgb;fragColor=vec4(result,1.0);}"
        },
        $Q = {
            frag: "snippet version;uniform sampler2D tOrig;uniform vec2 resolution;in vec2 vUv;out vec4 fragColor;\n#define texTop(t, p) texture(t, p, 0.0)\n#define texOff(t, p, o, r) texture(t, p + (o * r), 0.0)\nvec4 FxaaPixelShader(vec2 pos,sampler2D tex,vec2 fxaaQualityRcpFrame,float fxaaQualitySubpix,float fxaaQualityEdgeThreshold,float fxaaQualityEdgeThresholdMin){vec2 posM;posM.x=pos.x;posM.y=pos.y;vec4 rgbyM=texTop(tex,posM);\n#define lumaM rgbyM.y\nfloat lumaS=texOff(tex,posM,vec2(0.0,1.0),fxaaQualityRcpFrame.xy).y;float lumaE=texOff(tex,posM,vec2(1.0,0.0),fxaaQualityRcpFrame.xy).y;float lumaN=texOff(tex,posM,vec2(0.0,-1.0),fxaaQualityRcpFrame.xy).y;float lumaW=texOff(tex,posM,vec2(-1.0,0.0),fxaaQualityRcpFrame.xy).y;float maxSM=max(lumaS,lumaM);float minSM=min(lumaS,lumaM);float maxESM=max(lumaE,maxSM);float minESM=min(lumaE,minSM);float maxWN=max(lumaN,lumaW);float minWN=min(lumaN,lumaW);float rangeMax=max(maxWN,maxESM);float rangeMin=min(minWN,minESM);float rangeMaxScaled=rangeMax*fxaaQualityEdgeThreshold;float range=rangeMax-rangeMin;float rangeMaxClamped=max(fxaaQualityEdgeThresholdMin,rangeMaxScaled);bool earlyExit=range<rangeMaxClamped;if(earlyExit)return rgbyM;float lumaNW=texOff(tex,posM,vec2(-1.0,-1.0),fxaaQualityRcpFrame.xy).y;float lumaSE=texOff(tex,posM,vec2(1.0,1.0),fxaaQualityRcpFrame.xy).y;float lumaNE=texOff(tex,posM,vec2(1.0,-1.0),fxaaQualityRcpFrame.xy).y;float lumaSW=texOff(tex,posM,vec2(-1.0,1.0),fxaaQualityRcpFrame.xy).y;float lumaNS=lumaN+lumaS;float lumaWE=lumaW+lumaE;float subpixRcpRange=1.0/range;float subpixNSWE=lumaNS+lumaWE;float edgeHorz1=(-2.0*lumaM)+lumaNS;float edgeVert1=(-2.0*lumaM)+lumaWE;float lumaNESE=lumaNE+lumaSE;float lumaNWNE=lumaNW+lumaNE;float edgeHorz2=(-2.0*lumaE)+lumaNESE;float edgeVert2=(-2.0*lumaN)+lumaNWNE;float lumaNWSW=lumaNW+lumaSW;float lumaSWSE=lumaSW+lumaSE;float edgeHorz4=(abs(edgeHorz1)*2.0)+abs(edgeHorz2);float edgeVert4=(abs(edgeVert1)*2.0)+abs(edgeVert2);float edgeHorz3=(-2.0*lumaW)+lumaNWSW;float edgeVert3=(-2.0*lumaS)+lumaSWSE;float edgeHorz=abs(edgeHorz3)+edgeHorz4;float edgeVert=abs(edgeVert3)+edgeVert4;float subpixNWSWNESE=lumaNWSW+lumaNESE;float lengthSign=fxaaQualityRcpFrame.x;bool horzSpan=edgeHorz>=edgeVert;float subpixA=subpixNSWE*2.0+subpixNWSWNESE;if(!horzSpan)lumaN=lumaW;if(!horzSpan)lumaS=lumaE;if(horzSpan)lengthSign=fxaaQualityRcpFrame.y;float subpixB=(subpixA*(1.0/12.0))-lumaM;float gradientN=lumaN-lumaM;float gradientS=lumaS-lumaM;float lumaNN=lumaN+lumaM;float lumaSS=lumaS+lumaM;bool pairN=abs(gradientN)>=abs(gradientS);float gradient=max(abs(gradientN),abs(gradientS));if(pairN)lengthSign=-lengthSign;float subpixC=clamp(abs(subpixB)*subpixRcpRange,0.0,1.0);vec2 posB;posB.x=posM.x;posB.y=posM.y;vec2 offNP;offNP.x=(!horzSpan)? 0.0 : fxaaQualityRcpFrame.x;offNP.y=(horzSpan)? 0.0 : fxaaQualityRcpFrame.y;if(!horzSpan)posB.x+=lengthSign*0.5;if(horzSpan)posB.y+=lengthSign*0.5;vec2 posN;posN.x=posB.x-offNP.x;posN.y=posB.y-offNP.y;vec2 posP;posP.x=posB.x+offNP.x;posP.y=posB.y+offNP.y;float subpixD=((-2.0)*subpixC)+3.0;float lumaEndN=texTop(tex,posN).y;float subpixE=subpixC*subpixC;float lumaEndP=texTop(tex,posP).y;if(!pairN)lumaNN=lumaSS;float gradientScaled=gradient*1.0/4.0;float lumaMM=lumaM-lumaNN*0.5;float subpixF=subpixD*subpixE;bool lumaMLTZero=lumaMM<0.0;lumaEndN-=lumaNN*0.5;lumaEndP-=lumaNN*0.5;bool doneN=abs(lumaEndN)>=gradientScaled;bool doneP=abs(lumaEndP)>=gradientScaled;if(!doneN)posN.x-=offNP.x*1.5;if(!doneN)posN.y-=offNP.y*1.5;bool doneNP=(!doneN)||(!doneP);if(!doneP)posP.x+=offNP.x*1.5;if(!doneP)posP.y+=offNP.y*1.5;if(doneNP){if(!doneN)lumaEndN=texTop(tex,posN.xy).y;if(!doneP)lumaEndP=texTop(tex,posP.xy).y;if(!doneN)lumaEndN=lumaEndN-lumaNN*0.5;if(!doneP)lumaEndP=lumaEndP-lumaNN*0.5;doneN=abs(lumaEndN)>=gradientScaled;doneP=abs(lumaEndP)>=gradientScaled;if(!doneN)posN.x-=offNP.x*2.0;if(!doneN)posN.y-=offNP.y*2.0;doneNP=(!doneN)||(!doneP);if(!doneP)posP.x+=offNP.x*2.0;if(!doneP)posP.y+=offNP.y*2.0;if(doneNP){if(!doneN)lumaEndN=texTop(tex,posN.xy).y;if(!doneP)lumaEndP=texTop(tex,posP.xy).y;if(!doneN)lumaEndN=lumaEndN-lumaNN*0.5;if(!doneP)lumaEndP=lumaEndP-lumaNN*0.5;doneN=abs(lumaEndN)>=gradientScaled;doneP=abs(lumaEndP)>=gradientScaled;if(!doneN)posN.x-=offNP.x*4.0;if(!doneN)posN.y-=offNP.y*4.0;doneNP=(!doneN)||(!doneP);if(!doneP)posP.x+=offNP.x*4.0;if(!doneP)posP.y+=offNP.y*4.0;if(doneNP){if(!doneN)lumaEndN=texTop(tex,posN.xy).y;if(!doneP)lumaEndP=texTop(tex,posP.xy).y;if(!doneN)lumaEndN=lumaEndN-lumaNN*0.5;if(!doneP)lumaEndP=lumaEndP-lumaNN*0.5;doneN=abs(lumaEndN)>=gradientScaled;doneP=abs(lumaEndP)>=gradientScaled;if(!doneN)posN.x-=offNP.x*12.0;if(!doneN)posN.y-=offNP.y*12.0;doneNP=(!doneN)||(!doneP);if(!doneP)posP.x+=offNP.x*12.0;if(!doneP)posP.y+=offNP.y*12.0;}}}float dstN=posM.x-posN.x;float dstP=posP.x-posM.x;if(!horzSpan)dstN=posM.y-posN.y;if(!horzSpan)dstP=posP.y-posM.y;bool goodSpanN=(lumaEndN<0.0)!=lumaMLTZero;float spanLength=(dstP+dstN);bool goodSpanP=(lumaEndP<0.0)!=lumaMLTZero;float spanLengthRcp=1.0/spanLength;bool directionN=dstN<dstP;float dst=min(dstN,dstP);bool goodSpan=directionN ? goodSpanN : goodSpanP;float subpixG=subpixF*subpixF;float pixelOffset=(dst*(-spanLengthRcp))+0.5;float subpixH=subpixG*fxaaQualitySubpix;float pixelOffsetGood=goodSpan ? pixelOffset : 0.0;float pixelOffsetSubpix=max(pixelOffsetGood,subpixH);if(!horzSpan)posM.x+=pixelOffsetSubpix*lengthSign;if(horzSpan)posM.y+=pixelOffsetSubpix*lengthSign;return vec4(texTop(tex,posM).xyz,lumaM);}void main(){vec4 col=FxaaPixelShader(vUv,tOrig,1.0/resolution,0.5,0.2,0.0833);fragColor=col;}"
        },
        $X = {
            frag: "snippet version;uniform vec4 colStart;uniform vec4 colEnd;uniform vec2 offset;in vec2 vUv;out vec4 fragColor;void main(){fragColor=mix(colStart,colEnd,vUv.x);if(fragColor.a<0.01){discard;}fragColor.rgb*=fragColor.a;fragColor.a*=0.5;}",
            vert: "snippet version;in vec3 position;in vec2 uv;out vec2 vUv;uniform mat4 projectionViewMatrix;uniform vec2 offset;void main(){vUv=vec2(uv.x-min(uv.x/offset.y,1.0)*offset.x,uv.y);gl_Position=projectionViewMatrix*vec4(position,1.0);}"
        },
        $J = {
            frag: "snippet version;uniform vec4 colStart;uniform vec4 colEnd;uniform vec2 offset;uniform sampler2D diffuse;in vec2 vUv;out vec4 fragColor;void main(){fragColor=texture(diffuse,vUv);fragColor*=mix(colStart,colEnd,vUv.x);if(fragColor.a<0.01){discard;}}"
        },
        $K = {
            frag: "snippet version;void main(){}",
            vert: "snippet version;in vec3 position;in vec2 uv;in mat4 worldMatrix;uniform mat4 projectionViewMatrix;out vec2 vUv;snippet transformShadowPos;void main(){vUv=uv;gl_Position=transformShadowPos(projectionViewMatrix*worldMatrix*vec4(position,1.0));}"
        },
        $Z = {
            frag: "snippet version;in vec2 vUv;uniform sampler2D diffuse;void main(){if(texture(diffuse,vUv).a<0.5)discard;}"
        },
        ht = {
            frag: "snippet version;uniform sampler2D texvals1;uniform sampler2D terrainDiffuse[8];in vec2 vUv;in vec2 vUvt;uniform int textureHeights;float height;float count;snippet terraininfo;void computeColor(vec4 color,float value,vec4 info){float brightness=(color.r+color.g+color.b)/3.0;height+=pow(smoothstep(info[1],info[2],brightness)*value,2.5);count+=value;}void main(){height=0.0;if(textureHeights==1){vec4 t1=texture(texvals1,vec2(0.5*vUv.x,vUv.y));vec4 t2=texture(texvals1,vec2(0.5+0.5*vUv.x,vUv.y));if(t1[0]>0.0)computeColor(texture(terrainDiffuse[0],vUvt*tinf0[0]),t1[0],tinf0);if(t1[1]>0.0)computeColor(texture(terrainDiffuse[1],vUvt*tinf1[0]),t1[1],tinf1);if(t1[2]>0.0)computeColor(texture(terrainDiffuse[2],vUvt*tinf2[0]),t1[2],tinf2);if(t1[3]>0.0)computeColor(texture(terrainDiffuse[3],vUvt*tinf3[0]),t1[3],tinf3);if(t2[0]>0.0)computeColor(texture(terrainDiffuse[4],vUvt*tinf4[0]),t2[0],tinf4);if(t2[1]>0.0)computeColor(texture(terrainDiffuse[5],vUvt*tinf5[0]),t2[1],tinf5);if(t2[2]>0.0)computeColor(texture(terrainDiffuse[6],vUvt*tinf6[0]),t2[2],tinf6);if(t2[3]>0.0)computeColor(texture(terrainDiffuse[7],vUvt*tinf7[0]),t2[3],tinf7);height/=count;}gl_FragDepth=gl_FragCoord.z-height*0.003;}",
            vert: "snippet version;in vec3 position;uniform mat4 modelMatrix;uniform mat4 projectionViewMatrix;out vec2 vUv;out vec2 vUvt;out vec4 vColor1;out vec4 vColor2;out vec3 vMouse;snippet transformShadowPos;void main(){vec4 worldpos=modelMatrix*vec4(position,1.0);vUv=vec2(position[0]+0.5,66.0-position[2]-0.5)/66.0;vUvt=vec2(worldpos[0],worldpos[2])/4.0;gl_Position=transformShadowPos(projectionViewMatrix*worldpos);}"
        },
        he = {
            frag: "snippet version;uniform vec4 color;out vec4 fragColor;void main(){fragColor=color;}",
            vert: "snippet version;in vec3 position;in vec2 uv;in vec3 normal;out vec2 vUv;out vec3 vNormal;out vec3 vPos;uniform mat4 modelMatrix;uniform mat4 projectionViewMatrix;void main(){vUv=uv;vNormal=normal;vPos=position;gl_Position=projectionViewMatrix*modelMatrix*vec4(position,1.0);}"
        },
        hi = {
            frag: "snippet version;snippet uniformsEnvironment;uniform float daycycle;uniform sampler2D skyDiffuse;in vec2 vUv;in vec3 vPos;out vec4 fragColor;void main(){gl_FragDepth=0.999999;vec3 result=vec3(0.0);float sunAngle=dot(directionalDir,normalize(vPos));float sunPower=pow((1.0+sunAngle)*0.5,3.0);vec3 topCol=skyColor;vec3 horizon=fogColor;float c=pow(max(0.0,min(1.0,(1.0-(0.5+vPos.y))*2.0)),3.0);float dirVal=0.0;if(c<0.85){dirVal=smoothstep(0.85-sunPower*0.8,0.85,c);}else{dirVal=1.0-smoothstep(0.85,1.0,c);}c=pow(c,(1.0-sunPower)*3.0);horizon+=directionalColor*dirVal*0.4*sunPower;topCol=mix(skyColor*0.8,topCol,sunPower);result=mix(topCol,horizon,c);float nightAmount=1.0-sin(daycycle*6.28)+0.02;float starFade=max(0.0,min(1.0,vPos.y*5.0))*0.4;result+=texture(skyDiffuse,vec2(directionalDir.x*0.5-vUv.x,vUv.y)).rgb*nightAmount*starFade;fragColor=vec4(result,1.0);}"
        },
        hs = {
            frag: "snippet version;in vec2 vUv;uniform float seed;float stars(in vec2 uv,float scale){uv*=scale;vec2 s=floor(uv),f=fract(uv),p;float k=3.,d;p=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;d=length(p);k=min(d,k);return smoothstep(0.,k,sin(f.x+f.y)*0.003);}snippet noiseHash;snippet noise2d;out vec4 fragColor;void main(){vec2 pos=vec2(vUv.x+seed,vUv.y);float n=stars(vUv,10.0);n+=stars(vUv,20.0)*0.5;n+=stars(vUv,30.0)*0.2;n*=noise(vUv*20.0);vec2 galaxyP=vec2(vUv.x*3.0+5.0,vUv.y*5.0);float galaxy=noise(galaxyP)*0.9;galaxy+=noise(galaxyP*1.5)*0.5;galaxy+=noise(galaxyP*2.9)*0.25;galaxy*=noise(galaxyP*0.3)*0.1;galaxy*=1.0-distance(vec2(0.5),vUv)*2.0;fragColor.rgb+=n*4.0+galaxy*2.5;}"
        },
        hn = {
            frag: "snippet version;snippet uniformsEnvironment;uniform float daycycle;in vec2 vUv;out vec4 fragColor;void main(){gl_FragDepth=0.999998;float height=max(0.0,min(1.0,abs(sin(daycycle*6.282))+vUv.y*0.1-0.15));float interp=min(1.0,pow((1.0-height*height),100.0));float circle=0.5-length(vec2(0.5,0.5)-vUv);float alpha=smoothstep(0.0,1.0,circle)*2.0;alpha+=smoothstep(0.4,0.45,circle);fragColor.rgba=vec4(mix(vec3(1.0),fogColor,interp),alpha);}"
        },
        ha = {
            frag: "snippet version;precision highp sampler2DShadow;in vec3 vNormal;in vec3 vViewDir;uniform vec4 mouse;uniform vec4 circleInfo;snippet uniformsEnvironment;snippet shadowsEnabled;snippet terraininfo;in vec3 vLight;in vec2 vUv;in vec2 vUvt;uniform sampler2D texvals1;uniform sampler2D terrainDiffuse[8];vec4 result;float detail;uniform sampler2DShadow shadow;in vec3 vShadowCoord;void computeColor(vec4 color,float value,vec4 info){float brightness=max(max(color.x,color.y),color.z);color.a=pow(smoothstep(info[1],info[2],brightness)*value,2.5);detail+=info[3]*color.a;color.rgb=color.rgb*min(1.0,value*0.5+0.7)*color.a;result+=color;}out vec4 fragColor;void main(){snippet discardInFog;vec4 t1=texture(texvals1,vec2(0.5*vUv.x,vUv.y));vec4 t2=texture(texvals1,vec2(0.5+0.5*vUv.x,vUv.y));if(t1[0]>0.1)computeColor(texture(terrainDiffuse[0],vUvt*tinf0[0]),t1[0],tinf0);if(t1[1]>0.1)computeColor(texture(terrainDiffuse[1],vUvt*tinf1[0]),t1[1],tinf1);if(t1[2]>0.1)computeColor(texture(terrainDiffuse[2],vUvt*tinf2[0]),t1[2],tinf2);if(t1[3]>0.1)computeColor(texture(terrainDiffuse[3],vUvt*tinf3[0]),t1[3],tinf3);if(t2[0]>0.1)computeColor(texture(terrainDiffuse[4],vUvt*tinf4[0]),t2[0],tinf4);if(t2[1]>0.1)computeColor(texture(terrainDiffuse[5],vUvt*tinf5[0]),t2[1],tinf5);if(t2[2]>0.1)computeColor(texture(terrainDiffuse[6],vUvt*tinf6[0]),t2[2],tinf6);if(t2[3]>0.1)computeColor(texture(terrainDiffuse[7],vUvt*tinf7[0]),t2[3],tinf7);result.rgb/=result.a*0.85;detail/=result.a;result.a=1.0;float lambertian=max(0.0,dot(vNormal,directionalDir));float specularCoefficient=0.0;if(lambertian>0.0){if(shadowsEnabled==1&&vShadowCoord.x>0.0&&vShadowCoord.x<1.0&&vShadowCoord.y>0.0&&vShadowCoord.y<1.0){float shadowValue=texture(shadow,vShadowCoord);snippet shadowFogMax;lambertian=min(clamp(lambertian,0.0,1.0),max(shadowValue,shadowFogMax));}vec3 reflectDir=reflect(-directionalDir,vNormal);float specAngle=max(dot(reflectDir,vViewDir),0.0);specularCoefficient=pow(specAngle,8.5)*2.0;}float detailBrightness=length(result.rgb)*3.0*detail;float lights=pow((detailBrightness-0.5),3.0)*0.7+0.25;float spec=pow((detailBrightness-0.5)*lambertian,3.0)*1.2;if(detailBrightness>1.2){spec*=1.3;lights*=1.3;}specularCoefficient*=spec;vec3 directionalLightColor=result.rgb*directionalColor*lambertian*0.75;vec3 ambientLightColor=result.rgb*ambientColor;result.rgb=ambientLightColor+directionalLightColor+vec3(specularCoefficient)*0.15+vLight*lights;float circle=distance(vWorldPos.xz,mouse.xz);float vertical=min(1.0,max(0.0,4.0-abs(vWorldPos.y-mouse.y)));if(circle<mouse.w+0.1&&vertical>0.0){result.rgb=mix(result.rgb,circleInfo.rgb,vertical*circleInfo.a*((circle<mouse.w ? circle/mouse.w*0.5 : 0.0)+max(0.,(0.1-abs(mouse.w-circle))/0.1)));}snippet applyFog;fragColor=result;}",
            vert: "snippet version;snippet uniformsEnvironment;snippet uniformsPointlights;snippet transformShadowPos;snippet shadowsEnabled;in vec3 position;in vec3 normal;uniform mat4 modelMatrix;uniform mat4 projectionViewMatrix;uniform mat4 shadowPVMatrix;out vec3 vCamNormal;out vec3 vNormal;out vec2 vUv;out vec2 vUvt;out vec4 vShadowPos;out vec3 vShadowCoord;out vec3 vViewDir;void main(){vNormal=normal;vWorldPos=modelMatrix*vec4(position,1.0);vUv=vec2(position[0]+0.5,66.0-position[2]-0.5)/66.0;vUvt=vec2(vWorldPos[0],vWorldPos[2])/4.0;vec3 light=vec3(0.0);for(int i=0;i<lightCount;++i){vec3 lightDir=lightPos[i]-vWorldPos.xyz;float strenght=lightCols[i].w-dot(lightDir,lightDir);if(strenght>0.0){strenght/=(lightCols[i].w);strenght=strenght*strenght;light+=0.25*lightCols[i].rgb*strenght;}}vLight=light;snippet calculateCameraDistance;vViewDir=-normalize(vWorldPos.xyz-cameraPosition);if(shadowsEnabled==1){vec4 shadowPos=transformShadowPos(shadowPVMatrix*(vWorldPos));vShadowCoord=(shadowPos.xyz/shadowPos.w)*0.5+0.5;}gl_Position=projectionViewMatrix*vWorldPos;}"
        },
        hr = {
            frag: "snippet version;snippet uniformsEnvironment;snippet shadowsEnabled;uniform float time;uniform mat4 waterPVMatrix;uniform float visibility;uniform float speed;uniform vec3 colFoam;uniform vec3 colShallow;uniform vec3 colDeep;uniform sampler2D waterDepth;uniform sampler2D waterDiffuse;uniform sampler2D waterDiffuse2;in vec2 vUv;out vec4 fragColor;snippet transformShadowPos;float getWaterDepth(vec2 pos,float z){return texture(waterDepth,pos).r-z;}void main(){float vCameraDistance=length(cameraPosition-vWorldPos.xyz);snippet discardInFog;ivec2 wSize=textureSize(waterDepth,0);float wTexel=1.0/float(wSize.x);vec4 waterPos=transformShadowPos(waterPVMatrix*vWorldPos);vec3 vWaterCoord=(waterPos.xyz/waterPos.w)*0.5+0.5;float depth=1.0;if(shadowsEnabled==1){if(vWaterCoord.x>0.0&&vWaterCoord.x<1.0&&vWaterCoord.y>0.0&&vWaterCoord.y<1.0){float waterlevel=vWaterCoord.z;float ht=wTexel*0.5;float wul=getWaterDepth(vWaterCoord.xy+vec2(-ht,-ht),vWaterCoord.z);float wur=getWaterDepth(vWaterCoord.xy+vec2(ht,-ht),vWaterCoord.z);float wll=getWaterDepth(vWaterCoord.xy+vec2(-ht,ht),vWaterCoord.z);float wlr=getWaterDepth(vWaterCoord.xy+vec2(ht,ht),vWaterCoord.z);float shiftx=mod(vWaterCoord.x-ht,wTexel)/wTexel;float shifty=mod(vWaterCoord.y-ht,wTexel)/wTexel;depth=mix(mix(wul,wur,shiftx),mix(wll,wlr,shiftx),shifty);}else{depth=1.0;}depth*=50.0;}float speed=speed*0.01;float wave=0.0;vec2 dir=vec2(1.0,0.0);float wiggle=1.0;for(int i=0;i<2;++i){float off=1.0/3.0*float(i);float t=mod(time*0.2+off,1.0)*3.141;float sppd=speed+0.2;vec2 shift=vec2(sppd*dir.y*t+off,sppd*dir.x*t+off);float curve=abs(sin(t));wave+=texture(waterDiffuse,vUv.yx*0.5+shift).r*curve;wiggle+=((sin((vUv.x+shift.y)*10.0)+cos((vUv.y+shift.x)*10.0))*curve*(0.2+sppd*0.6));}float vis=visibility/100.0;vec4 bigwave=texture(waterDiffuse2,vUv.yx+time*speed*2.0+wave*0.1);vec4 wet_c=vec4(colFoam,0.0);vec4 foam_c=vec4(colFoam,0.9);vec4 blub_c=vec4(mix(colFoam,colShallow,0.9)*0.8,0.5)+speed*0.1;vec4 shallow_c=vec4(colShallow,0.4)+bigwave*0.05;vec4 water_c=vec4(mix(colShallow,colDeep,0.5),0.8-vis*0.4)+bigwave*0.08;vec4 deep_c=vec4(colDeep,1.4-vis*0.8)+bigwave*0.12;float wet_r=0.03+0.01*wave;float foam_r=wet_r+0.02+speed*0.05+0.03*wave+wiggle*0.02;float blub_r=foam_r+(0.05+speed*0.5*wave+wiggle*0.05)*vis;float shallow_r=blub_r+(0.2+speed*0.2-wave*0.1)*vis;float water_r=shallow_r+(0.2)*vis;vec4 result=vec4(0.0);if(depth<wet_r){result=mix(wet_c,foam_c,smoothstep(0.0,wet_r,depth));}else if(depth<foam_r){result=mix(foam_c,blub_c,smoothstep(wet_r,foam_r,depth));}else if(depth<blub_r){result=mix(blub_c,shallow_c,smoothstep(foam_r+(blub_r-foam_r)*0.3,blub_r,depth));}else if(depth<shallow_r){result=mix(shallow_c,water_c,smoothstep(blub_r+(shallow_r-blub_r)*0.4,shallow_r,depth));}else{result=mix(water_c,deep_c,smoothstep(water_r,1.0,depth));}result.rgb-=0.2;float lambertian=max(dot(directionalDir,vec3(0.0,1.0,0.0)),0.0);float specular=0.0;vec3 reflectDir=reflect(-directionalDir,vec3(0.0,1.0,0.0));vec3 viewDir=-normalize(vWorldPos.xyz-cameraPosition);float specAngle=max(dot(reflectDir,viewDir),0.0);specular=min(1.0,max(0.0,pow(specAngle,10.0)))*0.6;result.rgb=result.rgb*directionalColor*lambertian+result.rgb*ambientColor+specular*directionalColor;snippet applyFog;fragColor=result;}",
            vert: "snippet version;snippet uniformsEnvironment;uniform mat4 modelMatrix;uniform mat4 projectionViewMatrix;uniform float time;uniform int watertype;uniform float speed;in vec3 position;in vec2 uv;out vec2 vUv;out vec3 vViewPos;void main(){vec4 pos=vec4(position,1.0);pos.y-=(1.0+sin(time))*0.1;vWorldPos=modelMatrix*pos;vUv=vWorldPos.xz/2.0;gl_Position=projectionViewMatrix*vWorldPos;}"
        },
        hl = Object.freeze({
            __proto__: null,
            clouds: $N,
            cloudsTex: $I,
            drop: $U,
            foliage: $z,
            multimeshEffect: $O,
            multimeshFlat: $L,
            multimeshSimple: $B,
            multimeshTextured: $q,
            multimeshTileable: $V,
            multimeshTree: $W,
            particles: $H,
            particles_additive: $j,
            particles_normal: $G,
            bloom: $Y,
            post: $Q,
            ribbon: $X,
            ribbonTextured: $J,
            rocks: {
                frag: "snippet version;snippet uniformsEnvironment;uniform sampler2D rocksDiffuse;out vec4 fragColor;in vec3 vNormal;in vec3 vCol;in vec2 vUv;void main(){snippet discardInFog;vec4 result=vec4(mix(vCol,texture(rocksDiffuse,vUv).rgb,0.3),1.0);float lambertian=max(dot(vNormal,directionalDir),0.0);result.rgb=result.rgb*directionalColor*lambertian+result.rgb*ambientColor;snippet applyFog;fragColor=result;}",
                vert: "snippet version;precision highp sampler2DShadow;snippet uniformsEnvironment;snippet uniformsPointlights;snippet shadowsEnabled;uniform mat4 projectionViewMatrix;uniform mat4 shadowPVMatrix;uniform sampler2DShadow shadow;in vec4 posOffset;in vec3 info1;in vec3 info2;in vec3 position;in vec3 normal;out vec3 vNormal;out vec3 vCol;out vec2 vUv;void main(){vec4 vWorldPos=vec4(position*posOffset.w+posOffset.xyz,1.0);vNormal=normal;vCol=mix(info1,info2,smoothstep(0.0,1.0,position.y));vUv=position.xz/10.0;snippet calculateCameraDistance;gl_Position=projectionViewMatrix*vWorldPos;}"
            },
            shadowInstanced: $K,
            shadowInstancedAlpha: $Z,
            shadowTerrain: ht,
            simple: he,
            simpleShaded: {
                frag: "snippet version;precision highp sampler2DShadow;snippet uniformsEnvironment;snippet shadowsEnabled;uniform sampler2DShadow shadow;uniform int shadowActive;uniform vec4 color;in vec3 vNormal;in vec3 vShadowCoord;out vec4 fragColor;void main(){snippet discardInFog;vec4 result=color;float facing=(float(gl_FrontFacing)*2.0-1.0);float lambertian=max(dot(vNormal*facing,directionalDir),0.0);if(shadowsEnabled==1&&shadowActive==1&&lambertian>0.0&&vShadowCoord.x>0.0&&vShadowCoord.x<1.0&&vShadowCoord.z>0.0&&vShadowCoord.z<1.0){float shadowValue=texture(shadow,vShadowCoord+vec3(0.0,0.0,-0.001*facing));lambertian*=shadowValue;}result.rgb=result.rgb*directionalColor*lambertian+result.rgb*ambientColor;snippet applyFog;fragColor=result;}",
                vert: "snippet version;in vec3 position;in vec3 normal;snippet uniformsEnvironment;snippet shadowsEnabled;out vec3 vNormal;out vec2 vUv;out vec3 vShadowCoord;snippet transformShadowPos;uniform mat4 modelMatrix;uniform mat4 projectionViewMatrix;uniform mat4 shadowPVMatrix;void main(){vNormal=normal;vec4 vWorldPos=modelMatrix*vec4(position,1.0);snippet calculateCameraDistance;if(shadowsEnabled==1){vec4 vShadowPos=transformShadowPos(shadowPVMatrix*vWorldPos);vShadowCoord=(vShadowPos.xyz/vShadowPos.w)*0.5+0.5;}gl_Position=projectionViewMatrix*vWorldPos;}"
            },
            simpleTextured: {
                frag: "snippet version;uniform sampler2D diffuse;in vec2 vUv;out vec4 fragColor;void main(){vec4 col=texture(diffuse,vUv);vec3 light=normalize(vec3(1.0,1.0,0.3));fragColor=col;if(fragColor.a<0.2)discard;}",
                vert: "snippet version;in vec2 uv;in vec3 position;in vec3 normal;uniform mat4 modelMatrix;uniform mat4 projectionViewMatrix;out vec2 vUv;out vec3 vNormal;void main(){vUv=uv;gl_Position=projectionViewMatrix*modelMatrix*vec4(position,1.0);}"
            },
            sky: hi,
            skyStarTex: hs,
            sun: hn,
            terrain: ha,
            terrainDebug: {
                frag: "snippet version;in vec3 vPos;out vec4 fragColor;void main(){if(abs(vPos.x-0.0)<0.001||abs(vPos.x-64.0)<0.001||abs(vPos.z-0.0)<0.001||abs(vPos.z-64.0)<0.001)fragColor.rg=vec2(1.0,1.0);}",
                vert: "snippet version;in vec3 position;in vec3 normal;uniform mat4 modelMatrix;uniform mat4 projectionViewMatrix;uniform vec4 mouse;out vec3 vPos;void main(){vPos=position;gl_Position=projectionViewMatrix*modelMatrix*vec4(position[0],position[1]+0.1,position[2],1.0);}"
            },
            water: hr
        }),
        ho = {
            version: "#version 300 es\n    precision highp float;\n    precision highp int;\n  ",
            uniformsEnvironment: "\n    uniform vec3 ambientColor;\n    uniform vec3 directionalDir;\n    uniform vec3 directionalColor;\n    uniform vec3 skyColor;\n    uniform vec3 fogColor;\n    uniform float fogNear;\n    uniform float fogFar;\n    uniform vec3 cameraPosition;\n    out float vCameraDistance; // V\n    out vec4 vWorldPos; // V\n    in float vCameraDistance; // F\n    in vec4 vWorldPos; // F\n  ",
            shadowsEnabled: `
    const int shadowsEnabled = ${sO.shadows?1:0};
  `,
            uniformsPointlights: "\n    uniform vec4 lightCols[16];\n    uniform vec3 lightPos[16];\n    uniform int lightCount;\n    out vec3 vLight;\n  ",
            calculatePointlights: "\n    vec3 light = vec3(0.0);\n    for(int i = 0; i < lightCount; ++i){\n      vec3 lightDir = lightPos[i] - vWorldPos.xyz;\n      float strenght = lightCols[i].w-dot(lightDir,lightDir);\n      if(strenght > 0.0){\n        strenght /= (lightCols[i].w);\n        strenght = strenght*strenght;\n        light += max(0.0,dot(normalize(lightDir), vNormal)) * lightCols[i].rgb*strenght;\n      } \n    }\n    vLight = light;\n  ",
            calculateCameraDistance: "\n    vCameraDistance = length(cameraPosition - vWorldPos.xyz);\n  ",
            discardInFog: sO.fogpattern ? "\n    if(vCameraDistance > fogFar*0.9){\n      if(fract(sin(gl_FragCoord.x*556.78+gl_FragCoord.y*7123.4)) < smoothstep(fogFar*0.9,fogFar, vCameraDistance)) discard;\n    } " : "",
            shadowFogMax: "\n    float shadowFogMax = smoothstep(fogNear*1.5, fogFar*0.75, vCameraDistance);\n  ",
            applyFog: "\n    result.rgb = mix(result.rgb, fogColor, smoothstep(fogNear, fogFar, vCameraDistance));",
            transformShadowPos: "\n    vec4 transformShadowPos(vec4 pos){\n      pos.x = 2.0 / (1.0+exp(-10.0*pos.x)) - 1.0;\n      pos.y = 2.0 / (1.0+exp(-10.0*pos.y)) - 1.0;\n      return pos;\n    }",
            noiseHash: "\n    vec2 hash( vec2 p ) {\n    p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n  }",
            noise2d: "float noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    vec2 i = floor(p + (p.x+p.y)*K1); \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    vec3 n =h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    float d = dot(n, vec3(70.0));\n    return smoothstep(-1.0,1.0,d);\n  }",
            terraininfo: Array(8).fill(0).map((t, e) => `uniform vec4 tinf${e};`).join("")
        },
        hc = (t, e) => t.replace(/snippet (\w+);/g, (t, i) => {
            let s = ho[i].split("\n");
            return (s = s.filter(t => !(0 == e && t.indexOf("// F") > -1) && !(1 == e && t.indexOf("// V") > -1))).join("\n")
        }),
        hd = t => {
            for (let e in t) t[e].vert && (t[e].vert = hc(t[e].vert, 0)), t[e].frag && (t[e].frag = hc(t[e].frag, 1))
        },
        hu = {},
        h$ = [],
        hh = (t, e) => {
            uf(t)
        },
        hm = () => {
            if (ud(), hd(hl), sO.fxaa && ae.addPass({
                    fragment: $Q.frag,
                    globalUniforms: uc,
                    blitToOriginal: !0
                }), sO.bloom)
                for (let t = 0; t < 2; ++t) ae.addPass({
                    fragment: $Y.frag,
                    uniforms: {
                        step: {
                            value: t
                        }
                    },
                    globalUniforms: uc
                });
            hu.foliage = new n$(nK, {
                vertex: $z.vert,
                fragment: $z.frag,
                cullFace: null,
                active: !1,
                globalUniforms: uc,
                transparent: !0
            }), hu.multimeshFlat = new n$(nK, {
                vertex: $L.vert,
                fragment: $L.frag,
                instanced: [{
                    name: "color",
                    size: 4
                }],
                globalUniforms: uc
            }), hu.multimeshTextured = new n$(nK, {
                vertex: $q.vert,
                fragment: $q.frag,
                globalUniforms: uc
            }), hu.multimeshEffect = new n$(nK, {
                vertex: $O.vert,
                fragment: $O.frag,
                globalUniforms: uc,
                transparent: !0,
                depthWrite: !1,
                instanced: [{
                    name: "color",
                    size: 4
                }, {
                    name: "uvshift",
                    size: 4
                }, {
                    name: "ycutoff",
                    size: 2
                }]
            }), hu.multimeshTree = new n$(nK, {
                vertex: $q.vert,
                fragment: $W.frag,
                globalUniforms: uc
            }), hu.multimeshTileable = new n$(nK, {
                vertex: $V.vert,
                fragment: $q.frag,
                instanced: [{
                    name: "tile",
                    size: 4
                }],
                globalUniforms: uc
            }), hu.multimeshSimple = new n$(nK, {
                vertex: $B.vert,
                fragment: $B.frag,
                instanced: [{
                    name: "color",
                    size: 4
                }],
                globalUniforms: uc
            }), hu.drop = new n$(nK, {
                vertex: $U.vert,
                fragment: $U.frag,
                instanced: [{
                    name: "uvshift",
                    size: 4
                }, {
                    name: "shine",
                    size: 1
                }],
                globalUniforms: uc
            }), hu.terrain = new n$(nK, {
                active: !1,
                vertex: ha.vert,
                fragment: ha.frag,
                globalUniforms: uc,
                autoUniforms: ["texvals1"]
            }), hu.sun = new n$(nK, {
                vertex: he.vert,
                fragment: hn.frag,
                transparent: !0,
                globalUniforms: uc
            }), hu.clouds = new n$(nK, {
                vertex: he.vert,
                fragment: $N.frag,
                transparent: !0,
                frontFace: nK.CW,
                globalUniforms: uc
            }), hu.water = new n$(nK, {
                vertex: hr.vert,
                fragment: hr.frag,
                transparent: !0,
                active: !1,
                globalUniforms: uc
            }), hu.sky = new n$(nK, {
                vertex: he.vert,
                fragment: hi.frag,
                cullFace: null,
                depthTest: !0,
                globalUniforms: uc
            }), hu.shadowInstancedAlpha = new n$(nK, {
                cullFace: null,
                vertex: $K.vert,
                fragment: $Z.frag,
                autoUniforms: ["diffuse"],
                globalUniforms: uc
            }), hu.shadowInstanced = new n$(nK, {
                vertex: $K.vert,
                fragment: $K.frag,
                globalUniforms: uc
            }), hu.shadowTerrain = new n$(nK, {
                vertex: ht.vert,
                fragment: ht.frag,
                globalUniforms: uc,
                uniforms: {
                    textureHeights: {
                        value: 1
                    }
                },
                autoUniforms: ["texvals1"]
            }), hu.particles_additive = new n$(nK, {
                vertex: $H.vert,
                fragment: $j.frag,
                active: !1,
                transparent: !0,
                depthWrite: !1,
                globalUniforms: uc
            }), hu.particles_normal = new n$(nK, {
                vertex: $H.vert,
                fragment: $G.frag,
                active: !1,
                transparent: !1,
                depthWrite: !0,
                globalUniforms: uc
            }), hu.ribbon = new n$(nK, {
                vertex: $X.vert,
                fragment: $X.frag,
                transparent: !0,
                cullFace: null,
                depthWrite: !1,
                globalUniforms: uc
            }), hu.ribbonTextured = new n$(nK, {
                vertex: $X.vert,
                fragment: $J.frag,
                transparent: !0,
                cullFace: null,
                depthWrite: !1,
                globalUniforms: uc,
                autoUniforms: ["diffuse"]
            }), hu.ribbon.setBlendFunc(nK.ONE, nK.ONE_MINUS_SRC_ALPHA), hu.particles_additive.setBlendFunc(nK.ONE, nK.ONE_MINUS_SRC_ALPHA), hu.multimeshEffect.setBlendFunc(nK.ONE, nK.ONE_MINUS_SRC_ALPHA), h$.push(hu.multimeshFlat, hu.multimeshTextured, hu.multimeshTree, hu.multimeshTileable, hu.multimeshSimple, hu.drop, hu.multimeshEffect)
        },
        h_ = t => {
            hu.shadowTerrain.uniforms.textureHeights.value = 0
        },
        hf = t => {
            hu.shadowTerrain.uniforms.textureHeights.value = 1
        },
        hp = t => {
            uc.shadowPVMatrix.state++
        },
        hg = t => {
            uc.waterPVMatrix.state++
        },
        hv = [],
        hy = t => {
            ~hv.indexOf(t) ? console.log("tried adding but already present") : hv.push(t)
        },
        h0 = t => {
            let e = hv.indexOf(t);
            ~e ? hv.splice(e, 1) : console.log("tried removing but already remove")
        },
        hb, hx = () => {
            hb = new nU(void 0, hu.sky, nK.TRIANGLES, !1, 8e3), sH(hb.transform.scale, 40), hy(hb.transform), hb.transform.visible = !1, hb.transform.matrixAutoUpdate = !0, lg(1456, t => {
                let e = new nd(nK, t);
                hb.geometry = e;
                let i = l9(hs.frag, 1024, ai);
                hu.sky.uniforms.skyDiffuse.value = i, hu.sky.uniforms.skyDiffuse.state++, hb.transform.visible = !0
            })
        },
        hw = () => {
            hb.transform.position[0] = nZ.transform.worldMatrix[12], hb.transform.position[1] = .99 * nZ.transform.worldMatrix[13], hb.transform.position[2] = nZ.transform.worldMatrix[14]
        },
        h1, h9, h3 = () => {
            sO.clouds && lg(1456, t => {
                h9 = new nd(nK, t), (h1 = new nU(h9, hu.clouds, nK.TRIANGLES, !1, 5e3)).transform.position[1] = .1, sH(h1.transform.scale, .7), h1.transform.scale[1] *= .3, nC(h1.transform, hb.transform), h1.transform.matrixAutoUpdate = !0;
                let e = l9($I.frag, 1024, ai);
                hu.clouds.uniforms.cloudDiffuse.value = e, hu.clouds.uniforms.cloudDiffuse.state++
            })
        },
        hk = [],
        h2 = new Uint32Array(66);
    for (let h4 = 0, hC = 0; h4 < 66; h4 += 6, hC += 2) h2[h4 + 0] = hC, h2[h4 + 1] = hC + 1, h2[h4 + 2] = hC + 3, h2[h4 + 3] = hC, h2[h4 + 4] = hC + 3, h2[h4 + 5] = hC + 2;
    let hS = new Map,
        h7 = (t, e, i, s, n, a) => {
            let r = u.get(t),
                l = hS.get(r.steps),
                o;
            return (o = l && 0 !== l.length ? l.pop() : new hM(r)).reset(r, e, i, s, n, a), hk.push(o), o
        },
        hE = (t, e) => {
            for (let i = 0; i < hk.length; i++)
                if (hk[i].tick(t, e), hk[i].remove) {
                    let s = hk.splice(i--, 1)[0];
                    h6(s)
                }
        },
        h6 = t => {
            hS.has(t.maxSteps) || hS.set(t.maxSteps, []), hS.get(t.maxSteps).push(t), t.onCache()
        },
        hP = t => {
            hk.forEach(h6), hk.length = 0
        };
    class hM {
        constructor(t) {
            this.maxSteps = t.steps, this.stepTimer = new aH(0, 1), this.duration = new aH(0, 1), this.remove = !1, this.a = [0, 0, 0], this.b = [0, 0, 0], this.timeoutSteps = 0;
            let e = this.maxSteps + 1;
            this.uv = new Float32Array(4 * e), this.positions = new Float32Array(6 * e);
            for (let i = 0, s = 0; i < e; ++i, s += 4) this.uv[s] = i / this.maxSteps, this.uv[s + 2] = i / this.maxSteps, this.uv[s + 1] = 1, this.uv[s + 3] = 0;
            this.geometry = new nd(nK, {
                position: {
                    size: 3,
                    data: this.positions
                },
                uv: {
                    size: 2,
                    data: this.uv
                },
                index: {
                    type: nK.UNSIGNED_INT,
                    data: h2.subarray(0, 6 * this.maxSteps)
                }
            }), this.geometry.updateAttribute(this.geometry.attributes.uv), this.mesh = new nU(this.geometry, hu.ribbonTextured, nK.TRIANGLES, !1), this.mesh.uniformData.offset = [0, 0], this.waitingForTexture = !1, this.parent = null
        }
        reset(t, e, i, s, n, a) {
            this.stepTimer.reset(0, t.interval), this.duration.reset(a, n), this.currentStep = 0, this.a = sV(this.a, i), this.b = sV(this.b, s), this.mesh.uniformData.offset[1] = 1 / (this.maxSteps + 1), this.remove = !1, this.timeoutSteps = 0, this.geometry.drawRange.count = 0, this.mesh.uniformData.colStart = t.colStart, this.mesh.uniformData.colEnd = t.colEnd, t.texture > 0 ? (this.waitingForTexture = !0, this.mesh.program = hu.ribbonTextured, l1(t.texture, t => {
                this.mesh.uniformData.diffuse = t, this.waitingForTexture = !1
            })) : (this.waitingForTexture = !1, this.mesh.program = hu.ribbon, this.mesh.uniformData.diffuse = void 0), hy(this.mesh.transform), this.parent = e
        }
        tick(t, e) {
            if (this.waitingForTexture) return void(this.mesh.transform.visible = !1);
            if (this.duration.duration > 0 && this.duration.done(e)) return void(this.remove = !0);
            if (null !== this.parent) {
                if (this.mesh.transform.visible = this.parent.visible && (!this.parent.parent || this.parent.parent.visible), !this.mesh.transform.visible) return;
                this.mesh.transform.visible && 0 == this.timeoutSteps && (this.positions.set(ni(ar, this.a, this.parent.worldMatrix), 0), this.positions.set(ni(ar, this.b, this.parent.worldMatrix), 3))
            }
            this.stepTimer.done(e) && (this.stepTimer.reset(e), this.step()), this.geometry.updateAttribute(this.geometry.attributes.position);
            let i = this.stepTimer.fraction(e);
            this.mesh.uniformData.offset[0] = (1 - i) / this.maxSteps
        }
        detach() {
            this.timeoutSteps = Math.max(1, this.currentStep), this.parent = null
        }
        step() {
            this.currentStep = Math.min(this.maxSteps, this.currentStep + 1), this.positions.copyWithin(6, 0), this.geometry.drawRange.count = 6 * this.currentStep, this.timeoutSteps > 0 && (this.timeoutSteps--, 0 == this.timeoutSteps && (this.remove = !0))
        }
        onCache() {
            h0(this.mesh.transform), this.mesh.transform.visible = !1, this.parent = null
        }
    }
    let h5 = [],
        hD = 500,
        hT = [],
        hA = () => {
            hV();
            for (let t = 0; t < 1e3; ++t) h5.push({
                pos: [-0, -0, -0],
                vel: [-0, -0, -0],
                info: r.get(1),
                distance: 0,
                start: 0,
                end: 1.01,
                forced: !1,
                scaleRota: [0, 0, 0, 0],
                infoVec: [0, 0, 0, 0],
                progVec: [0, 0]
            })
        },
        h8 = (t, e, i, s) => {
            let n = e,
                a = i,
                r = !0,
                l = i;
            for (; e - i < 0;) r ? t[l].distance > t[e].distance ? (hR(t, l, e), l = e, i--, r = !r) : e++ : t[l].distance >= t[i].distance ? i-- : (hR(t, l, i), e++, l = i, r = !r);
            l - 1 > n && h8(t, n, l - 1), l + 1 < a && h8(t, l + 1, a)
        },
        hR = (t, e, i) => {
            let s = t[e];
            t[e] = t[i], t[i] = s
        },
        hF = (t, e, i, s) => {
            let n = Math.min(s, 50),
                a = [
                    [],
                    []
                ],
                r = 0,
                l = 0;
            for (; r < hT.length;) {
                let o = hT[r];
                if (o.start < 0 || o.end > t) {
                    if (hT[l] = o, l++, o.pos[0] > -1e3) {
                        let c = o.pos,
                            d = o.vel,
                            u = o.info.acc;
                        if (c[0] += (d[0] += u[0] * e) * e, c[1] += (d[1] += u[1] * e) * e, c[2] += (d[2] += u[2] * e) * e, o.info.friction > 0) {
                            let $ = 1 - o.info.friction;
                            d[0] *= $, d[1] *= $, d[2] *= $
                        }
                        if (o.distance = nt(i.frustum[5], c) + i.frustumConstants[5], o.distance < n && o.distance > 0) {
                            let h = o.start < 0 ? .5 * (Math.sin(t / o.info.duration) + 1) : (t - o.start) / o.info.duration;
                            o.progVec[0] = h, o.progVec[1] = aW[o.info.interp](h), a[o.info.blend].push(o)
                        }
                    }
                } else hD += o.forced ? 1 : 0, h5.push(o);
                ++r
            }
            return hT.length = l, h8(a[0], 0, a[0].length - 1, a[0].length), h8(a[1], 0, a[1].length - 1, a[1].length), a
        },
        hN = t => {
            for (let e = 0; e < 2; ++e) hU(t[e], hq[e]), hI(t[e], hq[e], hB[e])
        },
        hI = (t, e, i) => {
            t.length > 0 ? (i.transform.visible = !0, e.setDrawRange(0, t.length), e.updateAttribute(e.attributes.pos), e.updateAttribute(e.attributes.info), e.updateAttribute(e.attributes.progress), e.updateAttribute(e.attributes.scaleRota), e.updateAttribute(e.attributes.colStart), e.updateAttribute(e.attributes.colEnd)) : i.transform.visible = !1
        },
        hU = (t, e) => {
            let i = e.attributes.pos.data,
                s = e.attributes.progress.data,
                n = e.attributes.info.data,
                a = e.attributes.scaleRota.data,
                r = e.attributes.colStart.data,
                l = e.attributes.colEnd.data;
            for (let o = 0; o < t.length; ++o) {
                let c = t[o],
                    d = c.pos,
                    u = c.infoVec,
                    $ = c.progVec,
                    h = c.scaleRota,
                    m = c.info.colStart,
                    _ = c.info.colEnd,
                    f = 2 * o,
                    p = 3 * o,
                    g = 4 * o;
                i[p] = d[0], i[p + 1] = d[1], i[p + 2] = d[2], n[g] = u[0], n[g + 1] = u[1], n[g + 2] = u[2], n[g + 3] = u[3], s[f] = $[0], s[f + 1] = $[1], a[g] = h[0], a[g + 1] = h[1], a[g + 2] = h[2], a[g + 3] = h[3], r[g] = m[0], r[g + 1] = m[1], r[g + 2] = m[2], r[g + 3] = m[3], l[g] = _[0], l[g + 1] = _[1], l[g + 2] = _[2], l[g + 3] = _[3]
            }
        },
        hz = (t, e) => {
            let i = hF(af, t, nZ, e);
            hN(i)
        },
        hO = [0, 0, 0],
        hL = (t, e, i = 0, s = 0, n = 0, a = 0, l = 0, o = 0, c = !1) => {
            if (e ? ns(hO, i, s, n, e) : sW(hO, i, s, n), c) {
                if (hD <= 0) return
            } else {
                if (nt(nZ.frustum[0], hO) + nZ.frustumConstants[0] < 0 || nt(nZ.frustum[1], hO) + nZ.frustumConstants[1] < 0) return;
                let d = nt(nZ.frustum[5], hO) + nZ.frustumConstants[5];
                if (d < 0 || 10 * d > h5.length) return
            }
            let u = h5.pop();
            if (!u) {
                let $ = hT.length - 1;
                for (; $ >= 0 && hT[$].forced;) --$;
                $ >= 0 && (u = hT.splice($, 1)[0])
            }
            if (!u) return;
            let h = 1;
            if (e) {
                var m, _, f, p, g;
                let v = e[0],
                    y = e[1],
                    b = e[2];
                h = Math.sqrt(v * v + y * y + b * b), m = u.vel, _ = a, f = l, p = o, g = e, m[0] = g[0] * _ + g[4] * f + g[8] * p, m[1] = g[1] * _ + g[5] * f + g[9] * p, m[2] = g[2] * _ + g[6] * f + g[10] * p
            } else sW(u.vel, a, l, o);
            u.pos[0] = hO[0], u.pos[1] = hO[1], u.pos[2] = hO[2];
            let x = r.get(t);
            u.info = x, u.start = c ? -1 : af, u.end = u.start + u.info.duration;
            let w = Math.random() * x.randomRota,
                k = w + x.rota;
            return .5 > Math.random() && (w *= -1, k *= -1), n3(u.scaleRota, x.scaleStart * h, x.scaleEnd * h, w, k), n3(u.infoVec, x.idLoop, 0, x.idStart, x.idEnd + 1), nH(u.progVec, 0, 0), u.forced = c, hT.push(u), c && hD--, u
        },
        hB = [],
        hq = [],
        hV = () => {
            for (let t = 0; t < 2; ++t) hq[t] = new nd(nK, {
                pos: {
                    size: 3,
                    data: new Float32Array(3e3)
                },
                progress: {
                    size: 2,
                    data: new Float32Array(2e3)
                },
                info: {
                    size: 4,
                    data: new Float32Array(4e3)
                },
                scaleRota: {
                    size: 4,
                    data: new Float32Array(4e3)
                },
                colStart: {
                    size: 4,
                    data: new Float32Array(4e3)
                },
                colEnd: {
                    size: 4,
                    data: new Float32Array(4e3)
                }
            });
            hB[0] = new nU(hq[0], hu.particles_normal, nK.POINTS), hB[0].frustumCulled = !1, hy(hB[0].transform), l1(1741, t => {
                hu.particles_normal.uniforms.particleDiffuse.value = t, hu.particles_normal.uniforms.particleDiffuse.state++, hu.particles_normal.active = !0, hB[0].renderOrder = 9e3
            }), hB[1] = new nU(hq[1], hu.particles_additive, nK.POINTS), hB[1].frustumCulled = !1, hy(hB[1].transform), l1(1741, t => {
                hu.particles_additive.uniforms.particleDiffuse.value = t, hu.particles_additive.uniforms.particleDiffuse.state++, hu.particles_additive.active = !0, hB[1].renderOrder = 9e3
            })
        },
        hW = [],
        hH, hj, hG, hY = () => {
            hj = uc.lightCols, hH = uc.lightPos, hG = uc.lightCount
        },
        hQ = (t, e) => {
            let i = [0, 0, 0],
                s = [];
            for (let n = 0, a = hW.length; n < a; ++n) {
                let r = hW[n];
                r.remove ? (hW.splice(n, 1), --n, --a) : r.transform.visible && (sW(i, r.transform.worldMatrix[12], r.transform.worldMatrix[13], r.transform.worldMatrix[14]), r.distance = sK(nZ.worldPosition, i), r.distance < e && s.push(r))
            }
            s.sort((t, e) => t.distance - e.distance);
            let l = Math.min(s.length, 16);
            for (let o = 0; o < l; ++o) {
                let c = s[o],
                    d = 4 * o,
                    u = 3 * o;
                hH.value[u] = c.transform.worldMatrix[12], hH.value[u + 1] = c.transform.worldMatrix[13], hH.value[u + 2] = c.transform.worldMatrix[14], hj.value[d] = c.value[0], hj.value[d + 1] = c.value[1], hj.value[d + 2] = c.value[2], hj.value[d + 3] = c.value[3]
            }
            hH.state++, hj.state++, hG.value = l
        },
        hX = (t, e, i) => {
            let s = {
                transform: i,
                distance: 0,
                remove: !1,
                value: [...t, e]
            };
            return hW.push(s), s
        },
        hJ = t => {
            hW.length = 0
        },
        hK = new Map,
        hZ = (t, e, i, s, n) => {
            let a = t << 1 | e;
            if (a = (a = (a = a << 1 | i) << 1 | s) << 1 | n, hK.has(a)) return hK.get(a).create(); {
                let r = mt(t, e, i, s, n);
                return hK.set(a, r), r.create()
            }
        },
        mt = (t, e, i, s, n) => {
            let a = d.get(t),
                r = h$[a.shader],
                l = new nz(nK, r, nK.TRIANGLES, 0, null, sO.shadows && e ? s ? ue.shadow : ue.shadowStatic : void 0, sO.shadows && i ? ue.shadow : void 0, s, n);
            return l.cullFace = a.cull ? nK.BACK : nK.NONE, l.uniformData.shadowActive = sO.shadows && i ? 1 : 0, l.dynamicThrowShadows = sO.shadows && s && e || !1, hy(l.transform), lg(a.geometry, t => {
                l.shadowProgram = sO.shadows && e ? a.texture ? hu.shadowInstancedAlpha : hu.shadowInstanced : void 0, l.setAttributes(t), void 0 !== r.uniforms.diffuse ? l1(a.texture, t => {
                    t.setAnisotropy(2 ** sO.anisotropy), l.uniformData.diffuse = t, l.transform.visible = !0, l.renderOrder = (r.transparent ? 7e3 : 0) + (l.program.id + 1) * (t.id + 1) * (l.uniformData.shadowActive + 1)
                }) : (l.renderOrder = (r.transparent ? 7e3 : 0) + (l.program.id + 1) * (l.uniformData.shadowActive + 1), l.transform.visible = !0)
            }), l
        },
        me = () => {
            hK.forEach(t => {
                h0(t.transform)
            }), hK.clear()
        },
        mi = [{
            fun(t, e, i) {
                hL(e[0], t.transform.worldMatrix, e[1], e[2], e[3], e[4], e[5], e[6], !1)
            }
        }, {
            fun(t, e, i) {
                let s = e[1],
                    n = 2 * Math.PI / s;
                for (let a = 0; a < s; ++a) {
                    let r = Math.sin(a * n),
                        l = Math.cos(a * n);
                    hL(e[0], t.transform.worldMatrix, r * e[6] + e[2], e[3], l * e[6] + e[4], r * e[5], 0, l * e[5], !1)
                }
            }
        }, {
            fun(t, e, i) {
                for (let s = 0; s < e[1]; ++s) hL(e[0], t.transform.worldMatrix, e[2], e[3], e[4], l4(e[5], e[6]), l4(e[7], e[8]), l4(e[9], e[10]), !1)
            }
        }, {
            fun(t, e, i) {
                lz(e[0], t.transform, t.priority, !1, 1)
            }
        }],
        ms = [{
            create: (t, e) => hX([e[0], e[1], e[2]], e[3], t.transform),
            tick(t, e, i, s, n) {},
            end(t, e, i) {
                i.remove = !0
            },
            show(t, e, i) {},
            hide(t, e, i) {},
            modifiers: [(t, e, i, s, n) => {
                let a = aW[e[2]](n);
                i.value[3] = e[0] + a * (e[1] - e[0])
            }]
        }, {
            create: (t, e) => [0, 0, 0, 0],
            tick(t, e, i, s, n) {
                i[0] >= e[1] && (i[0] = 0, hL(e[0], t.transform.worldMatrix, l4(e[2], e[3]) + i[1], l4(e[4], e[5]) + i[2], l4(e[6], e[7]) + i[3], l4(e[8], e[9]), l4(e[10], e[11]), l4(e[12], e[13]), !1)), i[0] += ~~(1e3 * s)
            },
            end(t, e, i) {},
            show(t, e, i) {},
            hide(t, e, i) {},
            modifiers: [(t, e, i, s, n) => {
                let a = e[1] * n;
                i[1] = Math.sin(a) * e[0], i[3] = Math.cos(a) * e[0]
            }]
        }, {
            create: (t, e) => hD > 0 ? hL(e[0], t.transform.worldMatrix, 0, 0, 0, 0, 0, 0, !0) : void 0,
            tick(t, e, i, s, n) {},
            end(t, e, i) {
                i.start = 1, i.end = 1
            },
            show(t, e, i) {},
            hide(t, e, i) {
                i.pos[0] = -1e3
            },
            modifiers: [(t, e, i, s, n) => {
                let a = e[1] * n;
                ns(i.pos, Math.sin(a) * e[0], 0, Math.cos(a) * e[0], t.transform.worldMatrix)
            }, (t, e, i, s, n) => {
                ns(i.pos, e[0], e[1], e[2], t.transform.worldMatrix)
            }]
        }, {
            create: (t, e) => lz(e[0], t.transform, t.priority, !0, 1),
            tick(t, e, i, s, n) {},
            end(t, e, i) {
                i.stop()
            },
            show(t, e, i) {},
            hide(t, e, i) {},
            modifiers: []
        }, {
            create(t, e) {
                let i = hZ(e[0], !1, !1, !0, !0);
                return sW(i.position, e[1], e[2], e[3]), sW(i.scale, e[4], e[5], e[6]), sW(i.rotation, e[7], e[8], e[9]), nC(i, t.transform), nE(i, !1), i
            },
            tick(t, e, i, s, n) {},
            end(t, e, i) {
                i.data.multi.remove(i)
            },
            show(t, e, i) {
                i.visible = !0
            },
            hide(t, e, i) {
                i.visible = !1
            },
            modifiers: [(t, e, i, s, n) => {
                let a = e[1] * n;
                i.rotation[1] = e[2] + a, i.position[0] = Math.sin(a) * e[0], i.position[2] = Math.cos(a) * e[0], i.matrixNeedsUpdate = !0, nE(i, !1)
            }, (t, e, i, s, n) => {
                let a = i.data.multi.program.instancedAttributes[e[0]];
                for (let r = 0; r < a.size; ++r) i.data[a.name][r] = e[1 + r]
            }, (t, e, i, s, n) => {
                let a = i.data.multi.program.instancedAttributes[e[0]];
                for (let r = 0; r < a.size; ++r) {
                    let l = e[1 + r],
                        o = e[5 + r];
                    i.data[a.name][r] = l + n * (o - l)
                }
            }, (t, e, i, s, n) => {
                let a = aW[e[6]](n);
                i.scale[0] = e[0] + a * (e[3] - e[0]), i.scale[1] = e[1] + a * (e[4] - e[1]), i.scale[2] = e[2] + a * (e[5] - e[2]), i.matrixNeedsUpdate = !0
            }, (t, e, i, s, n) => {
                let a = aW[e[6]](n);
                i.rotation[0] = e[0] + a * (e[3] - e[0]), i.rotation[1] = e[1] + a * (e[4] - e[1]), i.rotation[2] = e[2] + a * (e[5] - e[2]), i.matrixNeedsUpdate = !0
            }]
        }, {
            create: (t, e) => h7(e[0], t.transform, [e[1], e[2], e[3]], [e[4], e[5], e[6]], 0, 0),
            tick(t, e, i, s, n) {},
            end(t, e, i) {
                i.detach()
            },
            show(t, e, i) {},
            hide(t, e, i) {},
            modifiers: [(t, e, i, s, n) => {
                let a = e[1] * n;
                i.b[0] = i.a[0] = Math.sin(a) * e[0], i.b[2] = i.a[2] = Math.cos(a) * e[0]
            }]
        }, {
            create(t, e) {
                if (hD < e[1]) return;
                let i = [];
                for (let s = 0; s < e[1]; ++s) i.push(hL(e[0], t.transform.worldMatrix, 0, 0, 0, 0, 0, 0, !0));
                return i
            },
            tick(t, e, i, s, n) {},
            end(t, e, i) {
                for (let s = 0; s < i.length; ++s) {
                    let n = i[s];
                    n.start = n.end = 1
                }
            },
            show(t, e, i) {},
            hide(t, e, i) {
                for (let s = 0; s < i.length; ++s) i[s].pos[0] = -1e3
            },
            modifiers: [(t, e, i, s, n) => {
                let a = i.length,
                    r = 6.283 / a,
                    l = e[0],
                    o = e[1] * n;
                for (let c = 0; c < a; ++c) {
                    let d = r * c + o;
                    ns(i[c].pos, Math.sin(d) * l, 0, Math.cos(d) * l, t.transform.worldMatrix)
                }
            }]
        }, {
            create: (t, e) => [0, 0],
            tick(t, e, i, s, n) {
                if (i[0] >= e[6]) {
                    i[0] = 0;
                    let a = e[1],
                        r = 2 * Math.PI / a;
                    for (let l = 0; l < a; ++l) hL(e[0], t.transform.worldMatrix, e[2], e[3], e[4], Math.sin(l * r + i[1]) * e[5], 0, Math.cos(l * r + i[1]) * e[5], !1)
                }
                i[0] += ~~(1e3 * s)
            },
            end(t, e, i) {},
            show(t, e, i) {},
            hide(t, e, i) {},
            modifiers: [(t, e, i, s, n) => {
                i[1] = e[0] * n
            }]
        }, {
            create: (t, e) => [0],
            tick(t, e, i, s, n) {
                if (i[0] >= e[1]) {
                    i[0] = 0;
                    let a = nT();
                    sW(a.rotation, l4(e[8], e[9]), l4(e[10], e[11]), l4(e[12], e[13])), mn(e[0], a, t.priority, !0), ns(a.position, l4(e[2], e[3]), l4(e[4], e[5]), l4(e[6], e[7]), t.transform.worldMatrix), n6(a)
                }
                i[0] += ~~(1e3 * s)
            },
            end(t, e, i) {},
            show(t, e, i) {},
            hide(t, e, i) {},
            modifiers: []
        }, {
            create(t, e) {
                let i = Math.sin(t.transform.rotation[1]) * Math.cos(t.transform.rotation[0]) * e[0],
                    s = -Math.sin(t.transform.rotation[0]) * e[0],
                    n = Math.cos(t.transform.rotation[1]) * Math.cos(t.transform.rotation[0]) * e[0],
                    a = t.info.duration,
                    r = a;
                if (e[1]) {
                    let l = as.raycastEnvironmentClosest(t.transform.position[0], t.transform.position[1], t.transform.position[2], i * a, s * a, n * a);
                    l < 1 && (r = a * l)
                }
                return [i, s, n, r]
            },
            tick(t, e, i, s, n) {
                e[1] && (i[3] -= s, i[3] <= 0) ? t.done = !0 : (t.transform.position[0] += i[0] * s, t.transform.position[1] += i[1] * s, t.transform.position[2] += i[2] * s, t.transform.matrixNeedsUpdate = !0, nE(t.transform, !1))
            },
            end(t, e, i) {},
            show(t, e, i) {},
            hide(t, e, i) {},
            modifiers: []
        }, {
            create: (t, e) => [],
            tick(t, e, i, s, n) {},
            end(t, e, i) {
                let s = nT();
                sV(s.position, t.transform.position), sV(s.rotation, t.transform.rotation), mn(e[0], s, t.priority, !0), n6(s)
            },
            show(t, e, i) {},
            hide(t, e, i) {},
            modifiers: []
        }],
        mn, ma = [],
        mr = [],
        ml = [],
        mo = [],
        mc = (t, e, i) => {
            mv(t, e), my(t);
            for (let s = 0; s < ma.length; ++s) {
                let n = ma[s],
                    a = n.visible !== n.transform.visible;
                if (n.visible = n.transform.visible, n.visible)
                    for (let r = 0; r < n.info.events.length; ++r) {
                        let l = n.info.events[r];
                        (0 === n.loops || l.fraction > 0) && n.fractionLast <= l.fraction && n.fractionNow > l.fraction && mi[l.id].fun(n, l.params, t)
                    }
                for (let o = 0; o < n.info.periods.length; ++o) {
                    let c = n.info.periods[o],
                        d = ms[c.id],
                        u = void 0 !== n.periodData[o],
                        $ = n.fractionNow >= c.fractionStart && n.fractionNow <= c.fractionEnd,
                        h = !1;
                    if (n.visible && $ && !u && n.fractionLast <= c.fractionStart && (h = u = void 0 !== (n.periodData[o] = d.create(n, c.params, t))), $ && u && (a && (n.visible ? d.show(n, c.params, n.periodData[o]) : d.hide(n, c.params, n.periodData[o])), n.visible)) {
                        let m = n.periodData[o],
                            _ = (n.fractionNow - c.fractionStart) / (c.fractionEnd - c.fractionStart);
                        d.tick(n, c.params, m, t, _);
                        for (let f = 0; f < c.modifiers.length; ++f) {
                            let p = c.modifiers[f];
                            (h || a || 1 === p.mode) && d.modifiers[p.id](n, p.params, m, t, _)
                        }
                    }!$ && u && (d.end(n, c.params, n.periodData[o]), n.periodData[o] = void 0)
                }
                n.visible && n.returnTransform && null === n.transform.parent && nE(n.transform, !1)
            }
            m0(), mb(), mx()
        },
        md = [],
        mu = (t, e, i, s) => md.length > 0 ? mh(md.pop(), t, e, i, s) : m$(t, e, i, s),
        m$ = (t, e, i, s) => ({
            info: t,
            priority: i,
            transform: e,
            returnTransform: s,
            visible: !0,
            fractionNow: 0,
            fractionLast: 0,
            timeEnd: 0,
            periodData: [],
            done: !1,
            loops: 0
        }),
        mh = (t, e, i, s, n) => (t.info = e, t.priority = s, t.transform = i, t.returnTransform = n, t),
        mm = t => (t.visible = !0, t.fractionNow = 0, t.fractionLast = 0, t.timeEnd = 0, t.periodData.length = 0, t.done = !1, t.loops = 0, t),
        m_ = t => {
            mw(t), t.returnTransform && nA(t.transform), md.push(mm(t))
        },
        mf = (t, e, i, s) => {
            let n = l.get(t),
                a = mu(n, e, i, s);
            return ma.push(a), mr.push(a), a
        },
        mp = (t, e, i, s) => {
            let n = l.get(t),
                a = mu(n, e, i, s);
            return ma.push(a), ml.push(a), a
        },
        mg = (t, e, i, s) => {
            let n = l.get(t),
                a = mu(n, e, i, s);
            return ma.push(a), mo.push(a), a
        },
        mv = (t, e, i) => {
            for (let s = 0; s < mr.length; ++s) {
                let n = mr[s];
                0 === n.timeEnd && (n.timeEnd = e + n.info.duration), n.fractionLast = n.fractionNow, n.fractionNow = 0 == n.info.duration ? 1 : aL(1 - (n.timeEnd - e) / n.info.duration, 0, 1)
            }
        },
        my = t => {
            for (let e = 0; e < ml.length; ++e) {
                let i = ml[e];
                i.fractionLast = i.fractionNow, i.fractionNow = (i.fractionNow + t / i.info.duration) % 1, i.fractionLast > i.fractionNow && (i.fractionLast = 0, i.loops++)
            }
        },
        m0 = (t, e, i) => {
            let s = mr.length;
            for (; s--;) {
                let n = mr[s];
                (1 === n.fractionNow || n.done) && (mr.splice(s, 1), ma.splice(ma.indexOf(n), 1), m_(n))
            }
        },
        mb = (t, e, i) => {
            let s = ml.length;
            for (; s--;) {
                let n = ml[s];
                n.done && (ml.splice(s, 1), ma.splice(ma.indexOf(n), 1), m_(n))
            }
        },
        mx = (t, e, i) => {
            let s = mo.length;
            for (; s--;) {
                let n = mo[s];
                n.done && (mo.splice(s, 1), ma.splice(ma.indexOf(n), 1), m_(n))
            }
        },
        mw = t => {
            for (let e = 0; e < t.info.periods.length; ++e) {
                let i = t.info.periods[e],
                    s = ms[i.id];
                void 0 !== t.periodData[e] && (s.end(t, i.params, t.periodData[e]), t.periodData[e] = void 0)
            }
        },
        m1 = t => {
            for (let e = 0; e < ma.length; ++e) m_(ma[e]);
            ma.length = 0, mr.length = 0, ml.length = 0, mo.length = 0
        };
    mn = a = mf;
    let m9 = [],
        m3, mk, m2 = {
            color: [0, 0, 0]
        },
        m4 = {
            color: [0, 0, 0]
        },
        mC = {
            color: [0, 0, 0],
            dir: [0, 0, 0]
        },
        mS = {
            near: 10,
            far: 100,
            color: [0, 0, 0]
        },
        m7 = () => {
            uc.fogNear.value = mS.near, uc.fogFar.value = mS.far, uc.fogColor.value = mS.color, uc.skyColor.value = m4.color, uc.ambientColor.value = m2.color, uc.directionalColor.value = mC.color, uc.directionalDir.value = mC.dir, sW(mC.dir, 1.5, 2.5, 0), sZ(mC.dir, mC.dir), uo(mC.dir)
        },
        mE, m6 = (t, e) => {
            mP(t), mM();
            let i = e + 10;
            mE != i && (uc.fogNear.value = 5, uc.fogFar.value = i, mE = i)
        },
        mP = t => {
            if (0 === m9.length) return;
            let e = (t / 600 + .9) % 1;
            e = e < .85 ? .5 * aq(0, .85, e) : .5 + .5 * aq(.85, 1, e), uc.daycycle.value = e;
            let i, s, n = .5;
            e < .05 ? (i = 1, s = 0, n = aq(0, .05, e)) : e < .4 ? (i = 0, s = 0) : e < .5 ? (i = 0, s = 1, n = aq(.4, .5, e)) : e < .6 ? (i = 1, s = 2, n = aq(.5, .6, e)) : e < .9 ? (i = 2, s = 2) : (i = 2, s = 1, n = aq(.9, 1, e)), ou(mC.color, m9[i].directional, m9[s].directional, n), ou(mS.color, m9[i].fog, m9[s].fog, n), ou(m2.color, m9[i].ambient, m9[s].ambient, n), ou(m4.color, m9[i].sky, m9[s].sky, n), nK.clearColor(mS.color[0], mS.color[1], mS.color[2], 1)
        };
    er.subscribe(t => {
        t && mD()
    });
    let mM = () => {
            if (!m3 || !mk) return;
            let t = uc.daycycle.value,
                e, i, s = .5;
            t < .1 ? (e = m3, i = mk, s = .5 * aq(0, .1, t) + .5) : t < .4 ? (e = m3, i = mk, s = -1) : t < .6 ? (e = mk, i = m3, s = aq(.4, .6, t)) : t < .9 ? (e = mk, i = m3, s = -1) : (e = m3, i = mk, s = .5 * aq(.9, 1, t)), s >= 0 ? (e.gain.gain.value = 1 - s, i.gain.gain.value = s) : (e.gain.gain.value = 0, i.gain.gain.value = 1)
        },
        m5 = (t, e) => {
            t.data.cols.forEach((t, e) => {
                m9[e] = {
                    fog: dA(t.fog),
                    directional: dA(t.directional),
                    ambient: dA(t.ambient),
                    sky: dA(t.sky)
                }
            }), mD()
        },
        mD = () => {
            mk && mk.stop(), m3 && m3.stop(), mk = lB(117, 2), m3 = lB(118, 2)
        },
        mT = 1,
        mA = t => {
            (mT = t % 2147483647) <= 0 && (mT += 2147483646)
        },
        m8 = () => mT = 16807 * mT % 2147483647,
        mR = () => (m8() - 1) / 2147483647,
        mF = t => {
            let e = Math.floor(t % 8);
            t /= 8;
            let i = Math.floor(t % 8);
            t /= 8;
            let s = Math.floor(t % 10);
            t /= 10;
            let n = Math.floor(t % 10);
            return {
                col3: e,
                col2: i,
                col1: s,
                val1: Math.floor(t /= 10),
                val2: n
            }
        },
        mN = 65536 / (2 * Math.PI),
        mI = (t, e, i) => (e.id = i.id, sW(e.pos, i.x / 1024, i.y / 1073741.8235, i.z / 1024), sW(e.rot, i.rx / mN, i.ry / mN, i.rz / mN), e.scale = Math.max(i.scale, 100) / 655.36, e),
        mU = Math.floor(70 * sO.foliage),
        mz = new Float32Array(4 * mU),
        mO = new Float32Array(2 * mU),
        mL = (t, e, i) => {
            let s = as.getChunkFromWorld(e, i);
            if (void 0 === s || e < 0 || i < 0 || e >= as.bounds || i >= as.bounds) return !0;
            let n = mF(s.data.color[e % 64 + i % 64 * 64]);
            return t.col1 !== n.col1
        },
        mB = (t, e) => {
            if (0 === sO.foliage || !e) return;
            mq(t, nK), mA(t.id + 1e3);
            let i = 0;
            for (let s = 0; s < mU; ++s) {
                let n = m8() % 64,
                    a = m8() % 64,
                    r = n + t.origin[0],
                    l = a + t.origin[2];
                if (as.getNormal(r, l)[1] < .8) continue;
                let o = mF(t.data.color[n + 64 * a]),
                    c = as.data.terrains[o.col1],
                    d = $.get(c),
                    u = mL(o, r + 2, l) || mL(o, r - 2, l) || mL(o, r, l + 2) || mL(o, r, l - 2);
                if (u || mR() > .8)
                    for (let h = 0; h < d.foliage.length; ++h) {
                        if (i >= mU) continue;
                        let m = d.foliage[h];
                        if (m8() % 255 > m[1]) continue;
                        let _ = n - .5 + mR(),
                            f = a - .5 + mR();
                        if (_ < 0 || _ >= 64 || f < 0 || f >= 64) continue;
                        let p = (.6 * mR() + .7) * (u ? .8 : .5),
                            g = t.getHeight(_, f) + .8 * p - .1;
                        _ += t.origin[0], f += t.origin[2], mz[4 * i] = _, mz[4 * i + 1] = g, mz[4 * i + 2] = f, mz[4 * i + 3] = p, mO[2 * i] = m[0], mO[2 * i + 1] = m8() % 2 ? -1 : 1, i++
                    }
            }
            let v = t.geometry.foliage;
            v.setDrawRange(0, i), v.updateAttribute(v.attributes.posOffset), v.updateAttribute(v.attributes.info), v.bounds = t.geometry.terrain.bounds
        },
        mq = (t, e) => {
            t.meshes.foliage || (t.geometry.foliage = new nd(e, {
                info: {
                    size: 2,
                    data: mO
                },
                posOffset: {
                    size: 4,
                    data: mz
                }
            }), t.meshes.foliage = new nU(t.geometry.foliage, hu.foliage, e.POINTS, !0, 2e3, null, void 0, ue.shadow), nC(t.meshes.foliage.transform, t.meshes.terrain.transform))
        },
        mV = (t, e) => {
            l1(t.data.foliage, t => {
                hu.foliage.active = !0, hu.foliage.uniforms.foliageDiffuse.value = t
            })
        },
        mW = [],
        mH = [],
        mj = new Map,
        mG = (t, e, i, s, n) => {
            let a = as.entity(t),
                r = as.entity(e);
            if (i.fx.effectMissile && void 0 !== a && void 0 !== r && void 0 !== a.visual && void 0 !== r.visual && (!a.visual.inFog || !r.visual.inFog)) {
                let l = {
                    mId: s,
                    targetid: e,
                    timer: n,
                    effect: mp(i.fx.effectMissile, nT(), a === as.player.id ? 1 : 0, !0),
                    start: sj([0, 0, 0], na(ar, [0, 0, a.radius], a.rot), a.pos)
                };
                l.effect.transform.matrixAutoUpdate = !0, mW.push(l), mj.set(s, l), mQ(l, mW.length - 1)
            }
        },
        mY = (t, e, i, s, n, a) => {
            if (s.fx.effectMissile) {
                let r = {
                    mId: n,
                    timer: a,
                    path: e,
                    fractions: i,
                    currentIndex: 0,
                    effect: mp(s.fx.effectMissile, nT(), t === as.player.id ? 1 : 0, !0)
                };
                r.effect.transform.matrixAutoUpdate = !0, mH.push(r), mj.set(n, r), mX(r, mH.length - 1)
            }
        },
        mQ = (t, e) => {
            if (!as.isEntityIdTaken(t.targetid) || t.timer.done(as.smoothtime)) return mW.splice(e, 1), t.effect.done = !0, void mj.delete(t.mId);
            let i = as.entity(t.targetid),
                s = sY([0, 0, 0], i.visualPosition, t.start);
            sX(t.effect.transform.position, t.start, s, t.timer.fraction(as.smoothtime));
            let n = as.getHeight(t.effect.transform.position[0], t.effect.transform.position[2]) + .3;
            n > t.effect.transform.position[1] && (t.effect.transform.position[1] = n), n5(t.effect.transform, i.visualPosition, !1, an), t.timer.passed(as.smoothtime) > .5 && (sV(t.start, t.effect.transform.position), t.timer.reset(as.smoothtime, t.timer.end - as.smoothtime)), nE(t.effect.transform, !1)
        },
        mX = (t, e) => {
            if (t.timer.done(as.smoothtime)) return mH.splice(e, 1), t.effect.done = !0, void mj.delete(t.mId);
            let i = Math.max(0, Math.min(1, t.timer.fraction(as.smoothtime)));
            t.currentIndex = og(t.effect.transform.position, t.path, i, t.fractions), nE(t.effect.transform, !1)
        },
        mJ = () => {
            mW.forEach(mQ), mH.forEach(mX)
        },
        mK = t => {
            mW.forEach(t => {
                t.effect.done = !0
            }), mH.forEach(t => {
                t.effect.done = !0
            }), mW.length = 0, mH.length = 0, mj.clear()
        },
        mZ, _t = 0,
        _e = new aH(0, 1),
        _i = t => {
            _t && (mZ ? mZ.ended && (_e.reset(t, lC(1, 2)), mZ = void 0) : _e.done(t) && (0 === _e.start ? _e.reset(t, lC(1, 2)) : mZ = lB(_t, 3)))
        },
        _s = (t, e) => {
            e && mZ && (mZ.stop(), mZ = void 0), _t = t.data.music
        },
        _n, _a = () => {
            _n = new nU(void 0, hu.sun, nK.TRIANGLES), sH(_n.transform.scale, .25), nC(_n.transform, hb.transform), _n.transform.visible = !1, lg(1455, t => {
                let e = new nd(nK, t);
                _n.geometry = e, _n.transform.visible = !0
            })
        },
        _r = () => {
            sV(_n.transform.position, mC.dir), sQ(_n.transform.position, _n.transform.position, .45), n5(_n.transform, aa, !1, an)
        },
        _l = new Uint8Array(34848),
        _o = new Float32Array(3267),
        _c = new Float32Array(3267);
    for (let _d = 0, _u = 0; _d <= 32; ++_d)
        for (let _$ = 0; _$ <= 32; ++_$, ++_u) _o[3 * _u + 0] = 2 * _$, _o[3 * _u + 2] = 2 * _d;
    let _h = {
            type: 0,
            data: new Uint32Array(6144)
        },
        _m = () => {
            _h.type = nK.UNSIGNED_INT;
            let t = 0;
            for (let e = 0; e <= 32; e += 1)
                for (let i = 0; i <= 32; i += 1) {
                    if (32 === i || 32 === e) continue;
                    let s = i + 33 * e,
                        n = i + (e + 1) * 33,
                        a = i + (e + 1) * 33 + 1,
                        r = i + 33 * e + 1;
                    _h.data[6 * t] = s, _h.data[6 * t + 1] = n, _h.data[6 * t + 2] = r, _h.data[6 * t + 3] = n, _h.data[6 * t + 4] = a, _h.data[6 * t + 5] = r, ++t
                }
        },
        __ = (t, e, i, s) => {
            let n = as.getChunkFromWorld(e, i);
            if (void 0 === n || e < 0 || i < 0 || e >= as.bounds || i >= as.bounds) return;
            let a = 3 * (2 * (e = e / 2 % 32) + 32 * (i = i / 2 % 32) * 2 + s);
            t[0] += n.normals[a], t[1] += n.normals[a + 1], t[2] += n.normals[a + 2]
        },
        _f = (t, e, i) => {
            _v(t, nK);
            let s = t.geometry.terrain,
                n = t.geometry.texture.image;
            if (e) {
                let a = [0, 0, 0],
                    r = s.attributes.position.data,
                    l = s.attributes.normal.data;
                for (let o = 0; o < 33; ++o)
                    for (let c = 0; c < 33; ++c) r[3 * (c + 33 * o) + 1] = t.getHeight(2 * c, 2 * o);
                for (let d = 0; d < 33; ++d)
                    for (let u = 0; u < 33; ++u) {
                        let $ = 3 * (u + 33 * d),
                            h = t.origin[0] + 2 * u,
                            m = t.origin[2] + 2 * d;
                        a[0] = a[1] = a[2] = 0, __(a, h, m, 0), __(a, h - 2, m, 0), __(a, h - 2, m, 1), __(a, h, m - 2, 0), __(a, h, m - 2, 1), __(a, h - 2, m - 2, 1);
                        let _ = a[0],
                            f = a[1],
                            p = a[2],
                            g = 1 / Math.sqrt(_ * _ + f * f + p * p);
                        l[$] = _ * g, l[$ + 1] = f * g, l[$ + 2] = p * g
                    }
                s.updateAttribute(s.attributes.position), s.updateAttribute(s.attributes.normal)
            }
            if (i) {
                for (let v = 0; v < 65; ++v)
                    for (let y = 0; y < 65; ++y) {
                        let b;
                        if (64 == y || 64 == v) {
                            let x = as.getChunk(t.x + (64 == y ? 1 : 0), t.z + (64 == v ? 1 : 0));
                            if (x && x.deserialized) b = mF(x.data.color[y % 64 + v % 64 * 64]);
                            else {
                                let w = Math.min(y, 63),
                                    k = Math.min(v, 63);
                                b = mF(t.data.color[w + 64 * k])
                            }
                        } else b = mF(t.data.color[y + 64 * v]);
                        let C = y + 132 * v,
                            S = y + 66 + 132 * v;
                        for (let E = 0; E < 4; ++E) _p(n, 4 * C + E, E, b), _p(n, 4 * S + E, E + 4, b)
                    }
                t.geometry.texture.needsUpdate = !0, t.geometry.texture.update()
            }
        },
        _p = (t, e, i, s, n) => {
            i == s.col1 ? t[e] = 128 + s.val1 / 8 * 127 : i == s.col2 ? t[e] = 128 - s.val1 / 8 * 127 : i == s.col3 ? t[e] = (.5 - s.val1 / 8 * .5) * (s.val2 / 8) * 255 : t[e] = 0
        },
        _g = {
            min: [0, 0, 0],
            max: [64, 64, 64],
            center: [32, 32, 32],
            scale: [64, 64, 64],
            radius: 60,
            initiated: !0
        },
        _v = (t, e) => {
            if (!t.geometry.terrain) {
                let i = _y(),
                    s = new nd(e, {
                        ...i,
                        index: _h
                    });
                Object.assign(s.bounds, _g), t.geometry.terrain = s, t.geometry.texture = _0(e, t, _l)
            }
            if (!t.meshes.terrain) {
                let n = t.meshes.terrain = new nU(t.geometry.terrain, hu.terrain, e.TRIANGLES, !0, 0, hu.shadowTerrain, ue.water, ue.shadow);
                n.frustumCulled = !0, n.renderOrder = 3e3, n.uniformData.texvals1 = t.geometry.texture
            }
            sV(t.meshes.terrain.transform.position, t.origin), t.meshes.terrain.transform.matrixNeedsUpdate = !0, nE(t.meshes.terrain.transform, !1), t.state = Math.max(t.state, 5)
        },
        _y = (t, e) => ({
            position: {
                size: 3,
                data: _o
            },
            normal: {
                size: 3,
                data: _c
            }
        }),
        _0 = (t, e, i) => {
            let s = new nq(t, {
                image: i,
                width: 132,
                height: 66
            });
            return s.update(), s
        },
        _b = (t, e) => {
            t.data.terrains.forEach((t, e) => {
                let i = $.get(t);
                l1(i.texture, t => {
                    ly.terrain[e] = t, t.setAnisotropy(2 ** sO.anisotropy);
                    let s = uc["tinf" + e];
                    n9(s.value, [i.scale / 127, i.darkest / 255, i.brightest / 255, i.spec / 255]), s.state++, hu.terrain.active = !0
                })
            })
        },
        _x, _w, _1 = [],
        _9 = () => {
            _x = new nd(nK, _2(nK)), l1(1242, t => {
                hu.water.uniforms.waterDiffuse.value = t, l1(1243, t => {
                    hu.water.active = !0, hu.water.uniforms.waterDiffuse2.value = t
                })
            })
        },
        _3 = (t, e) => {
            for (let i = 0; i < t.data.water.length; ++i) {
                let s = _1[i],
                    n = t.data.water[i];
                s || (_1[i] = s = new nU(void 0, hu.water, nK.TRIANGLES, !0, 6e3, void 0, void 0, ue.water), hy(s.transform)), s.geometry = _x, s.uniformData.watertype = n.watertype, s.uniformData.speed = n.speed, s.uniformData.visibility = n.visibility, s.uniformData.colFoam = dA(n.colFoam), s.uniformData.colShallow = dA(n.colShallow), s.uniformData.colDeep = dA(n.colDeep);
                let a = 64 * t.chunkAmount;
                0 == n.watertype ? (sW(s.transform.position, .5 * a, n.pos[1], .5 * a), sW(s.transform.scale, 1500, 1, 1500), s.transform.matrixAutoUpdate = !0, _w = s) : (sW(s.transform.position, n.pos[0], n.pos[1], n.pos[2]), sW(s.transform.scale, n.sx, 1, n.sz)), sW(s.transform.rotation, 0, 0, 0), s.transform.position[0] = aL(0, a, s.transform.position[0]), s.transform.position[2] = aL(0, a, s.transform.position[2])
            }
        },
        _k = t => {
            _1.forEach(t => {
                h0(t.transform)
            }), _1.length = 0, _w = void 0
        },
        _2 = t => {
            let e = new Float32Array(12),
                i = new Uint32Array(6),
                s = 0;
            for (let n = 0, a = 0; n <= 1; ++n)
                for (let r = 0; r <= 1; ++r, ++a) {
                    if (e[3 * a + 0] = r - .5, e[3 * a + 2] = n - .5, 1 === r || 1 === n) continue;
                    let l = r + 2 * n,
                        o = r + 2 * (n + 1),
                        c = r + 2 * (n + 1) + 1,
                        d = r + 2 * n + 1;
                    i[6 * s] = l, i[6 * s + 1] = o, i[6 * s + 2] = d, i[6 * s + 3] = o, i[6 * s + 4] = c, i[6 * s + 5] = d, ++s
                }
            return {
                position: {
                    size: 3,
                    data: e
                },
                index: {
                    type: t.UNSIGNED_INT,
                    data: i
                }
            }
        },
        _4 = () => {
            _w && (_w.transform.position[0] = nZ.transform.worldMatrix[12], _w.transform.position[2] = nZ.transform.worldMatrix[14])
        },
        _C = () => {
            lb(), ua(), hm(), m7(), h3(), _9(), hA(), hY(), hx(), _a(), _m()
        },
        _S = (t, e, i, s) => {
            ur(e), m6(e, i), mJ(), mc(t, e), hz(t, i), hQ(t, i ** 2), hE(t, e), hw(), _r(), _4(), lD(), _i(e), hh(e)
        },
        _7 = (t, e) => {
            lW(), m5(t), _b(t), _3(t), mV(t), _s(t, e)
        },
        _E = t => {
            _k(), mK(), m1(), hJ(), hP(), lH()
        },
        _6 = (t, e, i, s, n) => {
            _f(t, e, i), mB(t, s)
        },
        _P = sO.resolution / 100,
        _M = new class t {
            constructor({
                canvas: t = document.createElement("canvas"),
                width: e = 300,
                height: i = 150,
                dpr: s = 1,
                alpha: n = !1,
                depth: a = !0,
                stencil: r = !1,
                antialias: l = !1,
                preserveDrawingBuffer: o = !1,
                powerPreference: c = "default",
                autoClear: d = !0,
                resolution: u = 1
            } = {}) {
                this.dpr = s, this.alpha = n, this.color = !0, this.depth = a, this.stencil = r, this.autoClear = d, this.gl = t.getContext("webgl2", {
                    alpha: n,
                    depth: a,
                    stencil: r,
                    antialias: l,
                    preserveDrawingBuffer: o,
                    powerPreference: c,
                    premultipliedAlpha: !1
                }), this.gl && (this.gl.renderer = this, this.canvas2dElement = document.createElement("canvas"), this.canvas2dContext = this.canvas2dElement.getContext("2d", {}), this.width = this.height = 0, this.state = {
                    blendFunc: {
                        src: this.gl.ONE,
                        dst: this.gl.ZERO
                    },
                    blendEquation: {
                        modeRGB: this.gl.FUNC_ADD
                    },
                    cullFace: null,
                    frontFace: this.gl.CCW,
                    depthMask: !0,
                    depthFunc: this.gl.LESS,
                    flipY: !1,
                    framebuffer: null,
                    viewport: {
                        width: null,
                        height: null
                    },
                    textureUnits: [],
                    activeTextureUnit: 0
                }, this.textureUnitsUsed = [], this.extensions = {}, this.vertexAttribDivisor = this.getExtension("ANGLE_instanced_arrays", "vertexAttribDivisor", "vertexAttribDivisorANGLE"), this.drawArraysInstanced = this.getExtension("ANGLE_instanced_arrays", "drawArraysInstanced", "drawArraysInstancedANGLE"), this.drawElementsInstanced = this.getExtension("ANGLE_instanced_arrays", "drawElementsInstanced", "drawElementsInstancedANGLE"), this.createVertexArray = this.getExtension("OES_vertex_array_object", "createVertexArray", "createVertexArrayOES"), this.bindVertexArray = this.getExtension("OES_vertex_array_object", "bindVertexArray", "bindVertexArrayOES"), this.deleteVertexArray = this.getExtension("OES_vertex_array_object", "deleteVertexArray", "deleteVertexArrayOES"), this.anisotropy = this.getExtension("EXT_texture_filter_anisotropic"), this.parameters = {
                    maxTextureUnits: this.gl.getParameter(this.gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
                    maxAnisotropy: this.gl.getParameter(this.anisotropy.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                }, this.currentGeometry = -1, this.currentAttributeOrder = "", this.currentProgram = -1, this.setSize(e, i, u))
            }
            setSize(t, e, i) {
                this.width = Math.round(t * i), this.height = Math.round(e * i), this.gl.canvas.width = this.width * this.dpr, this.gl.canvas.height = this.height * this.dpr, this.canvas2dElement.width = t * this.dpr, this.canvas2dElement.height = e * this.dpr
            }
            setViewport(t, e) {
                this.state.viewport.width === t && this.state.viewport.height === e || (this.state.viewport.width = t, this.state.viewport.height = e, this.gl.viewport(0, 0, t, e))
            }
            enable(t) {
                !0 !== this.state[t] && (this.gl.enable(t), this.state[t] = !0)
            }
            disable(t) {
                !1 !== this.state[t] && (this.gl.disable(t), this.state[t] = !1)
            }
            setBlendFunc(t, e, i, s) {
                this.state.blendFunc.src === t && this.state.blendFunc.dst === e && this.state.blendFunc.srcAlpha === i && this.state.blendFunc.dstAlpha === s || (this.state.blendFunc.src = t, this.state.blendFunc.dst = e, this.state.blendFunc.srcAlpha = i, this.state.blendFunc.dstAlpha = s, void 0 !== i ? this.gl.blendFuncSeparate(t, e, i, s) : this.gl.blendFunc(t, e))
            }
            setBlendEquation(t, e) {
                this.state.blendEquation.modeRGB === t && this.state.blendEquation.modeAlpha === e || (this.state.blendEquation.modeRGB = t, this.state.blendEquation.modeAlpha = e, void 0 !== e ? this.gl.blendEquationSeparate(t, e) : this.gl.blendEquation(t))
            }
            setCullFace(t) {
                this.state.cullFace !== t && (this.state.cullFace = t, this.gl.cullFace(t))
            }
            setFrontFace(t) {
                this.state.frontFace !== t && (this.state.frontFace = t, this.gl.frontFace(t))
            }
            setDepthMask(t) {
                this.state.depthMask !== t && (this.state.depthMask = t, this.gl.depthMask(t))
            }
            setDepthFunc(t) {
                this.state.depthFunc !== t && (this.state.depthFunc = t, this.gl.depthFunc(t))
            }
            activeTexture(t) {
                this.state.activeTextureUnit !== t && (this.state.activeTextureUnit = t, this.gl.activeTexture(this.gl.TEXTURE0 + t))
            }
            bindFramebuffer({
                target: t = this.gl.FRAMEBUFFER,
                buffer: e = null
            } = {}) {
                this.state.framebuffer !== e && (this.state.framebuffer = e, this.gl.bindFramebuffer(t, e))
            }
            getExtension(t, e, i) {
                return e && this.gl[e] ? this.gl[e].bind(this.gl) : (this.extensions[t] || (this.extensions[t] = this.gl.getExtension(t)), e ? this.extensions[t][i].bind(this.extensions[t]) : this.extensions[t])
            }
            sortOpaque(t, e) {
                return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program.id !== e.program.id ? t.program.id - e.program.id : t.zDepth !== e.zDepth ? t.zDepth - e.zDepth : e.id - t.id
            }
            sortTransparent(t, e) {
                return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.zDepth !== e.zDepth ? e.zDepth - t.zDepth : e.id - t.id
            }
            sortUI(t, e) {
                return t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program.id !== e.program.id ? t.program.id - e.program.id : e.id - t.id
            }
            getRenderList(t, e, i, s, n) {
                let a = [];
                e && i && e.updateFrustum();
                for (let r = 0, l = t.length; r < l; ++r) n1(a, t[r], n, e, i);
                if (s) {
                    let o = [],
                        c = [],
                        d = [];
                    for (let u = 0, $ = a.length; u < $; ++u) {
                        let h = a[u];
                        h.program.transparent ? h.program.depthTest ? c.push(h) : d.push(h) : o.push(h), h.zDepth = 0, 0 === h.renderOrder && h.program.depthTest && e && (nv(nw, h.transform.worldMatrix), ni(nw, nw, e.projectionViewMatrix), h.zDepth = nw[2])
                    }
                    o.sort(this.sortOpaque), c.sort(this.sortTransparent), d.sort(this.sortUI), a = o.concat(c, d)
                }
                return a
            }
            render({
                scene: t,
                camera: e,
                target: i = null,
                update: s = !0,
                sort: n = !0,
                frustumCull: a = !0,
                shadowTarget: r = !1,
                sceneCamera: l,
                clear: o = !0
            }) {
                r && (i = r), null === i ? (this.bindFramebuffer(), this.setViewport(this.width * this.dpr, this.height * this.dpr)) : (this.bindFramebuffer(i), this.setViewport(i.width, i.height)), o && this.autoClear && (!this.depth || i && i.depth || (this.enable(this.gl.DEPTH_TEST), this.setDepthMask(!0)), this.gl.clear((this.color ? this.gl.COLOR_BUFFER_BIT : 0) | (this.depth ? this.gl.DEPTH_BUFFER_BIT : 0) | (this.stencil ? this.gl.STENCIL_BUFFER_BIT : 0)));
                let c = this.getRenderList(t, e, a, n, r);
                for (let d = 0, u = c.length; d < u; ++d) c[d].draw(e, r, l, s)
            }
            postRender() {
                this.textureUnitsUsed.length = 0
            }
        }({
            width: window.innerWidth,
            height: window.innerHeight,
            resolution: _P,
            antialias: !1,
            powerPreference: "high-performance"
        });
    _M.gl || (alert("WebGL2 problem found."), window.location.href = "/technical");
    let _5 = _M.gl,
        _D = new nN(.1, 500, 80),
        _T = nT(),
        _A = new class t {
            constructor(t, {
                width: e,
                height: i,
                dpr: s,
                wrapS: n = t.CLAMP_TO_EDGE,
                wrapT: a = t.CLAMP_TO_EDGE,
                minFilter: r = t.LINEAR,
                magFilter: l = t.LINEAR,
                resolution: o = 1
            } = {}) {
                this.gl = t, this.options = {
                    wrapS: n,
                    wrapT: a,
                    minFilter: r,
                    magFilter: l
                }, this.passes = [], this.geometry = new nd(t, {
                    position: {
                        size: 2,
                        data: new Float32Array([-1, -1, 3, -1, -1, 3])
                    },
                    uv: {
                        size: 2,
                        data: new Float32Array([0, 0, 2, 0, 0, 2])
                    }
                }), this.resize({
                    width: e,
                    height: i,
                    dpr: s,
                    resolution: o
                })
            }
            addPass({
                vertex: t = nJ,
                fragment: e = "#version 300 es\nprecision highp float;\nuniform sampler2D tMap;\nin vec2 vUv;\nout vec4 fragColor;\nvoid main() {\n    fragColor = texture2D(tMap, vUv);\n}",
                uniforms: i = {},
                textureUniform: s = "tMap",
                enabled: n = !0,
                globalUniforms: a,
                blitToOriginal: r = !1
            } = {}) {
                i[s] = {
                    value: this.target.texture
                }, i.tOrig = {
                    value: this.original.texture
                }, i.tOrigDepth = {
                    value: this.original.depthTexture
                };
                let l = new n$(this.gl, {
                        vertex: t,
                        fragment: e,
                        uniforms: i,
                        globalUniforms: a
                    }),
                    o = {
                        mesh: new nU(this.geometry, l, this.gl.TRIANGLES),
                        program: l,
                        uniforms: i,
                        enabled: n,
                        textureUniform: s,
                        blitToOriginal: r
                    };
                return this.passes.push(o), o
            }
            resize({
                width: t,
                height: e,
                dpr: i,
                resolution: s = 1
            } = {}) {
                i && (this.dpr = i), t && (this.width = t * s, this.height = e * s), i = this.dpr || this.gl.renderer.dpr, t = (this.width || this.gl.renderer.width) * i, e = (this.height || this.gl.renderer.height) * i, this.options.width = t, this.options.height = e, this.target = new nV(this.gl, this.options), this.original = new nV(this.gl, this.options), this.ping = new nV(this.gl, this.options), this.pong = new nV(this.gl, this.options), this.passes.forEach(t => {
                    t.uniforms.tOrig.value = this.original.texture
                })
            }
            render({
                scene: t,
                camera: e,
                target: i = null,
                update: s = !0,
                sort: n = !0,
                frustumCull: a = !0
            }) {
                let r = this.passes.filter(t => t.enabled);
                this.gl.renderer.render({
                    scene: t,
                    camera: e,
                    target: r.length ? this.original : i,
                    update: s,
                    sort: n,
                    frustumCull: a
                }), r.forEach((t, e) => {
                    let s = e ? e % 2 ? this.ping : this.pong : this.target,
                        n = e == r.length - 1 ? i : e % 2 ? this.pong : this.ping;
                    t.mesh.program.uniforms[t.textureUniform].value = s.texture, this.gl.renderer.render({
                        scene: [t.mesh.transform],
                        target: n,
                        clear: !0
                    }), t.blitToOriginal && null !== n && (this.gl.bindFramebuffer(this.gl.READ_FRAMEBUFFER, n.buffer), this.gl.bindFramebuffer(this.gl.DRAW_FRAMEBUFFER, this.original.buffer), this.gl.blitFramebuffer(0, 0, n.width, n.height, 0, 0, n.width, n.height, this.gl.COLOR_BUFFER_BIT, this.gl.NEAREST))
                })
            }
        }(_5, {
            width: window.innerWidth,
            height: window.innerHeight,
            resolution: _P
        }),
        _8 = 100,
        _R = _8 ** 2,
        _F = () => {
            nC(_D.transform, _T), sW(_D.transform.position, 0, 1, -1), _D.lookAt(an, an), _T.matrixAutoUpdate = !0, ag(_5, _D, _T, _A, _M), _C(), _M.canvas2dElement.className = "l-canvas", _M.gl.canvas.className = "l-canvas", _5.canvas.style.pointerEvents = "all", window.addEventListener("resize", _N, !1), _N(null, !0)
        };
    eV.subscribe(t => {
        _R = (_8 = t ** 2 / 10) ** 2, _D.far = _8 + 10, _D.perspective()
    }), el.subscribe(t => {});
    let _N = (t, e) => {
        e || (_M.setSize(window.innerWidth, window.innerHeight, _P), _A.resize({
            width: window.innerWidth,
            height: window.innerHeight,
            dpr: 1,
            resolution: _P
        })), _D.aspect = _5.canvas.width / _5.canvas.height, _D.perspective(), uv(_5.canvas.width, _5.canvas.height)
    };
    eW.subscribe(t => {
        let e = t / 100,
            i = _P !== e;
        _P = e, sO.resolutionScale = e, i && _N(null, !1)
    });
    let _I = () => {
            hv.forEach(t => {
                nE(t, !1)
            }), sO.shadows && dZ && (hf(), ug(un.water, !1), _M.render({
                scene: hv,
                camera: un.water,
                shadowTarget: ut.water
            }), hg(), h_(), ug(un.shadow, !1), _M.render({
                scene: hv,
                camera: un.shadow,
                shadowTarget: ut.shadowStatic
            }), hp(), ul(!1)), sO.shadows && (_5.bindFramebuffer(_5.READ_FRAMEBUFFER, ut.shadowStatic.buffer), _5.bindFramebuffer(_5.DRAW_FRAMEBUFFER, ut.shadow.buffer), _5.blitFramebuffer(0, 0, us, us, 0, 0, us, us, _5.DEPTH_BUFFER_BIT, _5.NEAREST), ug(un.shadow, !1), _M.render({
                scene: hv,
                clear: !1,
                camera: un.shadow,
                sceneCamera: _D,
                shadowTarget: ut.shadow
            })), ug(_D, !0), _A.render({
                scene: hv,
                camera: _D,
                update: !sO.shadows
            }), _M.postRender()
        },
        _U = (t, e) => {
            _S(t, e.smoothtime, _8)
        },
        _z = (t, e) => {
            _7(t, e)
        },
        _O = t => {
            _E(), me()
        },
        _L = (t, e, i, s, n) => {
            _6(t, e, i, s), (e || i || n) && ul(!0)
        };
    class _B extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a;
                return N(e, em, t => s(1, n = t)), tg(() => {
                    a.appendChild(_M.gl.canvas), a.appendChild(_M.canvas2dElement)
                }), [a, n, function t(e) {
                    tw[e ? "unshift" : "push"](() => {
                        s(0, a = e)
                    })
                }]
            }, function t(e) {
                let i;
                return {
                    c() {
                        tr(i = J("div"), "cursor", e[1])
                    },
                    m(t, s) {
                        Y(t, i, s), e[2](i)
                    },
                    p(t, [e]) {
                        2 & e && tr(i, "cursor", t[1])
                    },
                    i: C,
                    o: C,
                    d(t) {
                        t && Q(i), e[2](null)
                    }
                }
            }, A, {})
        }
    }

    function _q(t) {
        let e, i, s, n, a;
        return {
            c() {
                e = J("div"), ti(i = J("img"), "class", s = O(t[2].css) + " svelte-sh553q"), i.src !== (n = t[2].img) && ti(i, "src", n), ti(e, "class", a = "container border " + t[2].border + " svelte-sh553q"), tr(e, "top", t[1] + "px"), tr(e, "left", t[0] + "px")
            },
            m(t, s) {
                Y(t, e, s), G(e, i)
            },
            p(t, r) {
                4 & r && s !== (s = O(t[2].css) + " svelte-sh553q") && ti(i, "class", s), 4 & r && i.src !== (n = t[2].img) && ti(i, "src", n), 4 & r && a !== (a = "container border " + t[2].border + " svelte-sh553q") && ti(e, "class", a), 2 & r && tr(e, "top", t[1] + "px"), 1 & r && tr(e, "left", t[0] + "px")
            },
            d(t) {
                t && Q(e)
            }
        }
    }
    class _V extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a, r;
                N(e, eh, t => s(2, n = t));
                let l = t => {
                    (n || a || r) && (n ? (s(0, a = t.clientX - 10), s(1, r = t.clientY - 10)) : (s(0, a = 0), s(1, r = 0)))
                };
                return tg(() => {
                    document.addEventListener("mousemove", l, !1)
                }), ty(() => {
                    document.removeEventListener("mousemove", l)
                }), [a, r, n]
            }, function t(e) {
                let i, s = e[2] && e[0] && e[1] && _q(e);
                return {
                    c() {
                        s && s.c(), i = tt()
                    },
                    m(t, e) {
                        s && s.m(t, e), Y(t, i, e)
                    },
                    p(t, [e]) {
                        t[2] && t[0] && t[1] ? s ? s.p(t, e) : ((s = _q(t)).c(), s.m(i.parentNode, i)) : s && (s.d(1), s = null)
                    },
                    i: C,
                    o: C,
                    d(t) {
                        s && s.d(t), t && Q(i)
                    }
                }
            }, A, {})
        }
    }

    function _W(t, e, i) {
        let s = t.slice();
        return s[6] = e[i], s
    }

    function _H(t) {
        let e, i = t[2].opts,
            s = [];
        for (let n = 0; n < i.length; n += 1) s[n] = _Y(_W(t, i, n));
        let a = null;
        return i.length || (a = _j()), {
            c() {
                e = J("div");
                for (let i = 0; i < s.length; i += 1) s[i].c();
                a && a.c(), ti(e, "class", "panel context border grey"), tr(e, "left", t[2].x + "px"), tr(e, "top", t[2].y + "px")
            },
            m(i, n) {
                Y(i, e, n);
                for (let r = 0; r < s.length; r += 1) s[r].m(e, null);
                a && a.m(e, null), t[4](e)
            },
            p(t, n) {
                if (5 & n) {
                    let r;
                    for (i = t[2].opts, r = 0; r < i.length; r += 1) {
                        let l = _W(t, i, r);
                        s[r] ? s[r].p(l, n) : (s[r] = _Y(l), s[r].c(), s[r].m(e, null))
                    }
                    for (; r < s.length; r += 1) s[r].d(1);
                    s.length = i.length, i.length ? a && (a.d(1), a = null) : a || ((a = _j()).c(), a.m(e, null))
                }
                4 & n && tr(e, "left", t[2].x + "px"), 4 & n && tr(e, "top", t[2].y + "px")
            },
            d(i) {
                i && Q(e), X(s, i), a && a.d(), t[4](null)
            }
        }
    }

    function _j(t) {
        let e;
        return {
            c() {
                (e = J("div")).textContent = "No options", ti(e, "class", "choice disabled")
            },
            m(t, i) {
                Y(t, e, i)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function _G(t) {
        let e, i, s;
        return {
            c() {
                e = J("img"), s = Z(), ti(e, "class", "svgicon"), e.src !== (i = "/assets/ui/icons/" + t[6].icon + ".svg?v=5699699") && ti(e, "src", i)
            },
            m(t, i) {
                Y(t, e, i), Y(t, s, i)
            },
            p(t, s) {
                4 & s && e.src !== (i = "/assets/ui/icons/" + t[6].icon + ".svg?v=5699699") && ti(e, "src", i)
            },
            d(t) {
                t && Q(e), t && Q(s)
            }
        }
    }

    function _Y(t) {
        let e, i, s, n, a, r = t[6].name + "",
            l = t[6].icon && _G(t);

        function o(...e) {
            return t[3](t[6], ...e)
        }
        return {
            c() {
                e = J("div"), l && l.c(), i = K(r), ti(e, "class", s = "choice " + (t[6].css || ""))
            },
            m(t, s) {
                Y(t, e, s), l && l.m(e, null), G(e, i), n || (a = te(e, "mouseup", o), n = !0)
            },
            p(n, a) {
                (t = n)[6].icon ? l ? l.p(t, a) : ((l = _G(t)).c(), l.m(e, i)) : l && (l.d(1), l = null), 4 & a && r !== (r = t[6].name + "") && tn(i, r), 4 & a && s !== (s = "choice " + (t[6].css || "")) && ti(e, "class", s)
            },
            d(t) {
                t && Q(e), l && l.d(), n = !1, a()
            }
        }
    }
    class _Q extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a;
                N(e, et, t => s(2, n = t));
                let r = t => {
                        t.target != a && t.target.parentNode != a && n && et.set(void 0)
                    },
                    l = (t, e) => {
                        e.fun(t), et.set(void 0)
                    };
                tg(() => {
                    document.addEventListener("pointerdown", r, !1)
                }), ty(() => {
                    document.removeEventListener("pointerdown", r)
                });
                let o = (t, e) => l(e, t);
                return [l, a, n, o, function t(e) {
                    tw[e ? "unshift" : "push"](() => {
                        s(1, a = e)
                    })
                }]
            }, function t(e) {
                let i, s = e[2] && _H(e);
                return {
                    c() {
                        s && s.c(), i = tt()
                    },
                    m(t, e) {
                        s && s.m(t, e), Y(t, i, e)
                    },
                    p(t, [e]) {
                        t[2] ? s ? s.p(t, e) : ((s = _H(t)).c(), s.m(i.parentNode, i)) : s && (s.d(1), s = null)
                    },
                    i: C,
                    o: C,
                    d(t) {
                        s && s.d(t), t && Q(i)
                    }
                }
            }, A, {
                opt: 0
            })
        }
        get opt() {
            return this.$$.ctx[0]
        }
    }
    let _X = t => {
            navigator.clipboard.writeText(t)
        },
        _J = {
            normal: {
                partyBasedHostility: !1,
                allowRespawn: !0,
                pvpprotect: !0,
                instanced: !1
            },
            arena3v3: {
                name: "Arena 3v3",
                queue: !0,
                instanced: !0,
                groupsize: 3,
                groupcount: 2,
                partyBasedHostility: !0,
                allowRespawn: !1,
                pvpprotect: !1
            },
            arena5v5: {
                name: "Arena 5v5",
                startTimer: 30,
                groupsize: 5,
                groupcount: 2,
                queue: !0,
                instanced: !0,
                partyBasedHostility: !0,
                allowRespawn: !1,
                pvpprotect: !1
            },
            guardstonefind: {
                name: "Guardstone",
                queue: !0,
                partyfind: !0,
                minlevel: 0
            },
            headlessfind: {
                name: "Headless Landing",
                queue: !0,
                partyfind: !0,
                minlevel: 25
            },
            faivelfind: {
                name: "Faivel",
                queue: !0,
                partyfind: !0,
                minlevel: 35
            }
        },
        _K = {
            partyleave: t => ({
                name: rC.ui.party.leave,
                fun() {
                    $1("partyleave")
                }
            }),
            partyinvite: t => ({
                name: rC.ui.party.invite,
                fun() {
                    $1("partyinvite", t)
                }
            }),
            partykick: t => ({
                name: rC.ui.party.kick,
                fun() {
                    $1("partykick", t)
                }
            }),
            partygiveassistant: t => ({
                name: rC.ui.party.giveAssistant,
                fun() {
                    $1("partysetrole", t + " 1")
                }
            }),
            partygiveleader: t => ({
                name: rC.ui.party.giveLeader,
                fun() {
                    $1("partysetrole", t + " 2")
                }
            }),
            partyremoveassistant: t => ({
                name: rC.ui.party.removeAssistant,
                fun() {
                    $1("partysetrole", t + " 0")
                }
            }),
            partycreate: t => ({
                name: rC.ui.party.create,
                fun() {
                    $1("partycreate")
                }
            }),
            whisper: t => ({
                name: rC.ui.chat.whisper,
                fun() {
                    ic.set(t)
                }
            }),
            itemdrop: (...t) => ({
                name: rC.ui.inventory.drop,
                fun: () => fi(...t)
            }),
            itemsell: (...t) => ({
                name: rC.ui.inventory.sell,
                fun: () => fe(...t)
            }),
            itemstash: t => ({
                name: rC.ui.stash.stash,
                fun() {
                    $1("itemstash", t)
                }
            }),
            itemmove: (t, e) => ({
                name: rC.ui.inventory.equip,
                fun() {
                    dY(13, 100), $1("itemmove", `${t} ${e}`)
                }
            }),
            itemsplithalf: t => ({
                name: rC.ui.inventory.splithalf,
                fun() {
                    $1("itemsplithalf", t)
                }
            }),
            itemsplitone: t => ({
                name: rC.ui.inventory.splitone,
                fun() {
                    $1("itemsplitone", t)
                }
            }),
            itemuse: (t, e, i, s) => ({
                name: rC.ui.inventory.use,
                fun() {
                    $D(i < s, () => rp(aF.clientPlayerSkill.packData({
                        id: e,
                        info: [t]
                    })), "Bind Item", "Using this item will bind it to you. Continue?")
                }
            }),
            itemcopyid: t => ({
                name: rC.ui.inventory.copyitemid,
                fun() {
                    _X(t)
                }
            }),
            startqueue: (t, e) => ({
                name: _J[t].name,
                css: e ? "" : "disabled",
                fun() {
                    $1("startqueue", t)
                }
            }),
            stopqueue: (t, e) => ({
                icon: "check",
                name: _J[t].name,
                css: e ? "" : "disabled",
                fun() {
                    $1("stopqueue", t)
                }
            }),
            report: (t, e, i) => ({
                name: "Report",
                fun(s) {
                    e3.set({
                        name: t,
                        reason: 0,
                        messageId: e,
                        info: i
                    })
                }
            })
        },
        _Z = (t, e) => {
            let i = [{
                name: e.name,
                css: "disabled"
            }];
            0 === e.type && (e.id == as.player.id ? sO.partyinfo.membercount > 0 ? i.push(_K.partyleave()) : i.push(_K.partycreate()) : (e.faction == as.player.faction && (as.party.has(e.name) ? sO.partyinfo.role > e.role && (2 == sO.partyinfo.role && i.push(_K.partykick(e.name)), 0 == e.role ? i.push(_K.partygiveassistant(e.name)) : 1 == e.role && i.push(_K.partyremoveassistant(e.name)), sO.partyinfo.role > 1 && i.push(_K.partygiveleader(e.name))) : i.push(_K.partyinvite(e.name))), i.push(_K.report(e.name)), i.push(_K.whisper(e.name)))), et.set({
                x: t.pageX,
                y: t.pageY,
                opts: i
            })
        },
        ft = (t, e, i, s, n, a, r, l) => {
            $D(e >= sO.itemProtectQuality || i > 0, () => {
                $1(t, "" + s)
            }, r, `${l} ${rS(n,a)}?`)
        },
        fe = (t, e, i, s, n) => {
            ft("itemtradersell", t, e, i, s, n, "Sell item", "Really sell")
        },
        fi = (t, e, i, s, n) => {
            ft("itemdrop", t, e, i, s, n, "Drop item", "Really drop")
        };

    function fs(t) {
        let e, i;
        return {
            c() {
                ti(e = J("img"), "class", "icon svelte-erbdzy"), e.src !== (i = "/assets/ui/icons/gem.svg?v=5699699") && ti(e, "src", i)
            },
            m(t, i) {
                Y(t, e, i)
            },
            d(t) {
                t && Q(e)
            }
        }
    }
    class fn extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let {
                    name: n
                } = i, {
                    level: a
                } = i, {
                    pclass: r
                } = i, {
                    faction: l
                } = i, {
                    sub: o = !1
                } = i;
                return e.$$set = t => {
                    "name" in t && s(0, n = t.name), "level" in t && s(1, a = t.level), "pclass" in t && s(2, r = t.pclass), "faction" in t && s(3, l = t.faction), "sub" in t && s(4, o = t.sub)
                }, [n, a, r, l, o]
            }, function t(e) {
                let i, s, n, a, r, l, o, c, d = e[4] && fs();
                return {
                    c() {
                        i = J("span"), d && d.c(), s = J("img"), a = K(e[1]), r = Z(), l = J("span"), o = K(e[0]), ti(s, "class", "icon svelte-erbdzy"), s.src !== (n = rB(e[2])) && ti(s, "src", n), ti(i, "class", "textwhite"), ti(l, "class", c = "name textf" + e[3] + " svelte-erbdzy")
                    },
                    m(t, e) {
                        Y(t, i, e), d && d.m(i, null), G(i, s), G(i, a), G(i, r), Y(t, l, e), G(l, o)
                    },
                    p(t, [e]) {
                        t[4] ? d || ((d = fs()).c(), d.m(i, s)) : d && (d.d(1), d = null), 4 & e && s.src !== (n = rB(t[2])) && ti(s, "src", n), 2 & e && tn(a, t[1]), 1 & e && tn(o, t[0]), 8 & e && c !== (c = "name textf" + t[3] + " svelte-erbdzy") && ti(l, "class", c)
                    },
                    i: C,
                    o: C,
                    d(t) {
                        t && Q(i), d && d.d(), t && Q(l)
                    }
                }
            }, A, {
                name: 0,
                level: 1,
                pclass: 2,
                faction: 3,
                sub: 4
            })
        }
    }
    let {
        Map: fa
    } = tU;

    function fr(t, e, i) {
        let s = t.slice();
        return s[31] = e[i], s
    }

    function fl(t, e, i) {
        let s = t.slice();
        return s[34] = e[i], s
    }

    function fo(t, e, i) {
        let s = t.slice();
        return s[37] = e[i], s
    }

    function fc(t) {
        let e, i, s, n, a;

        function r(...e) {
            return t[13](t[37], ...e)
        }

        function l(...e) {
            return t[14](t[37], ...e)
        }
        return i = new fn({
            props: {
                name: t[37].sender,
                pclass: t[37].cclass,
                level: t[37].level,
                faction: t[37].faction,
                sub: t[37].sub
            }
        }), {
            c() {
                e = J("span"), tW(i.$$.fragment), ti(e, "class", "sender svelte-16y0b84")
            },
            m(t, o) {
                Y(t, e, o), tH(i, e, null), s = !0, n || (a = [te(e, "contextmenu", r), te(e, "dblclick", l)], n = !0)
            },
            p(e, s) {
                t = e;
                let n = {};
                64 & s[0] && (n.name = t[37].sender), 64 & s[0] && (n.pclass = t[37].cclass), 64 & s[0] && (n.level = t[37].level), 64 & s[0] && (n.faction = t[37].faction), 64 & s[0] && (n.sub = t[37].sub), i.$set(n)
            },
            i(t) {
                s || (tR(i.$$.fragment, t), s = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), s = !1
            },
            d(t) {
                t && Q(e), tj(i), n = !1, D(a)
            }
        }
    }

    function fd(t) {
        let e, i, s, n = t[37].text + "";
        return {
            c() {
                e = J("span"), i = K(n), ti(e, "class", s = "text" + t[37].channel + " svelte-16y0b84")
            },
            m(t, s) {
                Y(t, e, s), G(e, i)
            },
            p(t, a) {
                64 & a[0] && n !== (n = t[37].text + "") && tn(i, n), 64 & a[0] && s !== (s = "text" + t[37].channel + " svelte-16y0b84") && ti(e, "class", s)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function fu(t) {
        let e, i, s = t[37].text + "";
        return {
            c() {
                ti(e = J("span"), "class", i = "text" + t[37].channel + " svelte-16y0b84")
            },
            m(t, i) {
                Y(t, e, i), e.innerHTML = s
            },
            p(t, n) {
                64 & n[0] && s !== (s = t[37].text + "") && (e.innerHTML = s), 64 & n[0] && i !== (i = "text" + t[37].channel + " svelte-16y0b84") && ti(e, "class", i)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function f$(t, e) {
        let i, s, n, a, r, l, o, c, d, u, $ = e[37].time + "",
            h = e[37].channel + "",
            m = e[37].sender && fc(e);

        function _(t, e) {
            return t[37].interpolate ? fu : fd
        }
        let f = _(e),
            p = f(e);
        return {
            key: t,
            first: null,
            c() {
                i = J("article"), s = J("div"), n = J("span"), a = K($), r = J("span"), l = J("span"), o = K(h), c = Z(), m && m.c(), p.c(), ti(n, "class", "time svelte-16y0b84"), ti(l, "class", "capitalize channel svelte-16y0b84"), ti(r, "class", d = "text" + e[37].channel + " content svelte-16y0b84"), ti(s, "class", "linewrap svelte-16y0b84"), ti(i, "class", "line svelte-16y0b84"), this.first = i
            },
            m(t, e) {
                Y(t, i, e), G(i, s), G(s, n), G(n, a), G(s, r), G(r, l), G(l, o), G(r, c), m && m.m(r, null), p.m(s, null), u = !0
            },
            p(t, e) {
                (!u || 64 & e[0]) && $ !== ($ = t[37].time + "") && tn(a, $), (!u || 64 & e[0]) && h !== (h = t[37].channel + "") && tn(o, h), t[37].sender ? m ? (m.p(t, e), 64 & e[0] && tR(m, 1)) : ((m = fc(t)).c(), tR(m, 1), m.m(r, null)) : m && (tA(), tF(m, 1, 1, () => {
                    m = null
                }), t8()), (!u || 64 & e[0] && d !== (d = "text" + t[37].channel + " content svelte-16y0b84")) && ti(r, "class", d), f === (f = _(t)) && p ? p.p(t, e) : (p.d(1), (p = f(t)) && (p.c(), p.m(s, null)))
            },
            i(t) {
                u || (tR(m), u = !0)
            },
            o(t) {
                tF(m), u = !1
            },
            d(t) {
                t && Q(i), m && m.d(), p.d()
            }
        }
    }

    function fh(t) {
        let e, i, s, n, a, r, l = t[34] + "";

        function o(...e) {
            return t[16](t[34], ...e)
        }
        return {
            c() {
                e = J("div"), i = K("/"), s = K(l), ti(e, "class", n = "choice textsystem text" + t[34] + " svelte-16y0b84")
            },
            m(t, n) {
                Y(t, e, n), G(e, i), G(e, s), a || (r = te(e, "click", o), a = !0)
            },
            p(e, i) {
                t = e
            },
            d(t) {
                t && Q(e), a = !1, r()
            }
        }
    }

    function fm(t) {
        let e, i, s, n, a, r = t[31] + "";

        function l(...e) {
            return t[20](t[31], ...e)
        }
        return {
            c() {
                e = J("small"), i = K(r), ti(e, "class", s = "btn border black text" + (0 > t[5].indexOf(t[31]) ? t[31] : "grey") + " svelte-16y0b84")
            },
            m(t, s) {
                Y(t, e, s), G(e, i), n || (a = te(e, "click", l), n = !0)
            },
            p(i, n) {
                t = i, 32 & n[0] && s !== (s = "btn border black text" + (0 > t[5].indexOf(t[31]) ? t[31] : "grey") + " svelte-16y0b84") && ti(e, "class", s)
            },
            d(t) {
                t && Q(e), n = !1, a()
            }
        }
    }
    class f_ extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                var n;
                let a, r, l, o;
                N(e, eo, t => s(24, a = t)), N(e, ic, t => s(4, r = t)), N(e, iz, t => s(5, l = t));
                let c, d = !0;
                n = () => {
                    d = o && (o.offsetHeight + o.scrollTop > o.scrollHeight - 20 || 0 == o.scrollTop)
                }, tp().$$.before_update.push(n), tv(() => {
                    !1 !== d && o.scrollTo(0, o.scrollHeight)
                });
                let u = !1,
                    $ = [],
                    h = 0,
                    m = !1,
                    _ = "global",
                    f = new Map([
                        ["c", "clan"],
                        ["p", "party"],
                        ["g", "global"],
                        ["f", "faction"]
                    ]),
                    p = t => {
                        let e = t.match(/^\/[a-zA-Z0-9]+ /g);
                        if (e) {
                            let i = e[0].substring(1, e[0].length - 1);
                            if ("r" === i || "w" === i)
                                for (let n = a.length - 1; n > 0; --n) {
                                    let l = a[n];
                                    "from" == l.channel && (L(ic, r = l.sender), n = 0)
                                } else L(ic, r = f.has(i) ? f.get(i) : i);
                            s(1, c.value = t.substring(e[0].length), c)
                        }
                    },
                    g = t => lX[t] && lX[t].chat,
                    v = t => {
                        if (13 === t.keyCode) {
                            if (t.target == c) {
                                if ("" != t.target.value) {
                                    dY(41, 100);
                                    let e = t.target.value.match(/^\/[a-zA-Z0-9]+/g);
                                    e && (L(ic, r = e[0].substring(1)), s(1, c.value = "", c)), void 0 !== lQ[r] && lQ[r].client ? lQ[r].fun(c.value) : $1(r, c.value);
                                    let i = `/${r} ` + c.value;
                                    $[$.length - 1] != i && (h = $.push(i)), s(1, c.value = "", c), s(2, u = !1), c.blur()
                                } else g(r) || $1(r, c.value), s(2, u = !1), c.blur();
                                g(r) ? _ = r : L(ic, r = _)
                            } else document.activeElement == document.body && b()
                        } else(38 === t.keyCode || 40 === t.keyCode) && $.length ? t.target == c && (h += 38 === t.keyCode ? -1 : 1, h = aL(h, 0, $.length - 1), p($[h]), t.preventDefault()) : 27 === t.keyCode && (s(2, u = !1), c.blur())
                    },
                    y = t => {
                        c && c.focus()
                    },
                    b = t => {
                        t && L(ic, r = t), s(2, u = !0), (t2(), t3).then(y), dY(40, 100)
                    },
                    x = t => {
                        L(ic, r = t), s(3, m = !1), c && c.focus()
                    };
                tg(() => {
                    document.addEventListener("keydown", v)
                }), ty(() => {
                    document.removeEventListener("keydown", v), s(1, c = void 0)
                });
                let w = t => {
                        let e = l.indexOf(t);
                        iz.update(i => (e >= 0 ? i.splice(e, 1) : i.push(t), i))
                    },
                    k = (t, e) => {
                        let i = [{
                            name: e.sender,
                            css: "disabled"
                        }];
                        as.player.name !== e.sender && (e.faction != as.player.faction || as.party.has(e.sender) || i.push(_K.partyinvite(e.sender)), "to" !== e.channel && i.push(_K.report(e.sender, e.id, `Message: ${e.text.length>40?e.text.substring(0,37)+"...":e.text}`)), i.push({
                            name: "Whisper",
                            fun(t) {
                                b(e.sender)
                            }
                        })), et.set({
                            x: t.pageX,
                            y: t.pageY,
                            opts: i
                        }), t.preventDefault()
                    },
                    C = (t, e) => k(e, t),
                    S = (t, e) => {
                        b(t.sender)
                    },
                    E = (t, e) => x(t),
                    P = t => s(3, m = !m),
                    M = t => p(t.target.value),
                    D = (t, e) => w(t),
                    T;
                return e.$$.update = () => {
                    16777248 & e.$$.dirty[0] && s(6, T = a.filter(t => 0 > l.indexOf(t.channel)))
                }, [o, c, u, m, r, l, T, p, b, x, w, k, ["global", "faction", "party", "clan", "pvp", "inv"], C, S, function t(e) {
                    tw[e ? "unshift" : "push"](() => {
                        s(0, o = e)
                    })
                }, E, P, function t(e) {
                    tw[e ? "unshift" : "push"](() => {
                        s(1, c = e)
                    })
                }, M, D]
            }, function t(e) {
                let i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v = [],
                    y = new fa,
                    b = e[6],
                    x = t => t[37].key;
                for (let w = 0; w < b.length; w += 1) {
                    let k = fo(e, b, w),
                        C = x(k);
                    y.set(C, v[w] = f$(C, k))
                }
                let S = Object.keys(lQ),
                    E = [];
                for (let P = 0; P < S.length; P += 1) E[P] = fh(fl(e, S, P));
                let M = e[12],
                    T = [];
                for (let A = 0; A < M.length; A += 1) T[A] = fm(fr(e, M, A));
                return {
                    c() {
                        i = J("div"), s = J("section");
                        for (let t = 0; t < v.length; t += 1) v[t].c();
                        n = J("div"), a = J("section"), r = J("div"), l = J("div");
                        for (let f = 0; f < E.length; f += 1) E[f].c();
                        (o = J("div")).textContent = "/[playername]", c = J("div"), d = K(e[4]), $ = J("input"), m = J("div");
                        for (let p = 0; p < T.length; p += 1) T[p].c();
                        ti(s, "id", "chat"), ti(s, "class", "panel frame scrollbar svelte-16y0b84"), ti(o, "class", "choice textwhisper"), ti(l, "class", "panel context commandlist textsystem svelte-16y0b84"), tr(l, "display", e[3] ? "block" : "none"), ti(c, "class", u = "command btn black text" + (lX[e[4]] ? lX[e[4]].chat ? e[4] : "system" : "whisper") + " svelte-16y0b84"), ti($, "maxlength", "480"), ti($, "type", "text"), ti($, "class", "svelte-16y0b84"), ti(r, "id", "chatinput"), ti(r, "class", "inputcontainer panel-black border black svelte-16y0b84"), ti(a, "class", h = "chatsection " + (e[2] ? "" : "hidden") + " svelte-16y0b84"), ti(m, "class", _ = "channelselect " + (e[2] ? "hidden" : "") + " svelte-16y0b84"), ti(n, "class", "lowercontainer svelte-16y0b84"), ti(i, "class", "l-corner-ll container uiscaled svelte-16y0b84")
                    },
                    m(t, u) {
                        Y(t, i, u), G(i, s);
                        for (let h = 0; h < v.length; h += 1) v[h].m(s, null);
                        e[15](s), G(i, n), G(n, a), G(a, r), G(r, l);
                        for (let _ = 0; _ < E.length; _ += 1) E[_].m(l, null);
                        G(l, o), G(r, c), G(c, d), G(r, $), e[18]($), G(n, m);
                        for (let y = 0; y < T.length; y += 1) T[y].m(m, null);
                        f = !0, p || (g = [te(c, "click", e[17]), te($, "input", e[19])], p = !0)
                    },
                    p(t, e) {
                        if (2368 & e[0]) {
                            let i = t[6];
                            tA(), v = tL(v, e, x, 1, t, i, y, s, tO, f$, null, fo), t8()
                        }
                        if (512 & e[0]) {
                            let n;
                            for (S = Object.keys(lQ), n = 0; n < S.length; n += 1) {
                                let r = fl(t, S, n);
                                E[n] ? E[n].p(r, e) : (E[n] = fh(r), E[n].c(), E[n].m(l, o))
                            }
                            for (; n < E.length; n += 1) E[n].d(1);
                            E.length = S.length
                        }
                        if ((!f || 8 & e[0]) && tr(l, "display", t[3] ? "block" : "none"), (!f || 16 & e[0]) && tn(d, t[4]), (!f || 16 & e[0] && u !== (u = "command btn black text" + (lX[t[4]] ? lX[t[4]].chat ? t[4] : "system" : "whisper") + " svelte-16y0b84")) && ti(c, "class", u), (!f || 4 & e[0] && h !== (h = "chatsection " + (t[2] ? "" : "hidden") + " svelte-16y0b84")) && ti(a, "class", h), 5152 & e[0]) {
                            let $;
                            for (M = t[12], $ = 0; $ < M.length; $ += 1) {
                                let p = fr(t, M, $);
                                T[$] ? T[$].p(p, e) : (T[$] = fm(p), T[$].c(), T[$].m(m, null))
                            }
                            for (; $ < T.length; $ += 1) T[$].d(1);
                            T.length = M.length
                        }(!f || 4 & e[0] && _ !== (_ = "channelselect " + (t[2] ? "hidden" : "") + " svelte-16y0b84")) && ti(m, "class", _)
                    },
                    i(t) {
                        if (!f) {
                            for (let e = 0; e < b.length; e += 1) tR(v[e]);
                            f = !0
                        }
                    },
                    o(t) {
                        for (let e = 0; e < v.length; e += 1) tF(v[e]);
                        f = !1
                    },
                    d(t) {
                        t && Q(i);
                        for (let s = 0; s < v.length; s += 1) v[s].d();
                        e[15](null), X(E, t), e[18](null), X(T, t), p = !1, D(g)
                    }
                }
            }, A, {}, [-1, -1])
        }
    }

    function ff(t) {
        let e, i;
        return {
            c() {
                (e = J("img")).src !== (i = "/assets/ui/icons/" + t[1] + ".svg?v=5699699") && ti(e, "src", i), ti(e, "class", "titleicon svgicon svelte-yjs4p5")
            },
            m(t, i) {
                Y(t, e, i)
            },
            p(t, s) {
                2 & s && e.src !== (i = "/assets/ui/icons/" + t[1] + ".svg?v=5699699") && ti(e, "src", i)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function fp(t) {
        let e, i, s, n;
        return {
            c() {
                (e = J("img")).src !== (i = "/assets/ui/icons/cross.svg?v=5699699") && ti(e, "src", i), ti(e, "class", "btn black svgicon")
            },
            m(i, a) {
                Y(i, e, a), s || (n = te(e, "click", t[7]), s = !0)
            },
            p: C,
            d(t) {
                t && Q(e), s = !1, n()
            }
        }
    }
    class fg extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n = t0(),
                    {
                        title: a = "Title"
                    } = i,
                    {
                        icon: r
                    } = i,
                    {
                        close: l = !0
                    } = i,
                    {
                        scroll: o = !1
                    } = i,
                    {
                        $$slots: c = {},
                        $$scope: d
                    } = i,
                    u = () => n("close");
                return e.$$set = t => {
                    "title" in t && s(0, a = t.title), "icon" in t && s(1, r = t.icon), "close" in t && s(2, l = t.close), "scroll" in t && s(3, o = t.scroll), "$$scope" in t && s(5, d = t.$$scope)
                }, [a, r, l, o, n, d, c, u]
            }, function t(e) {
                let i, s, n, a, r, l, o, c, d = e[1] && ff(e),
                    u = e[2] && fp(e),
                    $ = e[6].default,
                    h = I($, e, e[5], null);
                return {
                    c() {
                        i = J("div"), s = J("div"), d && d.c(), n = J("div"), a = J("div"), r = K(e[0]), u && u.c(), l = J("div"), h && h.c(), ti(a, "name", "title"), ti(n, "class", "textprimary title svelte-yjs4p5"), ti(s, "class", "titleframe svelte-yjs4p5"), ti(l, "class", o = "slot " + (e[3] ? "scrollbar" : "") + " svelte-yjs4p5"), ti(i, "class", "window panel-black svelte-yjs4p5")
                    },
                    m(t, e) {
                        Y(t, i, e), G(i, s), d && d.m(s, null), G(s, n), G(n, a), G(a, r), u && u.m(s, null), G(i, l), h && h.m(l, null), c = !0
                    },
                    p(t, [e]) {
                        t[1] ? d ? d.p(t, e) : ((d = ff(t)).c(), d.m(s, n)) : d && (d.d(1), d = null), (!c || 1 & e) && tn(r, t[0]), t[2] ? u ? u.p(t, e) : ((u = fp(t)).c(), u.m(s, null)) : u && (u.d(1), u = null), h && h.p && 32 & e && z(h, $, t, t[5], e, null, null), (!c || 8 & e && o !== (o = "slot " + (t[3] ? "scrollbar" : "") + " svelte-yjs4p5")) && ti(l, "class", o)
                    },
                    i(t) {
                        c || (tR(h, t), c = !0)
                    },
                    o(t) {
                        tF(h, t), c = !1
                    },
                    d(t) {
                        t && Q(i), d && d.d(), u && u.d(), h && h.d(t)
                    }
                }
            }, A, {
                title: 0,
                icon: 1,
                close: 2,
                scroll: 3
            })
        }
    }

    function fv(t, e, i) {
        let s = t.slice();
        return s[4] = e[i], s[6] = i, s
    }

    function fy(t) {
        let e, i, s;
        return (i = new fg({
            props: {
                title: "Interaction",
                $$slots: {
                    default: [fb]
                },
                $$scope: {
                    ctx: t
                }
            }
        })).$on("close", t[3]), {
            c() {
                e = J("div"), tW(i.$$.fragment), ti(e, "class", "l-upperLeftModal container uiscaled svelte-uxs0uj")
            },
            m(t, n) {
                Y(t, e, n), tH(i, e, null), s = !0
            },
            p(t, e) {
                let s = {};
                129 & e && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }), i.$set(s)
            },
            i(t) {
                s || (tR(i.$$.fragment, t), s = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), s = !1
            },
            d(t) {
                t && Q(e), tj(i)
            }
        }
    }

    function f0(t) {
        let e, i, s, n, a, r = lc(t[4]) + "";

        function l(...e) {
            return t[2](t[6], ...e)
        }
        return {
            c() {
                e = J("div"), i = J("span"), ti(e, "class", "btn border black textgreen"), ti(e, "value", s = t[6])
            },
            m(t, s) {
                Y(t, e, s), G(e, i), i.innerHTML = r, n || (a = te(e, "click", l), n = !0)
            },
            p(e, s) {
                t = e, 1 & s && r !== (r = lc(t[4]) + "") && (i.innerHTML = r)
            },
            d(t) {
                t && Q(e), n = !1, a()
            }
        }
    }

    function fb(t) {
        let e, i, s, n, a, r = t[0].title + "",
            l = t[0].text + "",
            o = t[0].choices,
            c = [];
        for (let d = 0; d < o.length; d += 1) c[d] = f0(fv(t, o, d));
        return {
            c() {
                e = J("div"), i = J("h3"), s = K(r), n = J("p"), a = K(l);
                for (let t = 0; t < c.length; t += 1) c[t].c();
                ti(i, "class", "textprimary name svelte-uxs0uj"), ti(e, "class", "container svelte-uxs0uj")
            },
            m(t, r) {
                Y(t, e, r), G(e, i), G(i, s), G(e, n), G(n, a);
                for (let l = 0; l < c.length; l += 1) c[l].m(e, null)
            },
            p(t, i) {
                if (1 & i && r !== (r = t[0].title + "") && tn(s, r), 1 & i && l !== (l = t[0].text + "") && tn(a, l), 3 & i) {
                    let n;
                    for (o = t[0].choices, n = 0; n < o.length; n += 1) {
                        let d = fv(t, o, n);
                        c[n] ? c[n].p(d, i) : (c[n] = f0(d), c[n].c(), c[n].m(e, null))
                    }
                    for (; n < c.length; n += 1) c[n].d(1);
                    c.length = o.length
                }
            },
            d(t) {
                t && Q(e), X(c, t)
            }
        }
    }
    class fx extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n;

                function a(t) {
                    rp(aF.clientPlayerInteract.packData({
                        id: t
                    })), L(es, n = void 0)
                }
                N(e, es, t => s(0, n = t));
                let r = (t, e) => a(t),
                    l = () => {
                        L(es, n = void 0)
                    };
                return [n, a, r, l]
            }, function t(e) {
                let i, s, n = e[0] && fy(e);
                return {
                    c() {
                        n && n.c(), i = tt()
                    },
                    m(t, e) {
                        n && n.m(t, e), Y(t, i, e), s = !0
                    },
                    p(t, [e]) {
                        t[0] ? n ? (n.p(t, e), 1 & e && tR(n, 1)) : ((n = fy(t)).c(), tR(n, 1), n.m(i.parentNode, i)) : n && (tA(), tF(n, 1, 1, () => {
                            n = null
                        }), t8())
                    },
                    i(t) {
                        s || (tR(n), s = !0)
                    },
                    o(t) {
                        tF(n), s = !1
                    },
                    d(t) {
                        n && n.d(t), t && Q(i)
                    }
                }
            }, A, {})
        }
    }
    class fw extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let {
                    left: n = ""
                } = i, {
                    right: a = ""
                } = i, {
                    fract: r
                } = i, {
                    barcol: l
                } = i, {
                    size: o
                } = i, {
                    darken: c
                } = i, {
                    $$slots: d = {},
                    $$scope: u
                } = i;
                return e.$$set = t => {
                    "left" in t && s(0, n = t.left), "right" in t && s(1, a = t.right), "fract" in t && s(2, r = t.fract), "barcol" in t && s(3, l = t.barcol), "size" in t && s(4, o = t.size), "darken" in t && s(5, c = t.darken), "$$scope" in t && s(6, u = t.$$scope)
                }, [n, a, r, l, o, c, u, d]
            }, function t(e) {
                let i, s, n, a, r, l, o, c, d, u = e[7].default,
                    $ = I(u, e, e[6], null);
                return {
                    c() {
                        i = J("div"), s = J("div"), n = J("span"), a = K(e[0]), r = J("span"), l = K(e[1]), $ && $.c(), ti(n, "class", "left svelte-i7i7g5"), ti(r, "class", "right svelte-i7i7g5"), ti(s, "class", o = "progressBar " + e[3] + " svelte-i7i7g5"), tr(s, "width", e[2] + "%"), tr(s, "font-size", e[4]), ti(i, "class", c = "bar " + (e[5] ? "dark" : "") + " svelte-i7i7g5"), tr(i, "z-index", "hp" == e[3] ? "1" : "0")
                    },
                    m(t, e) {
                        Y(t, i, e), G(i, s), G(s, n), G(n, a), G(s, r), G(r, l), $ && $.m(i, null), d = !0
                    },
                    p(t, [e]) {
                        (!d || 1 & e) && tn(a, t[0]), (!d || 2 & e) && tn(l, t[1]), (!d || 8 & e && o !== (o = "progressBar " + t[3] + " svelte-i7i7g5")) && ti(s, "class", o), (!d || 4 & e) && tr(s, "width", t[2] + "%"), (!d || 16 & e) && tr(s, "font-size", t[4]), $ && $.p && 64 & e && z($, u, t, t[6], e, null, null), (!d || 32 & e && c !== (c = "bar " + (t[5] ? "dark" : "") + " svelte-i7i7g5")) && ti(i, "class", c), (!d || 8 & e) && tr(i, "z-index", "hp" == t[3] ? "1" : "0")
                    },
                    i(t) {
                        d || (tR($, t), d = !0)
                    },
                    o(t) {
                        tF($, t), d = !1
                    },
                    d(t) {
                        t && Q(i), $ && $.d(t)
                    }
                }
            }, R, {
                left: 0,
                right: 1,
                fract: 2,
                barcol: 3,
                size: 4,
                darken: 5
            })
        }
    }

    function f1(t) {
        let e, i, s = (t[4] > 99 ? Math.round(t[4] / 60) + "'" : Math.ceil(t[4])) + "";
        return {
            c() {
                e = J("div"), i = K(s), ti(e, "class", "time absCentered slottext svelte-1rfiesb")
            },
            m(t, s) {
                Y(t, e, s), G(e, i)
            },
            p(t, e) {
                16 & e && s !== (s = (t[4] > 99 ? Math.round(t[4] / 60) + "'" : Math.ceil(t[4])) + "") && tn(i, s)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function f9(t) {
        let e, i;
        return {
            c() {
                e = J("div"), i = K(t[0]), ti(e, "class", "stacks slottext svelte-1rfiesb")
            },
            m(t, s) {
                Y(t, e, s), G(e, i)
            },
            p(t, e) {
                1 & e && tn(i, t[0])
            },
            d(t) {
                t && Q(e)
            }
        }
    }
    class f3 extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, {
                        stacks: a
                    } = i,
                    {
                        duration: r
                    } = i,
                    {
                        time: l
                    } = i,
                    {
                        icon: o
                    } = i,
                    {
                        type: c
                    } = i,
                    {
                        size: d
                    } = i,
                    u = 0;
                return e.$$set = t => {
                    "stacks" in t && s(0, a = t.stacks), "duration" in t && s(6, r = t.duration), "time" in t && s(7, l = t.time), "icon" in t && s(1, o = t.icon), "type" in t && s(2, c = t.type), "size" in t && s(3, d = t.size)
                }, e.$$.update = () => {
                    232 & e.$$.dirty && (s(4, u = r - l), rM(Math.round(l / r * 100), n, d))
                }, [a, o, c, d, u, n, r, l, function t(e) {
                    tw[e ? "unshift" : "push"](() => {
                        s(5, n = e)
                    })
                }]
            }, function t(e) {
                let i, s, n, a, r, l, o, c = e[3] > 30 && sO.cdTextBuffs && e[4] > 0 && f1(e),
                    d = e[0] > 1 && f9(e);
                return {
                    c() {
                        i = J("div"), s = J("div"), c && c.c(), n = J("img"), r = J("div"), d && d.c(), ti(n, "class", "icon svelte-1rfiesb"), n.src !== (a = e[1]) && ti(n, "src", a), tr(n, "max-width", e[3] + "px"), ti(r, "class", "overlay svelte-1rfiesb"), ti(s, "class", l = "slot border " + (1 === e[2] ? "negative" : "positive") + " svelte-1rfiesb"), ti(i, "class", o = "container " + (e[4] < sO.buffCdFlashingDuration && e[4] % sO.buffCdFlashingInterval * 2 > sO.buffCdFlashingInterval ? "soon" : "") + " svelte-1rfiesb")
                    },
                    m(t, a) {
                        Y(t, i, a), G(i, s), c && c.m(s, null), G(s, n), G(s, r), e[8](r), d && d.m(s, null)
                    },
                    p(t, [e]) {
                        t[3] > 30 && sO.cdTextBuffs && t[4] > 0 ? c ? c.p(t, e) : ((c = f1(t)).c(), c.m(s, n)) : c && (c.d(1), c = null), 2 & e && n.src !== (a = t[1]) && ti(n, "src", a), 8 & e && tr(n, "max-width", t[3] + "px"), t[0] > 1 ? d ? d.p(t, e) : ((d = f9(t)).c(), d.m(s, null)) : d && (d.d(1), d = null), 4 & e && l !== (l = "slot border " + (1 === t[2] ? "negative" : "positive") + " svelte-1rfiesb") && ti(s, "class", l), 16 & e && o !== (o = "container " + (t[4] < sO.buffCdFlashingDuration && t[4] % sO.buffCdFlashingInterval * 2 > sO.buffCdFlashingInterval ? "soon" : "") + " svelte-1rfiesb") && ti(i, "class", o)
                    },
                    i: C,
                    o: C,
                    d(t) {
                        t && Q(i), c && c.d(), e[8](null), d && d.d()
                    }
                }
            }, R, {
                stacks: 0,
                duration: 6,
                time: 7,
                icon: 1,
                type: 2,
                size: 3
            })
        }
    }

    function fk(t, e, i) {
        let s = t.slice();
        return s[26] = e[i], s
    }

    function f2(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p = [],
            g = new Map,
            v = "default" == t[2] && f4();
        l = new fw({
            props: {
                size: "1.3em",
                fract: t[7],
                barcol: t[12],
                left: t[9],
                right: t[5],
                darken: !1,
                $$slots: {
                    default: [fS]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        let y = ("default" == t[2] || t[18]) && f7(t);

        function b(t, e) {
            return t[14].role >= 1 ? fP : f6
        }
        let x = b(t),
            w = x(t),
            k = "default" == t[2] && t[14].combat && t[14].alive && fM(),
            C = t[19],
            S = t => t[26].id;
        for (let E = 0; E < C.length; E += 1) {
            let P = fk(t, C, E),
                M = S(P);
            g.set(M, p[E] = f5(M, P))
        }
        return {
            c() {
                e = J("div"), i = J("div"), v && v.c(), s = J("img"), r = J("div"), tW(l.$$.fragment), y && y.c(), o = tt(), w.c(), c = tt(), k && k.c(), d = J("div");
                for (let m = 0; m < p.length; m += 1) p[m].c();
                ti(s, "class", n = "pclass icon border black bgc" + t[14].class + " svelte-mohsod"), s.src !== (a = (!1 !== t[14].powertype ? "/assets/ui/mobpower/" + t[14].powertype : "/assets/ui/classes/" + t[14].class) + "." + rR) && ti(s, "src", a), ti(i, "class", "iconcontainer svelte-mohsod"), ti(d, "class", u = "buffarray " + t[2] + " svelte-mohsod"), ti(r, "class", $ = "panel-black bars " + (t[17] && t[14].id == t[17].id && "party" == t[2] ? "target" : "") + " " + (t[14].id && t[14].range ? "targetable" : "") + " svelte-mohsod"), ti(e, "id", t[4]), ti(e, "class", h = "grid " + (t[3] ? "right" : "left") + " svelte-mohsod"), tr(e, "font-size", t[16] + "%"), tr(e, "opacity", t[14].range ? "" : .6)
            },
            m(n, a) {
                Y(n, e, a), G(e, i), v && v.m(i, null), G(i, s), G(e, r), tH(l, r, null), y && y.m(r, null), G(r, o), w.m(r, null), G(r, c), k && k.m(r, null), G(r, d);
                for (let u = 0; u < p.length; u += 1) p[u].m(d, null);
                m = !0, _ || (f = [te(e, "click", t[20]), te(e, "contextmenu", t[21])], _ = !0)
            },
            p(t, _) {
                "default" == t[2] ? v || ((v = f4()).c(), v.m(i, s)) : v && (v.d(1), v = null), (!m || 16384 & _ && n !== (n = "pclass icon border black bgc" + t[14].class + " svelte-mohsod")) && ti(s, "class", n), (!m || 16384 & _ && s.src !== (a = (!1 !== t[14].powertype ? "/assets/ui/mobpower/" + t[14].powertype : "/assets/ui/classes/" + t[14].class) + "." + rR)) && ti(s, "src", a);
                let f = {};
                if (128 & _ && (f.fract = t[7]), 4096 & _ && (f.barcol = t[12]), 512 & _ && (f.left = t[9]), 32 & _ && (f.right = t[5]), 536883332 & _ && (f.$$scope = {
                        dirty: _,
                        ctx: t
                    }), l.$set(f), "default" == t[2] || t[18] ? y ? (y.p(t, _), 262148 & _ && tR(y, 1)) : ((y = f7(t)).c(), tR(y, 1), y.m(r, o)) : y && (tA(), tF(y, 1, 1, () => {
                        y = null
                    }), t8()), x === (x = b(t)) && w ? w.p(t, _) : (w.d(1), (w = x(t)) && (w.c(), w.m(r, c))), "default" == t[2] && t[14].combat && t[14].alive ? k || ((k = fM()).c(), k.m(r, d)) : k && (k.d(1), k = null), 524292 & _) {
                    let C = t[19];
                    tA(), p = tL(p, _, S, 1, t, C, g, d, tO, f5, null, fk), t8()
                }(!m || 4 & _ && u !== (u = "buffarray " + t[2] + " svelte-mohsod")) && ti(d, "class", u), (!m || 147460 & _ && $ !== ($ = "panel-black bars " + (t[17] && t[14].id == t[17].id && "party" == t[2] ? "target" : "") + " " + (t[14].id && t[14].range ? "targetable" : "") + " svelte-mohsod")) && ti(r, "class", $), (!m || 16 & _) && ti(e, "id", t[4]), (!m || 8 & _ && h !== (h = "grid " + (t[3] ? "right" : "left") + " svelte-mohsod")) && ti(e, "class", h), (!m || 65536 & _) && tr(e, "font-size", t[16] + "%"), (!m || 16384 & _) && tr(e, "opacity", t[14].range ? "" : .6)
            },
            i(t) {
                if (!m) {
                    tR(l.$$.fragment, t), tR(y);
                    for (let e = 0; e < C.length; e += 1) tR(p[e]);
                    m = !0
                }
            },
            o(t) {
                tF(l.$$.fragment, t), tF(y);
                for (let e = 0; e < p.length; e += 1) tF(p[e]);
                m = !1
            },
            d(t) {
                t && Q(e), v && v.d(), tj(l), y && y.d(), w.d(), k && k.d();
                for (let i = 0; i < p.length; i += 1) p[i].d();
                _ = !1, D(f)
            }
        }
    }

    function f4(t) {
        let e;
        return {
            c() {
                ti(e = J("div"), "class", "deco svelte-mohsod")
            },
            m(t, i) {
                Y(t, e, i)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function fC(t) {
        let e, i, s;
        return {
            c() {
                ti(e = J("div"), "class", i = "progressBar " + t[12] + " hpdelta svelte-mohsod"), ti(e, "style", s = (t[13] ? "transition:none;" : "") + "width:" + t[7] + "%;")
            },
            m(t, i) {
                Y(t, e, i)
            },
            p(t, n) {
                4096 & n && i !== (i = "progressBar " + t[12] + " hpdelta svelte-mohsod") && ti(e, "class", i), 8320 & n && s !== (s = (t[13] ? "transition:none;" : "") + "width:" + t[7] + "%;") && ti(e, "style", s)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function fS(t) {
        let e, i = "default" == t[2] && fC(t);
        return {
            c() {
                i && i.c(), e = tt()
            },
            m(t, s) {
                i && i.m(t, s), Y(t, e, s)
            },
            p(t, s) {
                "default" == t[2] ? i ? i.p(t, s) : ((i = fC(t)).c(), i.m(e.parentNode, e)) : i && (i.d(1), i = null)
            },
            d(t) {
                i && i.d(t), t && Q(e)
            }
        }
    }

    function f7(t) {
        let e, i;
        return e = new fw({
            props: {
                size: "0.7em",
                fract: t[8],
                barcol: t[15],
                left: t[10],
                right: t[6],
                darken: !0,
                $$slots: {
                    default: [fE]
                },
                $$scope: {
                    ctx: t
                }
            }
        }), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            p(t, i) {
                let s = {};
                256 & i && (s.fract = t[8]), 32768 & i && (s.barcol = t[15]), 1024 & i && (s.left = t[10]), 64 & i && (s.right = t[6]), 536872960 & i && (s.$$scope = {
                    dirty: i,
                    ctx: t
                }), e.$set(s)
            },
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }

    function fE(t) {
        let e;
        return {
            c() {
                ti(e = J("div"), "class", "progressBar bgspell castbar svelte-mohsod"), tr(e, "width", t[11] + "%"), tr(e, "display", t[11] > 0 ? "inherit" : "none")
            },
            m(t, i) {
                Y(t, e, i)
            },
            p(t, i) {
                2048 & i && tr(e, "width", t[11] + "%"), 2048 & i && tr(e, "display", t[11] > 0 ? "inherit" : "none")
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function f6(t) {
        let e, i, s;
        return {
            c() {
                ti(e = J("img"), "class", i = "tag icon border black bgf" + t[14].faction + " round svelte-mohsod"), e.src !== (s = "/assets/ui/factions/" + t[14].faction + "." + rR) && ti(e, "src", s)
            },
            m(t, i) {
                Y(t, e, i)
            },
            p(t, n) {
                16384 & n && i !== (i = "tag icon border black bgf" + t[14].faction + " round svelte-mohsod") && ti(e, "class", i), 16384 & n && e.src !== (s = "/assets/ui/factions/" + t[14].faction + "." + rR) && ti(e, "src", s)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function fP(t) {
        let e, i;
        return {
            c() {
                ti(e = J("img"), "class", "tag icon border black bgblack round svelte-mohsod"), e.src !== (i = "/assets/ui/icons/" + (2 == t[14].role ? "star" : "starsilver") + "." + rR) && ti(e, "src", i)
            },
            m(t, i) {
                Y(t, e, i)
            },
            p(t, s) {
                16384 & s && e.src !== (i = "/assets/ui/icons/" + (2 == t[14].role ? "star" : "starsilver") + "." + rR) && ti(e, "src", i)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function fM(t) {
        let e;
        return {
            c() {
                ti(e = J("div"), "class", "tag icon border black round combat svelte-mohsod")
            },
            m(t, i) {
                Y(t, e, i)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function f5(t, e) {
        let i, s, n, a = [e[26], {
                size: "default" == e[2] ? 31 : 23
            }],
            r = {};
        for (let l = 0; l < a.length; l += 1) r = E(r, a[l]);
        return s = new f3({
            props: r
        }), {
            key: t,
            first: null,
            c() {
                i = tt(), tW(s.$$.fragment), this.first = i
            },
            m(t, e) {
                Y(t, i, e), tH(s, t, e), n = !0
            },
            p(t, e) {
                let i = 524292 & e ? tB(a, [524288 & e && tq(t[26]), 4 & e && {
                    size: "default" == t[2] ? 31 : 23
                }]) : {};
                s.$set(i)
            },
            i(t) {
                n || (tR(s.$$.fragment, t), n = !0)
            },
            o(t) {
                tF(s.$$.fragment, t), n = !1
            },
            d(t) {
                t && Q(i), tj(s, t)
            }
        }
    }
    class fD extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a, r, l, o = C,
                    c = () => (o(), o = F($, t => s(14, n = t)), $),
                    d = C,
                    u = () => (d(), d = F(h, t => s(19, l = t)), h);
                N(e, ed, t => s(17, a = t)), N(e, iJ, t => s(18, r = t)), e.$$.on_destroy.push(() => o()), e.$$.on_destroy.push(() => d());
                let {
                    unit: $
                } = i;
                c();
                let {
                    buffs: h
                } = i;
                u();
                let m, _, f, p, g, v, y, b, x, w, {
                        mode: k = "default"
                    } = i,
                    {
                        order: S = 0
                    } = i,
                    {
                        id: E = ""
                    } = i,
                    P = !1,
                    M = 0,
                    D = t => {
                        n.id && ub(n.id)
                    },
                    T = t => _Z(t, n),
                    A, R, I;
                return e.$$set = t => {
                    "unit" in t && c(s(0, $ = t.unit)), "buffs" in t && u(s(1, h = t.buffs)), "mode" in t && s(2, k = t.mode), "order" in t && s(3, S = t.order), "id" in t && s(4, E = t.id)
                }, e.$$.update = () => {
                    16384 & e.$$.dirty && s(25, A = n.world == as.id ? !n.alive && "Dead" : n.world), 37765124 & e.$$.dirty && (s(22, m = n.hpMax ? "default" == k ? rQ(n.hp) + "/" + rQ(n.hpMax) : rQ(n.hp) : "?"), s(5, f = A || m), s(7, g = "offline" != A ? ~~(n.hpMax ? n.hp / n.hpMax * 100 : 100) : 0), s(12, w = A ? "bggrey" : (as.mode.partyBasedHostility ? n.party === as.player.party : n.faction === as.player.faction) ? "bghealth" : "bgenemy")), 16388 & e.$$.dirty && s(23, _ = n.mpMax ? "default" == k ? rQ(n.mp) + "/" + rQ(n.mpMax) : rQ(n.mp) : "?"), 16384 & e.$$.dirty && s(9, y = n.name ? rJ(n.name, 10) : ""), 16384 & e.$$.dirty && s(10, b = n.timedSkill ? (rC.ui.hiddenskills[n.timedSkill.id] || rC.items.book[n.timedSkill.id]).name : "Lv. " + n.level), 41959424 & e.$$.dirty && s(6, p = A || (n.timedSkill ? n.timedCast.remaining(as.smoothtime).toFixed(1) : _)), 33570816 & e.$$.dirty && s(8, v = "offline" != A ? ~~(n.mpMax ? n.mp / n.mpMax * 100 : 100) : 0), 33570816 & e.$$.dirty && s(11, x = "offline" != A && n.timedSkill ? 100 * n.timedCast.fraction(as.smoothtime) : 0), 33554432 & e.$$.dirty && s(15, R = A ? "bggrey" : "bgmana"), 4 & e.$$.dirty && s(16, I = Math.round("default" == k ? 100 : 85)), 16793600 & e.$$.dirty && (s(13, P = M != n.id), s(24, M = n.id))
                }, [$, h, k, S, E, f, p, g, v, y, b, x, w, P, n, R, I, a, r, l, D, T]
            }, function t(e) {
                let i, s, n = e[14].visible && f2(e);
                return {
                    c() {
                        n && n.c(), i = tt()
                    },
                    m(t, e) {
                        n && n.m(t, e), Y(t, i, e), s = !0
                    },
                    p(t, [e]) {
                        t[14].visible ? n ? (n.p(t, e), 16384 & e && tR(n, 1)) : ((n = f2(t)).c(), tR(n, 1), n.m(i.parentNode, i)) : n && (tA(), tF(n, 1, 1, () => {
                            n = null
                        }), t8())
                    },
                    i(t) {
                        s || (tR(n), s = !0)
                    },
                    o(t) {
                        tF(n), s = !1
                    },
                    d(t) {
                        n && n.d(t), t && Q(i)
                    }
                }
            }, A, {
                unit: 0,
                buffs: 1,
                mode: 2,
                order: 3,
                id: 4
            })
        }
    }
    class fT extends tY {
        constructor(t) {
            super(), tG(this, t, null, function t(e) {
                let i, s, n, a;
                return s = new fD({
                    props: {
                        id: "ufplayer",
                        order: 0,
                        unit: ec,
                        buffs: e$
                    }
                }), n = new fD({
                    props: {
                        id: "uftarget",
                        order: 1,
                        unit: ed,
                        buffs: eu
                    }
                }), {
                    c() {
                        i = J("div"), tW(s.$$.fragment), tW(n.$$.fragment), ti(i, "class", "targetframes svelte-17up9g6")
                    },
                    m(t, e) {
                        Y(t, i, e), tH(s, i, null), tH(n, i, null), a = !0
                    },
                    p: C,
                    i(t) {
                        a || (tR(s.$$.fragment, t), tR(n.$$.fragment, t), a = !0)
                    },
                    o(t) {
                        tF(s.$$.fragment, t), tF(n.$$.fragment, t), a = !1
                    },
                    d(t) {
                        t && Q(i), tj(s), tj(n)
                    }
                }
            }, R, {})
        }
    }

    function fA(t) {
        let e, i;
        return {
            c() {
                e = J("span"), i = K(t[2]), ti(e, "class", "slottext key")
            },
            m(t, s) {
                Y(t, e, s), G(e, i)
            },
            p(t, e) {
                4 & e[0] && tn(i, t[2])
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function f8(t) {
        let e, i;
        return {
            c() {
                e = J("span"), i = K(t[3]), ti(e, "class", "slottext stacks")
            },
            m(t, s) {
                Y(t, e, s), G(e, i)
            },
            p(t, e) {
                8 & e[0] && tn(i, t[3])
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function fR(t) {
        let e, i, s = (t[5] > 99 ? Math.round(t[5] / 60) + "'" : t[5] <= 3 ? t[5].toFixed(1) : Math.ceil(t[5])) + "";
        return {
            c() {
                e = J("div"), i = K(s), ti(e, "class", "time absCentered slottext svelte-18ojcpo")
            },
            m(t, s) {
                Y(t, e, s), G(e, i)
            },
            p(t, e) {
                32 & e[0] && s !== (s = (t[5] > 99 ? Math.round(t[5] / 60) + "'" : t[5] <= 3 ? t[5].toFixed(1) : Math.ceil(t[5])) + "") && tn(i, s)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function fF(t) {
        let e;
        return {
            c() {
                ti(e = J("div"), "class", "autocast svelte-18ojcpo")
            },
            m(t, i) {
                Y(t, e, i)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function fN(t) {
        let e, i, s, n = t[30].default,
            a = I(n, t, t[29], null);
        return {
            c() {
                e = J("div"), a && a.c(), ti(e, "class", i = "border " + t[6] + " slotdescription svelte-18ojcpo"), ti(e, "style", t[10])
            },
            m(i, n) {
                Y(i, e, n), a && a.m(e, null), t[32](e), s = !0
            },
            p(t, r) {
                a && a.p && 536870912 & r[0] && z(a, n, t, t[29], r, null, null), (!s || 64 & r[0] && i !== (i = "border " + t[6] + " slotdescription svelte-18ojcpo")) && ti(e, "class", i), (!s || 1024 & r[0]) && ti(e, "style", t[10])
            },
            i(t) {
                s || (tR(a, t), s = !0)
            },
            o(t) {
                tF(a, t), s = !1
            },
            d(i) {
                i && Q(e), a && a.d(i), t[32](null)
            }
        }
    }
    class fI extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n;
                N(e, eh, t => s(16, n = t));
                let {
                    data: a
                } = i, {
                    key: r
                } = i, {
                    stacks: l
                } = i, {
                    cd: o
                } = i, {
                    remaining: c
                } = i, {
                    border: d = "grey"
                } = i, {
                    img: u
                } = i, {
                    meta: $
                } = i, {
                    css: h = ""
                } = i, {
                    id: m = ""
                } = i, {
                    describe: _ = !0
                } = i, {
                    queued: f = !1
                } = i, {
                    pickable: p = !0
                } = i, {
                    descRoot: g
                } = i, {
                    descPos: v = "bottom: 100%; right: 100%;"
                } = i, {
                    auto: y = !1
                } = i, {
                    status: b = 0
                } = i, {
                    hover: x = !1
                } = i, {
                    clickToUse: w = !1
                } = i, k = !1, C = (t, e) => t ? "queued" : 5 == e ? "oom" : 6 == e ? "range" : 11 == e || 9 == e ? "combat" : "hidden", S, E = t => {
                    !w || ob.shift.down || ob.ctrl.down ? (k = !0, A(!1), F("click", $)) : F("use", {
                        e: t,
                        ...$
                    })
                }, P = t => {
                    2 == t.button ? ob.shift.down || ob.ctrl.down ? F("use", {
                        e: t,
                        ...$
                    }) : F("context", {
                        e: t,
                        ...$
                    }) : n ? (n.data.type && lL(d7[n.data.type].sound), F("move", {
                        from: n.meta,
                        to: $
                    }), n.meta && n.meta.store && n.meta.store.set(), L(eh, n = void 0)) : (!w || ob.shift.down || ob.ctrl.down) && R(), k = !1
                }, M = t => {
                    A(!0)
                }, D = () => {
                    F("discard")
                }, T = t => {
                    A(!1), a && k && (k = !1, R())
                }, A = t => {
                    "force" !== x && s(0, x = t)
                }, R = () => {
                    a && !1 !== p && (a.moving || L(eh, n = {
                        data: a,
                        img: u,
                        meta: $,
                        border: d,
                        css: h,
                        discard: D
                    }), a.type && lL(d7[a.type].sound))
                }, F = t0(), I, U, z, O, {
                    $$slots: B = {},
                    $$scope: q
                } = i;
                return e.$$set = t => {
                    "data" in t && s(1, a = t.data), "key" in t && s(2, r = t.key), "stacks" in t && s(3, l = t.stacks), "cd" in t && s(4, o = t.cd), "remaining" in t && s(5, c = t.remaining), "border" in t && s(6, d = t.border), "img" in t && s(22, u = t.img), "meta" in t && s(23, $ = t.meta), "css" in t && s(7, h = t.css), "id" in t && s(8, m = t.id), "describe" in t && s(9, _ = t.describe), "queued" in t && s(24, f = t.queued), "pickable" in t && s(25, p = t.pickable), "descRoot" in t && s(26, g = t.descRoot), "descPos" in t && s(10, v = t.descPos), "auto" in t && s(11, y = t.auto), "status" in t && s(27, b = t.status), "hover" in t && s(0, x = t.hover), "clickToUse" in t && s(28, w = t.clickToUse), "$$scope" in t && s(29, q = t.$$scope)
                }, e.$$.update = () => {
                    16400 & e.$$.dirty[0] && s(14, U = U || o > 0), 138477585 & e.$$.dirty[0] && s(15, z = u ? n && x || o > 0 || -1 == b ? u.replace(".", "_grey.").replace(/_q[0-9]/g, "") : u : `/assets/ui/slotbg/bg.${rF}?v=5699699`), 150996992 & e.$$.dirty[0] && s(17, O = C(y || f, b)), 67112960 & e.$$.dirty[0] && S && g && g.appendChild(S), 8208 & e.$$.dirty[0] && rM(Math.floor(o || 0), I, 40)
                }, [x, a, r, l, o, c, d, h, m, _, v, y, S, I, U, z, n, O, E, P, M, T, u, $, f, p, g, b, w, q, B, function t(e) {
                    tw[e ? "unshift" : "push"](() => {
                        s(13, I = e)
                    })
                }, function t(e) {
                    tw[e ? "unshift" : "push"](() => {
                        s(12, S = e)
                    })
                }]
            }, function t(e) {
                let i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g = void 0 !== e[2] && fA(e),
                    v = void 0 !== e[3] && f8(e),
                    y = sO.cdTextSkills && void 0 !== e[5] && fR(e),
                    b = e[11] && fF(),
                    x = e[9] && e[0] && !e[16] && fN(e);
                return {
                    c() {
                        i = J("div"), g && g.c(), s = tt(), v && v.c(), n = tt(), y && y.c(), a = J("div"), l = J("div"), c = J("div"), b && b.c(), u = J("img"), x && x.c(), ti(a, "class", r = "overlay " + (void 0 !== e[4] ? "" : "hidden") + " svelte-18ojcpo"), ti(l, "class", o = "overlay " + e[17] + " svelte-18ojcpo"), ti(c, "class", d = "overlay " + (!e[14] || e[4] > 0 && e[4] < 10 ? "hidden" : "offCd") + " svelte-18ojcpo"), ti(u, "class", $ = "icon " + e[7] + " svelte-18ojcpo"), u.src !== (h = e[15]) && ti(u, "src", h), ti(i, "id", e[8]), ti(i, "class", m = "border " + e[6] + " " + (e[16] && e[16].data == e[1] ? "grey" : "") + " slot " + (e[1] ? "filled" : "") + " svelte-18ojcpo")
                    },
                    m(t, r) {
                        Y(t, i, r), g && g.m(i, null), G(i, s), v && v.m(i, null), G(i, n), y && y.m(i, null), G(i, a), e[31](a), G(i, l), G(i, c), b && b.m(i, null), G(i, u), x && x.m(i, null), _ = !0, f || (p = [te(i, "pointerenter", e[20]), te(i, "pointerleave", e[21]), te(i, "pointerdown", e[18]), te(i, "pointerup", e[19])], f = !0)
                    },
                    p(t, e) {
                        void 0 !== t[2] ? g ? g.p(t, e) : ((g = fA(t)).c(), g.m(i, s)) : g && (g.d(1), g = null), void 0 !== t[3] ? v ? v.p(t, e) : ((v = f8(t)).c(), v.m(i, n)) : v && (v.d(1), v = null), sO.cdTextSkills && void 0 !== t[5] ? y ? y.p(t, e) : ((y = fR(t)).c(), y.m(i, a)) : y && (y.d(1), y = null), (!_ || 16 & e[0] && r !== (r = "overlay " + (void 0 !== t[4] ? "" : "hidden") + " svelte-18ojcpo")) && ti(a, "class", r), (!_ || 131072 & e[0] && o !== (o = "overlay " + t[17] + " svelte-18ojcpo")) && ti(l, "class", o), (!_ || 16400 & e[0] && d !== (d = "overlay " + (!t[14] || t[4] > 0 && t[4] < 10 ? "hidden" : "offCd") + " svelte-18ojcpo")) && ti(c, "class", d), t[11] ? b || ((b = fF()).c(), b.m(i, u)) : b && (b.d(1), b = null), (!_ || 128 & e[0] && $ !== ($ = "icon " + t[7] + " svelte-18ojcpo")) && ti(u, "class", $), (!_ || 32768 & e[0] && u.src !== (h = t[15])) && ti(u, "src", h), t[9] && t[0] && !t[16] ? x ? (x.p(t, e), 66049 & e[0] && tR(x, 1)) : ((x = fN(t)).c(), tR(x, 1), x.m(i, null)) : x && (tA(), tF(x, 1, 1, () => {
                            x = null
                        }), t8()), (!_ || 256 & e[0]) && ti(i, "id", t[8]), (!_ || 65602 & e[0] && m !== (m = "border " + t[6] + " " + (t[16] && t[16].data == t[1] ? "grey" : "") + " slot " + (t[1] ? "filled" : "") + " svelte-18ojcpo")) && ti(i, "class", m)
                    },
                    i(t) {
                        _ || (tR(x), _ = !0)
                    },
                    o(t) {
                        tF(x), _ = !1
                    },
                    d(t) {
                        t && Q(i), g && g.d(), v && v.d(), y && y.d(), e[31](null), b && b.d(), x && x.d(), f = !1, D(p)
                    }
                }
            }, R, {
                data: 1,
                key: 2,
                stacks: 3,
                cd: 4,
                remaining: 5,
                border: 6,
                img: 22,
                meta: 23,
                css: 7,
                id: 8,
                describe: 9,
                queued: 24,
                pickable: 25,
                descRoot: 26,
                descPos: 10,
                auto: 11,
                status: 27,
                hover: 0,
                clickToUse: 28
            }, [-1, -1])
        }
    }
    let fU = (t, e) => "function" == typeof t ? t(e) : t,
        fz = ["onBlock", "statsStatic", "statsConvert", "statsOverride", "onInterval", "multiplyIncomingHeal", "multiplyIncomingDamage", "addIncomingHeal", "addIncomingDamage", "addIncomingCrit", "afterDamageEnemy", "afterHealAlly", "beforeDamageEnemy", "beforeIncomingDamage", "afterIncomingDamage", "movementOverride", "incapacitated", "breakOnMove", "breakOnCast", "instantCast", "onCast", "onEnd", "onAffectedEnemyDeath", "immuneAll", "immuneCC", "breakAfterPercentDamage"];
    class fO {
        constructor(t) {
            this.id = t.id, this.intervalHaste = !1 !== t.intervalHaste, this.intervalDuration = t.intervalDuration, this.intervalOnApply = t.intervalOnApply || !1, this.maxStacks = t.maxStacks, this.passive = t.passive || !1, this.clearOnDeath = !1 !== t.clearOnDeath, this.custom = t.custom, this.unique = t.unique || !1, this.dr = t.dr || 0, this.type = t.type || 0, this.tags = t.tags || new Set, this.immuneAll = t.immuneAll || !1, this.immuneCC = t.immuneCC || !1, fz.forEach(e => {
                this[e] = t[e]
            }), this.icon = t.icon, this.fx = t.fx || {}
        }
        onSet(t, e, i) {
            this.tags.forEach(e => {
                i.tags.get(e).add(t)
            }), fz.forEach(e => {
                this[e] && ("incapacitated" !== e && "movementOverride" !== e || i.immuneCC.size <= 0) && i[e].add(t)
            })
        }
        onRemove(t, e, i) {
            this.tags.forEach(e => {
                i.tags.get(e).delete(t)
            }), fz.forEach(e => {
                this[e] && i[e].delete(t)
            })
        }
    }
    let fL = new fO({
            id: 76,
            passive: !0,
            statsStatic(t, e) {
                e.addStat(12, Math.round(40 * t.level)), e.addStat(28, Math.round(200 * t.level))
            }
        }),
        fB = new fO({
            id: 58,
            icon: "skills/2",
            fx: {
                stick: 15
            },
            statsStatic(t, e) {
                e.addStat(13, 300 + 40 * t.level)
            }
        }),
        fq = (t, e) => t * e / 65535,
        fV = (t, e) => {
            let i = e / 65535;
            return [(t >>> 16) * i, (65535 & t) * i]
        },
        fW = t => t / 60,
        fH = (t, e) => {
            if (t.static || !e.data) return !1;
            let i = fV(2 * e.data[0], 6400),
                s = [i[0] - t.pos[0], i[1] - t.pos[2]];
            return nQ(s) > t.size ? (t.setSteer(0, 1), t.setRot(oo(s)), t.setJump(0), !0) : (t.setSteer(0, 0), !1)
        },
        fj = new fO({
            id: 86,
            incapacitated: !0,
            icon: "skills/33",
            fx: {
                stick: 74,
                endSound: 65
            },
            statsOverride(t, e) {
                e.stat.set(15, 250)
            },
            movementOverride(t, e, i, s, n) {
                fH(s, n) || s.buffs.removeBuff(n.id, s.id)
            }
        }),
        fG = new fO({
            id: 75,
            icon: "skills/20",
            fx: {
                stick: 53
            },
            unique: !0,
            statsStatic(t, e) {
                e.addStat(12, Math.round(30 * t.level)), e.addStat(9, Math.round(22 * t.level))
            }
        }),
        fY = new fO({
            id: 72,
            passive: !0,
            icon: "skills/17",
            custom: [
                [t => 93 + 32 * t, "% as additional damage over 10 seconds"]
            ],
            afterDamageEnemy: {
                3(t, e, i) {}
            }
        }),
        fQ = new fO({
            id: 73,
            type: 1,
            tags: new Set([1]),
            maxStacks: 3,
            icon: "skills/18",
            fx: {
                stick: 38,
                color: [.7, .1, .1, .5]
            },
            intervalDuration: 1.5,
            onInterval: (t, e, i) => ({
                id: 18,
                mode: 1,
                caster: t.caster,
                target: e.id,
                dmg: t.level * t.stacks,
                noDaze: !0,
                type: 1
            })
        }),
        fX = new fO({
            id: 71,
            icon: "skills/17",
            fx: {
                stick: 18,
                color: [.9, .3, .1, .7]
            },
            custom: [
                [t => 12 * t, "% increased damage"]
            ]
        }),
        fJ = new fO({
            id: 121,
            incapacitated: !0,
            type: 1,
            tags: new Set([7]),
            dr: 3,
            breakAfterPercentDamage: .1,
            icon: "skills/50",
            fx: {
                stick: 86,
                incapacitated: !0
            },
            statsOverride(t, e) {
                e.stat.get(15) > 100 && e.stat.set(15, 100)
            },
            movementOverride(t, e, i, s, n) {
                fH(s, n)
            },
            intervalDuration: 1
        }),
        fK = new fO({
            id: 60,
            passive: !0,
            icon: "skills/8",
            statsConvert: [
                [0, .3, 10],
                [0, .3, 11],
                [0, .3, 8]
            ]
        }),
        fZ = new fO({
            id: 88,
            type: 1,
            tags: new Set([3]),
            icon: "skills/34",
            statsStatic(t, e) {
                e.maxStat(29, 10 + 10 * t.level)
            }
        }),
        pt = new fO({
            id: 105,
            maxStacks: 3,
            icon: "skills/temperBoostBuff",
            fx: {
                stick: 24,
                color: [.2, .2, .25, .95]
            },
            statsStatic(t, e) {
                e.addStat(15, 20)
            }
        }),
        pe = new fO({
            id: 104,
            maxStacks: 3,
            tags: new Set([3, 4]),
            icon: "skills/41",
            fx: {
                stick: 23,
                color: [.1, .1, .1, .92]
            },
            intervalDuration: .5,
            onInterval: (t, e, i) => !0
        }),
        pi = new fO({
            id: 74,
            icon: "skills/19",
            fx: {
                stick: 54
            },
            unique: !0,
            statsStatic(t, e) {
                e.addStat(10, 3 * t.level), e.addStat(11, 4 * t.level), e.addStat(6, 50 * t.level)
            }
        }),
        ps = new fO({
            id: 115,
            incapacitated: !0,
            tags: new Set([8]),
            immuneCC: !0,
            icon: "skills/46",
            fx: {
                anim: 34
            },
            statsStatic(t, e) {
                e.maxStat(29, 40)
            },
            statsOverride(t, e) {
                e.stat.set(13, 0)
            },
            intervalDuration: .5,
            onInterval: (t, e, i) => !0
        }),
        pn = new fO({
            id: 90,
            type: 1,
            tags: new Set([6]),
            incapacitated: !0,
            dr: 3,
            icon: "skills/37",
            fx: {
                visual: 20,
                stick: 88,
                endSound: 69
            },
            statsStatic(t, e) {
                e.maxStat(29, 30 + 7 * t.level), e.maxStat(30, 20 + 5 * t.level)
            }
        }),
        pa = new fO({
            id: 83,
            icon: "skills/28",
            fx: {
                stick: 65
            },
            unique: !0,
            statsStatic(t, e) {
                e.addStat(16, 100 + 60 * t.level)
            }
        }),
        pr = new fO({
            id: 66,
            type: 1,
            tags: new Set([3, 1]),
            icon: "skills/12",
            fx: {
                apply: 50,
                stick: 49,
                color: [.5, .4, .05, .5]
            },
            statsStatic(t, e) {
                e.maxStat(29, 20 + 3 * t.level)
            },
            intervalDuration: 1.5,
            onInterval: (t, e, i) => ({
                id: 12,
                mode: 1,
                caster: t.caster,
                target: e.id,
                dmg: 1 + i.stats.getDamageRoll() * (.1 + .08 * t.level),
                type: 1,
                noDaze: !0
            })
        }),
        pl = new fO({
            id: 67,
            icon: "skills/13",
            fx: {
                stick: 52
            },
            intervalDuration: 1,
            custom: [
                [t => 30 + 40 * t, "MP recovered"]
            ],
            onInterval(t, e, i) {}
        }),
        po = new fO({
            id: 107,
            maxStacks: 5,
            icon: "skills/43",
            fx: {
                stick: 20
            }
        }),
        pc = new fO({
            id: 106,
            passive: !0
        }),
        pd = new fO({
            id: 59,
            maxStacks: 3,
            icon: "skills/7",
            fx: {
                stick: 37
            },
            intervalDuration: 1,
            multiplyIncomingHeal: {
                6: t => 1 + .3 * t.stacks,
                7: t => 1 + .3 * (t.stacks - 1)
            },
            onInterval: (t, e, i) => ({
                id: 7,
                mode: 2,
                caster: t.caster,
                target: e.id,
                heal: 6 + i.stats.getDamageRoll() * (.028 + .024 * t.level)
            })
        }),
        pu = new fO({
            id: 63,
            passive: !0,
            icon: "skills/8",
            statsConvert: [
                [4, .4, 10],
                [4, .4, 11]
            ]
        }),
        p$ = new fO({
            id: 89,
            breakOnCast: !0,
            icon: "skills/36",
            fx: {
                visual: 26,
                apply: 76,
                endSound: 69
            },
            statsStatic(t, e) {
                e.addStat(15, 8 + 12 * t.level)
            }
        }),
        ph = new fO({
            id: 119,
            incapacitated: !0,
            type: 1,
            tags: new Set([7]),
            dr: 3,
            breakAfterPercentDamage: .1,
            icon: "skills/49",
            fx: {
                incapacitated: !0,
                apply: 122,
                stick: 124
            },
            statsOverride(t, e) {
                e.stat.get(15) > 50 && e.stat.set(15, 50)
            },
            movementOverride(t, e, i, s, n) {
                fH(s, n)
            }
        }),
        pm = new fO({
            id: 120,
            passive: !0
        }),
        p_ = new fO({
            id: 81,
            passive: !0,
            statsStatic(t, e) {
                e.addStat(14, Math.round(30 * t.level))
            }
        }),
        pf = new fO({
            id: 65,
            icon: "skills/11",
            fx: {
                stick: 39,
                endSound: 69
            },
            custom: [
                [t => 9 * t, "% increased damage"]
            ]
        }),
        pp = new fO({
            id: 82,
            icon: "skills/27",
            fx: {
                stick: 63
            },
            unique: !0,
            statsStatic(t, e) {
                e.addStat(15, 5 + 13 * t.level)
            }
        }),
        pg = new fO({
            id: 84,
            passive: !0,
            icon: "skills/29",
            custom: [
                [t => 5 + 25 * t, "% per stack as additional damage over 10 seconds"]
            ],
            afterDamageEnemy: {
                9(t, e, i) {}
            }
        }),
        pv = new fO({
            id: 85,
            type: 1,
            maxStacks: 3,
            tags: new Set([3, 1]),
            icon: "skills/29",
            fx: {
                apply: 51,
                stick: 66,
                color: [.1, 1, .3, .3]
            },
            statsStatic(t, e) {
                e.maxStat(29, 30)
            },
            intervalDuration: 1.5,
            onInterval: (t, e, i) => ({
                id: 29,
                mode: 1,
                caster: t.caster,
                target: e.id,
                dmg: t.level * t.stacks,
                type: 1,
                noDaze: !0
            })
        }),
        py = new fO({
            id: 95,
            maxStacks: 4,
            icon: "skills/31",
            instantCast: new Set([31]),
            beforeDamageEnemy: {
                31(t, e, i, s) {}
            }
        }),
        p0 = new fO({
            id: 64,
            passive: !0,
            icon: "skills/10",
            custom: [
                [t => 2 + 1 * t, " Jumps"],
                [t => 15 + 12.5 * t, "% damage per Jump"]
            ],
            afterDamageEnemy: {
                9(t, e, i) {}
            }
        }),
        pb = new fO({
            id: 91,
            icon: "skills/38",
            fx: {
                stick: 77
            },
            statsStatic(t, e) {
                e.addStat(15, 30)
            },
            instantCast: new Set([9]),
            onCast: {
                9(t, e) {}
            }
        }),
        px = new fO({
            id: 96,
            passive: !1,
            incapacitated: !0,
            icon: "skills/38",
            statsOverride(t, e) {
                e.stat.set(15, 400)
            },
            movementOverride(t, e, i, s, n) {
                s.setSteer(n.data[0] - 1, n.data[1] - 1)
            }
        }),
        pw = new fO({
            id: 62,
            passive: !0,
            icon: "skills/8",
            statsConvert: [
                [2, .4, 10],
                [2, .4, 11]
            ]
        }),
        p1 = new fO({
            id: 80,
            icon: "skills/25",
            fx: {
                stick: 64
            },
            unique: !0,
            statsStatic(t, e) {
                e.addStat(16, 30 * t.level)
            }
        }),
        p9 = new fO({
            id: 118,
            passive: !0
        }),
        p3 = new fO({
            id: 114,
            incapacitated: !0,
            tags: new Set([8]),
            icon: "skills/45",
            fx: {
                anim: 33
            },
            intervalDuration: .2,
            statsStatic(t, e) {
                e.maxStat(29, 15)
            },
            onInterval: (t, e, i) => !0
        }),
        pk = new fO({
            id: 77,
            icon: "skills/22",
            fx: {
                stick: 60
            },
            unique: !0,
            statsStatic(t, e) {
                e.addStat(14, 30 * t.level)
            }
        }),
        p2 = new fO({
            id: 101,
            type: 1,
            tags: new Set([5]),
            incapacitated: !0,
            dr: 1,
            icon: "skills/deepFrozen",
            fx: {
                stick: 57,
                color: [.1, .9, .8, .9],
                frozen: !0
            },
            statsStatic(t, e) {
                e.maxStat(29, 100)
            },
            multiplyIncomingDamage: {
                4: t => 1 + .1 * t.level,
                15: t => 1 + .1 * t.level,
                51: t => 1 + .1 * t.level
            }
        }),
        p4 = new fO({
            id: 79,
            icon: "skills/24",
            fx: {
                stick: 91
            },
            unique: !0,
            statsStatic(t, e) {
                e.addStat(10, Math.floor(2 + 1.5 * t.level)), e.addStat(11, Math.floor(3 + 3.5 * t.level))
            }
        }),
        pC = new fO({
            id: 108,
            icon: "skills/extraBolt",
            fx: {
                stick: 22
            }
        }),
        pS = new fO({
            id: 116,
            incapacitated: !0,
            tags: new Set([8]),
            breakOnMove: !0,
            icon: "skills/52",
            fx: {
                anim: 35
            },
            intervalDuration: 1,
            intervalOnApply: 1,
            onInterval: (t, e, i) => !0
        }),
        p7 = new fO({
            id: 68,
            type: 1,
            tags: new Set([4]),
            dr: 2,
            icon: "skills/14",
            fx: {
                stick: 56,
                color: [.7, .7, 1, .4]
            },
            statsStatic(t, e) {
                e.maxStat(29, 100)
            },
            addIncomingCrit: {
                4: t => 10 + 30 * t.level,
                15: t => 20 + 30 * t.level
            },
            intervalDuration: 1.5,
            onInterval: (t, e, i) => ({
                id: 14,
                mode: 1,
                caster: t.caster,
                target: e.id,
                dmg: i.stats.getDamageRoll() * (.1 + .3 * t.level),
                type: 1,
                noDaze: !0
            })
        }),
        pE = new fO({
            id: 99,
            type: 1,
            tags: new Set([3]),
            maxStacks: 4,
            icon: "skills/frozenBuff",
            fx: {
                stick: 58,
                color: [.1, .1, .8, .5]
            },
            statsStatic(t, e) {
                e.maxStat(29, 20)
            }
        }),
        p6 = new fO({
            id: 70,
            icon: "skills/16",
            fx: {
                stick: 40,
                endSound: 69
            },
            statsStatic(t, e) {
                e.addStat(16, 30 + 70 * t.level), e.addStat(27, 2 + 8 * t.level)
            }
        }),
        pP = new fO({
            id: 117,
            incapacitated: !0,
            tags: new Set([9]),
            immuneAll: !0,
            intervalDuration: 1,
            intervalHaste: !1,
            icon: "skills/53",
            fx: {
                stick: 120,
                frozen: !0
            },
            statsStatic(t, e) {
                e.maxStat(29, 100)
            },
            onInterval: (t, e, i) => ({
                id: 53,
                mode: 2,
                caster: t.caster,
                target: i.id,
                heal: 50 * t.level,
                nocrit: !0
            })
        }),
        pM = new fO({
            id: 100,
            passive: !0
        }),
        p5 = new fO({
            id: 78,
            icon: "skills/23",
            fx: {
                stick: 17
            }
        }),
        pD = new fO({
            id: 69,
            passive: !0
        }),
        pT = new fO({
            id: 61,
            passive: !0,
            icon: "skills/8",
            statsConvert: [
                [3, .4, 10],
                [3, .4, 11]
            ]
        }),
        pA = new fO({
            id: 112,
            type: 0,
            icon: "skills/charm4",
            fx: {
                stick: 42,
                color: [0, 0, 1, .7]
            }
        }),
        p8 = new fO({
            id: 113,
            type: 1,
            tags: new Set([1]),
            maxStacks: 10,
            icon: "skills/firebuff",
            fx: {
                stick: 67,
                color: [2, 1, .3, 1]
            }
        }),
        pR = new fO({
            id: 124,
            type: 1,
            tags: new Set([1]),
            maxStacks: 5,
            icon: "skills/firebuff",
            fx: {
                stick: 132,
                apply: 135,
                color: [.7, .1, 1.5, 1]
            }
        }),
        pF = new fO({
            id: 93,
            type: 1,
            tags: new Set([3]),
            icon: "skills/dazedBuff",
            fx: {
                stick: 73
            },
            statsStatic(t, e) {
                e.maxStat(29, 30)
            }
        }),
        pN = new fO({
            id: 110,
            type: 0,
            icon: "skills/charm2",
            fx: {
                stick: 21,
                color: [1, 0, 0, .8]
            },
            statsStatic(t, e) {
                e.addStat(27, t.level)
            }
        }),
        pI = new fO({
            id: 109,
            type: 0,
            icon: "skills/charm1",
            fx: {
                stick: 61,
                color: [.3, .3, .3, .9]
            },
            beforeIncomingDamage: (t, e, i, s) => i * (t.level / 100)
        }),
        pU = new fO({
            id: 92,
            breakOnCast: !0,
            icon: "skills/39",
            fx: {
                mount: t => dO[t.data[0]].visual,
                mountVisualData: t => dO[t.data[0]].visualData,
                apply: 76,
                endSound: 69
            },
            statsStatic(t, e) {
                e.addStat(15, 60)
            }
        }),
        pz = new fO({
            id: 111,
            type: 0,
            icon: "skills/charm3",
            fx: {
                stick: 62,
                color: [.3, 0, .6, .8]
            },
            statsStatic(t, e) {
                e.addStat(15, t.level)
            }
        }),
        pO = new fO({
            id: 125,
            type: 0,
            maxStacks: 8,
            clearOnDeath: !1,
            icon: "skills/obeliskbuff"
        }),
        pL = new fO({
            id: 123,
            maxStacks: 25,
            type: 1,
            icon: "skills/pierce",
            multiplyIncomingDamage: {
                0: t => 1 + .2 * t.stacks,
                59: t => 1 + .2 * t.stacks
            }
        }),
        pB = new fO({
            id: 103,
            icon: "skills/postsummon",
            fx: {
                stick: 80
            },
            unique: !0,
            statsStatic(t, e) {
                e.addStat(15, 20)
            }
        }),
        pq = ["potionhp", "potionMp"].map((t, e) => new fO({
            id: [97, 98][e],
            maxStacks: 1,
            icon: "skills/" + t,
            fx: {
                stick: [43, 83][e]
            },
            intervalHaste: !1,
            intervalDuration: .5,
            onInterval: (t, i, s) => ({
                id: 100,
                mode: [2, 3][e],
                caster: t.caster,
                target: i.id,
                heal: 1 == e ? void 0 : t.level,
                mprec: 0 == e ? void 0 : t.level,
                nocrit: !0
            })
        })),
        pV = new fO({
            id: 94,
            passive: !0,
            immuneAll: !0,
            statsStatic(t, e) {
                e.addStat(15, 100), e.addStat(12, 1e4)
            }
        }),
        pW = new fO({
            id: 87,
            type: 1,
            tags: new Set([5]),
            dr: 1,
            incapacitated: !0,
            icon: "skills/stunBuff",
            fx: {
                stick: 86,
                incapacitated: !0
            },
            movementOverride(t, e, i, s, n) {
                s.setSteer(0, 0), s.setJump(0)
            }
        }),
        pH = new fO({
            id: 102,
            maxStacks: 99,
            icon: "skills/suddenDeath",
            statsStatic(t, e) {
                e.maxStat(30, t.stacks)
            }
        }),
        pj = {
            obeliskbuff: pO,
            boss_puddledotDebuff: pR,
            pierce: pL,
            worldBoss: new fO({
                id: 122,
                passive: !1,
                immuneCC: !0,
                icon: "skills/21",
                statsStatic(t, e) {
                    e.addStat(6, 5e5 * t.stacks), t.level > 1 && (e.addStat(17, 30), e.addStat(16, 1e3), e.addStat(15, 200), e.addStat(10, 500), e.addStat(11, 500))
                },
                onCast: {
                    0(t, e, i, s, n) {}
                }
            }),
            boss_flamepitDebuff: p8,
            blueMarble: pA,
            moveBoost: pz,
            dmgBoost: pN,
            incomingDmgReduce: pI,
            postsummon: pB,
            suddendeath: pH,
            hppotion: pq[0],
            mppotion: pq[1],
            stun: pW,
            mount: pU,
            daze: pF,
            resetting: pV
        },
        pG = new Map;
    [pj, {
        relentlessCryDebuff: fJ,
        whirlwindChannel: ps,
        temperBoostBuff: pt,
        temperBuff: pe,
        tauntDebuff: fZ,
        chargeBuff: fj,
        warcryBuff: pi,
        courageBuff: fG,
        armorreinforcementBuff: fL,
        crescentBleedDebuff: fQ,
        crescentBleedBuff: fY,
        enrageBuff: fX,
        blockBuff: fB,
        specializationWarrior: fK
    }, {
        plaguespreaderBuff: po,
        plaguespreaderBuffPassive: pc,
        agonizeDebuff: pn,
        spiritanimalBuff: p$,
        caninehowlBuff: pa,
        manaBuff: pl,
        revitalizeBuff: pd,
        specializationShaman: pu,
        decayBuff: pr
    }, {
        iceBlockBuff: pP,
        frostcallChannel: pS,
        extraboltBuff: pC,
        deepFrozenBuff: p2,
        iceboltBuff: pM,
        frozenBuff: pE,
        enchantmentBuff: p4,
        arcticauraBuff: pk,
        iceshieldBuff: p5,
        icicleBuff: pD,
        frostnovaBuff: p7,
        specializationMage: pT,
        hypothermicBuff: p6
    }, {
        boneArrowBuff: pm,
        blindingShotDebuff: ph,
        vampiricArrowBuff: p9,
        volleyChannel: p3,
        snipeMoveBuff: px,
        preciseshotBuff: py,
        snipeBuff: pb,
        poisonarrowsBuff: pg,
        poisonarrowsDebuff: pv,
        temporaldilationBuff: p1,
        pathfindingBuff: pp,
        cranialpuncturesBuff: p_,
        specializationArcher: pw,
        serpentArrowsBuff: p0,
        invigorateBuff: pf
    }].forEach(t => {
        for (let e in t) pG.set(t[e].id, t[e])
    });
    class pY {
        constructor(t) {
            this.entity = t, this.alive = !0, this.stat = new Map, this.resource = new Map, this.combatTimer = new aH(-1, 6)
        }
        tick(t, e) {
            this.combatTimer.start > 0 && this.combatTimer.done(e) && this.onCombatEnd(e)
        }
        die() {
            return !!this.alive && (this.alive = !1, this.entity.skills.onDeath(), this.entity.buffs.onDeath(), !0)
        }
        getStat(t) {
            return 0 | this.stat.get(t)
        }
        getResource(t) {
            return 0 | this.resource.get(t)
        }
        addStat(t, e) {
            this.stat.set(t, (0 | this.stat.get(t)) + e)
        }
        maxStat(t, e) {
            this.stat.set(t, Math.max(0 | this.stat.get(t), e))
        }
        multiplyStat(t, e) {
            this.stat.set(t, (0 | this.stat.get(t)) * e)
        }
        setResource(t, e) {
            let i = Math.round(aL(e, 0, this.getStat(t)));
            return this.resource.set(t, i), i
        }
        changeResource(t, e) {
            return this.setResource(t, this.getResource(t) + e)
        }
        respawn() {
            this.alive = !0, this.onCombatEnd()
        }
        clear() {}
        refreshCombatTimer(t, e) {
            this.combatTimer.end < t + e && this.combatTimer.reset(t, e)
        }
        onCombatEnd() {
            this.combatTimer.reset(-1)
        }
        getDamageRoll() {
            return Math.round((this.getStat(10) + this.getStat(11)) / 2)
        }
    }

    function pQ(t, e, i) {
        let s = t.slice();
        return s[13] = e[i], s
    }

    function pX(t, e, i) {
        let s = t.slice();
        return s[16] = e[i], s
    }

    function pJ(t, e, i) {
        let s = t.slice();
        return s[19] = e[i], s
    }

    function pK(t, e, i) {
        let s = t.slice();
        return s[19] = e[i], s
    }

    function pZ(t, e, i) {
        let s = t.slice();
        return s[27] = e[i], s
    }

    function gt(t, e, i) {
        let s = t.slice();
        return s[24] = e[i], s
    }

    function ge(t, e, i) {
        let s = t.slice();
        return s[27] = e[i], s
    }

    function gi(t, e, i) {
        let s = t.slice();
        return s[24] = e[i], s
    }

    function gs(t, e, i) {
        let s = t.slice();
        return s[27] = e[i], s
    }

    function gn(t, e, i) {
        let s = t.slice();
        return s[34] = e[i], s
    }

    function ga(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v, y, b, x, w, k = !t[2] && void 0 === t[0].parent && gl(t),
            C = t[0].actiontype && go(t),
            S = t[0].auto && gc(),
            E = t[0].costMp && gd(t),
            P = t[0].castLen && gu(t),
            M = t[0].cd && g$(t),
            D = t[0].duration > 0 && gh(t),
            T = t[0].unique && gm(),
            A = t[0].refresh && g_(),
            R = t[0].range && gf(t),
            F = t[7][t[0].targetMode] && gp(t),
            N = t[0].maxStacks && gg(t),
            I = t[0].dmg && gv(t),
            U = t[0].heal && gy(t),
            z = [t[0].multiplyIncomingHeal, t[0].multiplyIncomingDamage],
            O = [];
        for (let L = 0; L < 2; L += 1) O[L] = gb(gn(t, z, L));
        let B = [t[0].addIncomingHeal, t[0].addIncomingDamage],
            q = [];
        for (let V = 0; V < 2; V += 1) q[V] = gw(gi(t, B, V));
        let W = [t[0].addIncomingCrit],
            H = [];
        for (let j = 0; j < 1; j += 1) H[j] = g9(gt(t, W, j));
        let K = t[0].statsStatic && g3(t),
            Z = t[0].statsConvert && g2(t),
            te = t[0].custom && gC(t),
            ts = t[0].aoe && t[0].aoe.circleRadius && g7(t),
            tn = !t[0].parent && gE(t),
            ta = t[3],
            tr = [];
        for (let tl = 0; tl < ta.length; tl += 1) tr[tl] = g6(pQ(t, ta, tl));
        let to = t => tF(tr[t], 1, 1, () => {
            tr[t] = null
        });
        return {
            c() {
                k && k.c(), e = J("div"), C && C.c(), i = tt(), S && S.c(), s = tt(), E && E.c(), n = tt(), P && P.c(), a = tt(), M && M.c(), r = tt(), D && D.c(), l = tt(), T && T.c(), o = tt(), A && A.c(), c = J("div"), R && R.c(), d = tt(), F && F.c(), N && N.c(), u = tt(), I && I.c(), $ = tt(), U && U.c(), h = tt();
                for (let t = 0; t < 2; t += 1) O[t].c();
                m = tt();
                for (let w = 0; w < 2; w += 1) q[w].c();
                _ = tt();
                for (let z = 0; z < 1; z += 1) H[z].c();
                f = tt(), K && K.c(), p = tt(), Z && Z.c(), g = tt(), te && te.c(), v = tt(), ts && ts.c(), y = tt(), tn && tn.c(), b = tt();
                for (let L = 0; L < tr.length; L += 1) tr[L].c();
                x = tt(), ti(e, "class", "pad textgreen svelte-14w0l4b")
            },
            m(t, z) {
                k && k.m(t, z), Y(t, e, z), C && C.m(e, null), G(e, i), S && S.m(e, null), G(e, s), E && E.m(e, null), G(e, n), P && P.m(e, null), G(e, a), M && M.m(e, null), G(e, r), D && D.m(e, null), G(e, l), T && T.m(e, null), G(e, o), A && A.m(e, null), G(e, c), R && R.m(c, null), G(c, d), F && F.m(c, null), N && N.m(t, z), Y(t, u, z), I && I.m(t, z), Y(t, $, z), U && U.m(t, z), Y(t, h, z);
                for (let L = 0; L < 2; L += 1) O[L].m(t, z);
                Y(t, m, z);
                for (let B = 0; B < 2; B += 1) q[B].m(t, z);
                Y(t, _, z);
                for (let V = 0; V < 1; V += 1) H[V].m(t, z);
                Y(t, f, z), K && K.m(t, z), Y(t, p, z), Z && Z.m(t, z), Y(t, g, z), te && te.m(t, z), Y(t, v, z), ts && ts.m(t, z), Y(t, y, z), tn && tn.m(t, z), Y(t, b, z);
                for (let W = 0; W < tr.length; W += 1) tr[W].m(t, z);
                Y(t, x, z), w = !0
            },
            p(t, w) {
                if (t[2] || void 0 !== t[0].parent ? k && (k.d(1), k = null) : k ? k.p(t, w) : ((k = gl(t)).c(), k.m(e.parentNode, e)), t[0].actiontype ? C ? C.p(t, w) : ((C = go(t)).c(), C.m(e, i)) : C && (C.d(1), C = null), t[0].auto ? S || ((S = gc()).c(), S.m(e, s)) : S && (S.d(1), S = null), t[0].costMp ? E ? E.p(t, w) : ((E = gd(t)).c(), E.m(e, n)) : E && (E.d(1), E = null), t[0].castLen ? P ? P.p(t, w) : ((P = gu(t)).c(), P.m(e, a)) : P && (P.d(1), P = null), t[0].cd ? M ? M.p(t, w) : ((M = g$(t)).c(), M.m(e, r)) : M && (M.d(1), M = null), t[0].duration > 0 ? D ? D.p(t, w) : ((D = gh(t)).c(), D.m(e, l)) : D && (D.d(1), D = null), t[0].unique ? T || ((T = gm()).c(), T.m(e, o)) : T && (T.d(1), T = null), t[0].refresh ? A || ((A = g_()).c(), A.m(e, c)) : A && (A.d(1), A = null), t[0].range ? R ? R.p(t, w) : ((R = gf(t)).c(), R.m(c, d)) : R && (R.d(1), R = null), t[7][t[0].targetMode] ? F ? F.p(t, w) : ((F = gp(t)).c(), F.m(c, null)) : F && (F.d(1), F = null), t[0].maxStacks ? N ? N.p(t, w) : ((N = gg(t)).c(), N.m(u.parentNode, u)) : N && (N.d(1), N = null), t[0].dmg ? I ? I.p(t, w) : ((I = gv(t)).c(), I.m($.parentNode, $)) : I && (I.d(1), I = null), t[0].heal ? U ? U.p(t, w) : ((U = gy(t)).c(), U.m(h.parentNode, h)) : U && (U.d(1), U = null), 257 & w[0]) {
                    let L;
                    for (z = [t[0].multiplyIncomingHeal, t[0].multiplyIncomingDamage], L = 0; L < 2; L += 1) {
                        let V = gn(t, z, L);
                        O[L] ? O[L].p(V, w) : (O[L] = gb(V), O[L].c(), O[L].m(m.parentNode, m))
                    }
                    for (; L < 2; L += 1) O[L].d(1)
                }
                if (257 & w[0]) {
                    let j;
                    for (B = [t[0].addIncomingHeal, t[0].addIncomingDamage], j = 0; j < 2; j += 1) {
                        let G = gi(t, B, j);
                        q[j] ? q[j].p(G, w) : (q[j] = gw(G), q[j].c(), q[j].m(_.parentNode, _))
                    }
                    for (; j < 2; j += 1) q[j].d(1)
                }
                if (257 & w[0]) {
                    let Y;
                    for (W = [t[0].addIncomingCrit], Y = 0; Y < 1; Y += 1) {
                        let Q = gt(t, W, Y);
                        H[Y] ? H[Y].p(Q, w) : (H[Y] = g9(Q), H[Y].c(), H[Y].m(f.parentNode, f))
                    }
                    for (; Y < 1; Y += 1) H[Y].d(1)
                }
                if (t[0].statsStatic ? K ? K.p(t, w) : ((K = g3(t)).c(), K.m(p.parentNode, p)) : K && (K.d(1), K = null), t[0].statsConvert ? Z ? Z.p(t, w) : ((Z = g2(t)).c(), Z.m(g.parentNode, g)) : Z && (Z.d(1), Z = null), t[0].custom ? te ? te.p(t, w) : ((te = gC(t)).c(), te.m(v.parentNode, v)) : te && (te.d(1), te = null), t[0].aoe && t[0].aoe.circleRadius ? ts ? ts.p(t, w) : ((ts = g7(t)).c(), ts.m(y.parentNode, y)) : ts && (ts.d(1), ts = null), t[0].parent ? tn && (tn.d(1), tn = null) : tn ? tn.p(t, w) : ((tn = gE(t)).c(), tn.m(b.parentNode, b)), 10 & w[0]) {
                    let X;
                    for (ta = t[3], X = 0; X < ta.length; X += 1) {
                        let J = pQ(t, ta, X);
                        tr[X] ? (tr[X].p(J, w), tR(tr[X], 1)) : (tr[X] = g6(J), tr[X].c(), tR(tr[X], 1), tr[X].m(x.parentNode, x))
                    }
                    for (tA(), X = ta.length; X < tr.length; X += 1) to(X);
                    t8()
                }
            },
            i(t) {
                if (!w) {
                    for (let e = 0; e < ta.length; e += 1) tR(tr[e]);
                    w = !0
                }
            },
            o(t) {
                tr = tr.filter(Boolean);
                for (let e = 0; e < tr.length; e += 1) tF(tr[e]);
                w = !1
            },
            d(t) {
                k && k.d(t), t && Q(e), C && C.d(), S && S.d(), E && E.d(), P && P.d(), M && M.d(), D && D.d(), T && T.d(), A && A.d(), R && R.d(), F && F.d(), N && N.d(t), t && Q(u), I && I.d(t), t && Q($), U && U.d(t), t && Q(h), X(O, t), t && Q(m), X(q, t), t && Q(_), X(H, t), t && Q(f), K && K.d(t), t && Q(p), Z && Z.d(t), t && Q(g), te && te.d(t), t && Q(v), ts && ts.d(t), t && Q(y), tn && tn.d(t), t && Q(b), X(tr, t), t && Q(x)
            }
        }
    }

    function gr(t) {
        let e, i, s = t[0].item + "";
        return {
            c() {
                e = J("div"), i = K(s)
            },
            m(t, s) {
                Y(t, e, s), G(e, i)
            },
            p(t, e) {
                1 & e[0] && s !== (s = t[0].item + "") && tn(i, s)
            },
            i: C,
            o: C,
            d(t) {
                t && Q(e)
            }
        }
    }

    function gl(t) {
        let e, i, s, n, a, r, l = rC.items.book[t[0].id].name + "",
            o = t[0].engineOnly ? "" : " Lv. " + t[1];
        return {
            c() {
                e = J("div"), i = J("img"), n = Z(), a = K(l), r = K(o), ti(i, "class", "texticon"), i.src !== (s = rz(t[0].id)) && ti(i, "src", s), ti(e, "class", "slottitle textprimary")
            },
            m(t, s) {
                Y(t, e, s), G(e, i), G(e, n), G(e, a), G(e, r)
            },
            p(t, e) {
                1 & e[0] && i.src !== (s = rz(t[0].id)) && ti(i, "src", s), 1 & e[0] && l !== (l = rC.items.book[t[0].id].name + "") && tn(a, l), 3 & e[0] && o !== (o = t[0].engineOnly ? "" : " Lv. " + t[1]) && tn(r, o)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function go(t) {
        let e, i, s, n, a = t[9][t[0].mode] + "",
            r = t[0].actiontype + "";
        return {
            c() {
                e = J("div"), i = K(a), s = Z(), n = K(r), ti(e, "class", "textwhite")
            },
            m(t, a) {
                Y(t, e, a), G(e, i), G(e, s), G(e, n)
            },
            p(t, e) {
                1 & e[0] && a !== (a = t[9][t[0].mode] + "") && tn(i, a), 1 & e[0] && r !== (r = t[0].actiontype + "") && tn(n, r)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function gc(t) {
        let e;
        return {
            c() {
                (e = J("div")).textContent = "Auto cast"
            },
            m(t, i) {
                Y(t, e, i)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function gd(t) {
        let e, i, s, n, a, r = t[0].costMp(t[1]) + "",
            l = rC.ui.stats.array[7] + "";
        return {
            c() {
                e = J("div"), i = K("Cost: "), s = K(r), n = Z(), a = K(l)
            },
            m(t, r) {
                Y(t, e, r), G(e, i), G(e, s), G(e, n), G(e, a)
            },
            p(t, e) {
                3 & e[0] && r !== (r = t[0].costMp(t[1]) + "") && tn(s, r)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function gu(t) {
        let e, i, s, n = t[8](t[0].castLen) + "";
        return {
            c() {
                e = J("div"), i = K(n), s = K("s Cast time")
            },
            m(t, n) {
                Y(t, e, n), G(e, i), G(e, s)
            },
            p(t, e) {
                1 & e[0] && n !== (n = t[8](t[0].castLen) + "") && tn(i, n)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function g$(t) {
        let e, i, s, n = t[8](t[0].cd) + "";
        return {
            c() {
                e = J("div"), i = K(n), s = K("s Cooldown")
            },
            m(t, n) {
                Y(t, e, n), G(e, i), G(e, s)
            },
            p(t, e) {
                1 & e[0] && n !== (n = t[8](t[0].cd) + "") && tn(i, n)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function gh(t) {
        let e, i, s, n = t[8](t[0].duration) + "";
        return {
            c() {
                e = J("div"), i = K(n), s = K("s Duration")
            },
            m(t, n) {
                Y(t, e, n), G(e, i), G(e, s)
            },
            p(t, e) {
                1 & e[0] && n !== (n = t[8](t[0].duration) + "") && tn(i, n)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function gm(t) {
        let e;
        return {
            c() {
                (e = J("div")).textContent = "Unique"
            },
            m(t, i) {
                Y(t, e, i)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function g_(t) {
        let e;
        return {
            c() {
                (e = J("div")).textContent = "Stacks refresh duration"
            },
            m(t, i) {
                Y(t, e, i)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function gf(t) {
        let e, i, s, n = t[8](t[0].range) + "";
        return {
            c() {
                e = J("span"), i = K(n), s = K("m range ")
            },
            m(t, n) {
                Y(t, e, n), G(e, i), G(e, s)
            },
            p(t, e) {
                1 & e[0] && n !== (n = t[8](t[0].range) + "") && tn(i, n)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function gp(t) {
        let e, i, s = t[7][t[0].targetMode] + "";
        return {
            c() {
                e = J("span"), i = K(s)
            },
            m(t, s) {
                Y(t, e, s), G(e, i)
            },
            p(t, e) {
                1 & e[0] && s !== (s = t[7][t[0].targetMode] + "") && tn(i, s)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function gg(t) {
        let e, i, s, n, a, r, l, o = t[5].stacks + "";
        return {
            c() {
                e = J("div"), i = J("u"), s = K("At "), n = K(o), a = K(" stacks"), r = K(":"), (l = J("span")).textContent = "(Press shift to toggle)", ti(e, "class", "pad textsecondary svelte-14w0l4b"), ti(l, "class", "textgrey")
            },
            m(t, o) {
                Y(t, e, o), G(e, i), G(i, s), G(i, n), G(i, a), G(e, r), Y(t, l, o)
            },
            p(t, e) {
                32 & e[0] && o !== (o = t[5].stacks + "") && tn(n, o)
            },
            d(t) {
                t && Q(e), t && Q(l)
            }
        }
    }

    function gv(t) {
        let e, i, s, n = t[8](t[0].dmg) + "";
        return {
            c() {
                e = J("div"), i = K(n), s = K(" DMG"), ti(e, "class", "textgreen")
            },
            m(t, n) {
                Y(t, e, n), G(e, i), G(e, s)
            },
            p(t, e) {
                1 & e[0] && n !== (n = t[8](t[0].dmg) + "") && tn(i, n)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function gy(t) {
        let e, i, s, n = t[8](t[0].heal) + "";
        return {
            c() {
                e = J("div"), i = K(n), s = K(" Heal"), ti(e, "class", "textgreen")
            },
            m(t, n) {
                Y(t, e, n), G(e, i), G(e, s)
            },
            p(t, e) {
                1 & e[0] && n !== (n = t[8](t[0].heal) + "") && tn(i, n)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function g0(t) {
        let e, i, s, n, a, r, l = rC.items.book[t[27]].name + "",
            o = Math.round(100 * t[8](t[34][t[27]](t[0])) - 100) + "";
        return {
            c() {
                e = J("div"), i = K("Empower "), s = K(l), n = K(" by "), a = K(o), r = K("%"), ti(e, "class", "textcyan")
            },
            m(t, l) {
                Y(t, e, l), G(e, i), G(e, s), G(e, n), G(e, a), G(e, r)
            },
            p(t, e) {
                1 & e[0] && l !== (l = rC.items.book[t[27]].name + "") && tn(s, l), 1 & e[0] && o !== (o = Math.round(100 * t[8](t[34][t[27]](t[0])) - 100) + "") && tn(a, o)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function gb(t) {
        let e, i = Object.keys(t[34] || {}),
            s = [];
        for (let n = 0; n < i.length; n += 1) s[n] = g0(gs(t, i, n));
        return {
            c() {
                for (let t = 0; t < s.length; t += 1) s[t].c();
                e = tt()
            },
            m(t, i) {
                for (let n = 0; n < s.length; n += 1) s[n].m(t, i);
                Y(t, e, i)
            },
            p(t, n) {
                if (257 & n[0]) {
                    let a;
                    for (i = Object.keys(t[34] || {}), a = 0; a < i.length; a += 1) {
                        let r = gs(t, i, a);
                        s[a] ? s[a].p(r, n) : (s[a] = g0(r), s[a].c(), s[a].m(e.parentNode, e))
                    }
                    for (; a < s.length; a += 1) s[a].d(1);
                    s.length = i.length
                }
            },
            d(t) {
                X(s, t), t && Q(e)
            }
        }
    }

    function gx(t) {
        let e, i, s, n, a, r = rC.items.book[t[27]].name + "",
            l = t[8](t[24][t[27]](t[0])) + "";
        return {
            c() {
                e = J("div"), i = K("Empower "), s = K(r), n = K(" by "), a = K(l), ti(e, "class", "textcyan")
            },
            m(t, r) {
                Y(t, e, r), G(e, i), G(e, s), G(e, n), G(e, a)
            },
            p(t, e) {
                1 & e[0] && r !== (r = rC.items.book[t[27]].name + "") && tn(s, r), 1 & e[0] && l !== (l = t[8](t[24][t[27]](t[0])) + "") && tn(a, l)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function gw(t) {
        let e, i = Object.keys(t[24] || {}),
            s = [];
        for (let n = 0; n < i.length; n += 1) s[n] = gx(ge(t, i, n));
        return {
            c() {
                for (let t = 0; t < s.length; t += 1) s[t].c();
                e = tt()
            },
            m(t, i) {
                for (let n = 0; n < s.length; n += 1) s[n].m(t, i);
                Y(t, e, i)
            },
            p(t, n) {
                if (257 & n[0]) {
                    let a;
                    for (i = Object.keys(t[24] || {}), a = 0; a < i.length; a += 1) {
                        let r = ge(t, i, a);
                        s[a] ? s[a].p(r, n) : (s[a] = gx(r), s[a].c(), s[a].m(e.parentNode, e))
                    }
                    for (; a < s.length; a += 1) s[a].d(1);
                    s.length = i.length
                }
            },
            d(t) {
                X(s, t), t && Q(e)
            }
        }
    }

    function g1(t) {
        let e, i, s, n, a, r = rC.items.book[t[27]].name + "",
            l = lt(14, t[8](t[24][t[27]](t[0]))) + "";
        return {
            c() {
                e = J("div"), i = K("Empower Crit% of "), s = K(r), n = K(" by "), a = K(l), ti(e, "class", "textcyan")
            },
            m(t, r) {
                Y(t, e, r), G(e, i), G(e, s), G(e, n), G(e, a)
            },
            p(t, e) {
                1 & e[0] && r !== (r = rC.items.book[t[27]].name + "") && tn(s, r), 1 & e[0] && l !== (l = lt(14, t[8](t[24][t[27]](t[0]))) + "") && tn(a, l)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function g9(t) {
        let e, i = Object.keys(t[24] || {}),
            s = [];
        for (let n = 0; n < i.length; n += 1) s[n] = g1(pZ(t, i, n));
        return {
            c() {
                for (let t = 0; t < s.length; t += 1) s[t].c();
                e = tt()
            },
            m(t, i) {
                for (let n = 0; n < s.length; n += 1) s[n].m(t, i);
                Y(t, e, i)
            },
            p(t, n) {
                if (257 & n[0]) {
                    let a;
                    for (i = Object.keys(t[24] || {}), a = 0; a < i.length; a += 1) {
                        let r = pZ(t, i, a);
                        s[a] ? s[a].p(r, n) : (s[a] = g1(r), s[a].c(), s[a].m(e.parentNode, e))
                    }
                    for (; a < s.length; a += 1) s[a].d(1);
                    s.length = i.length
                }
            },
            d(t) {
                X(s, t), t && Q(e)
            }
        }
    }

    function g3(t) {
        let e, i = Array.from(t[4].stat),
            s = [];
        for (let n = 0; n < i.length; n += 1) s[n] = gk(pK(t, i, n));
        return {
            c() {
                for (let t = 0; t < s.length; t += 1) s[t].c();
                e = tt()
            },
            m(t, i) {
                for (let n = 0; n < s.length; n += 1) s[n].m(t, i);
                Y(t, e, i)
            },
            p(t, n) {
                if (16 & n[0]) {
                    let a;
                    for (i = Array.from(t[4].stat), a = 0; a < i.length; a += 1) {
                        let r = pK(t, i, a);
                        s[a] ? s[a].p(r, n) : (s[a] = gk(r), s[a].c(), s[a].m(e.parentNode, e))
                    }
                    for (; a < s.length; a += 1) s[a].d(1);
                    s.length = i.length
                }
            },
            d(t) {
                X(s, t), t && Q(e)
            }
        }
    }

    function gk(t) {
        let e, i, s, n, a, r, l = lt(t[19][0], t[19][1]) + "",
            o = rC.ui.stats.array[t[19][0]] + "";
        return {
            c() {
                e = J("div"), i = K("+"), s = K(l), n = Z(), a = K(o), r = Z(), ti(e, "class", "textcyan")
            },
            m(t, l) {
                Y(t, e, l), G(e, i), G(e, s), G(e, n), G(e, a), G(e, r)
            },
            p(t, e) {
                16 & e[0] && l !== (l = lt(t[19][0], t[19][1]) + "") && tn(s, l), 16 & e[0] && o !== (o = rC.ui.stats.array[t[19][0]] + "") && tn(a, o)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function g2(t) {
        let e, i = t[0].statsConvert,
            s = [];
        for (let n = 0; n < i.length; n += 1) s[n] = g4(pJ(t, i, n));
        return {
            c() {
                for (let t = 0; t < s.length; t += 1) s[t].c();
                e = tt()
            },
            m(t, i) {
                for (let n = 0; n < s.length; n += 1) s[n].m(t, i);
                Y(t, e, i)
            },
            p(t, n) {
                if (1 & n[0]) {
                    let a;
                    for (i = t[0].statsConvert, a = 0; a < i.length; a += 1) {
                        let r = pJ(t, i, a);
                        s[a] ? s[a].p(r, n) : (s[a] = g4(r), s[a].c(), s[a].m(e.parentNode, e))
                    }
                    for (; a < s.length; a += 1) s[a].d(1);
                    s.length = i.length
                }
            },
            d(t) {
                X(s, t), t && Q(e)
            }
        }
    }

    function g4(t) {
        let e, i, s, n, a, r, l, o = rC.ui.stats.array[t[19][0]] + "",
            c = lt(t[19][0], t[19][1]) + "",
            d = rC.ui.stats.array[t[19][2]] + "";
        return {
            c() {
                e = J("div"), i = K("For 1 "), s = K(o), n = K(" gain "), a = K(c), r = Z(), l = K(d), ti(e, "class", "textcyan")
            },
            m(t, o) {
                Y(t, e, o), G(e, i), G(e, s), G(e, n), G(e, a), G(e, r), G(e, l)
            },
            p(t, e) {
                1 & e[0] && o !== (o = rC.ui.stats.array[t[19][0]] + "") && tn(s, o), 1 & e[0] && c !== (c = lt(t[19][0], t[19][1]) + "") && tn(a, c), 1 & e[0] && d !== (d = rC.ui.stats.array[t[19][2]] + "") && tn(l, d)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function gC(t) {
        let e, i = t[0].custom,
            s = [];
        for (let n = 0; n < i.length; n += 1) s[n] = gS(pX(t, i, n));
        return {
            c() {
                for (let t = 0; t < s.length; t += 1) s[t].c();
                e = tt()
            },
            m(t, i) {
                for (let n = 0; n < s.length; n += 1) s[n].m(t, i);
                Y(t, e, i)
            },
            p(t, n) {
                if (259 & n[0]) {
                    let a;
                    for (i = t[0].custom, a = 0; a < i.length; a += 1) {
                        let r = pX(t, i, a);
                        s[a] ? s[a].p(r, n) : (s[a] = gS(r), s[a].c(), s[a].m(e.parentNode, e))
                    }
                    for (; a < s.length; a += 1) s[a].d(1);
                    s.length = i.length
                }
            },
            d(t) {
                X(s, t), t && Q(e)
            }
        }
    }

    function gS(t) {
        let e, i, s, n = t[8](t[16][0](t[1])) + "",
            a = t[16][1] + "";
        return {
            c() {
                e = J("div"), i = K(n), s = K(a), ti(e, "class", "textcyan")
            },
            m(t, n) {
                Y(t, e, n), G(e, i), G(e, s)
            },
            p(t, e) {
                3 & e[0] && n !== (n = t[8](t[16][0](t[1])) + "") && tn(i, n), 1 & e[0] && a !== (a = t[16][1] + "") && tn(s, a)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function g7(t) {
        let e, i, s, n, a, r, l, o = t[0].aoe.limit ? "Up to " + t[0].aoe.limit : "All",
            c = t[0].aoe.faction ? "allies" : "enemies",
            d = t[8](t[0].aoe.circleRadius) + "";
        return {
            c() {
                e = J("div"), i = K(o), s = Z(), n = K(c), a = K(" within "), r = K(d), l = K("m"), ti(e, "class", "textpvp")
            },
            m(t, o) {
                Y(t, e, o), G(e, i), G(e, s), G(e, n), G(e, a), G(e, r), G(e, l)
            },
            p(t, e) {
                1 & e[0] && o !== (o = t[0].aoe.limit ? "Up to " + t[0].aoe.limit : "All") && tn(i, o), 1 & e[0] && c !== (c = t[0].aoe.faction ? "allies" : "enemies") && tn(n, c), 1 & e[0] && d !== (d = t[8](t[0].aoe.circleRadius) + "") && tn(r, d)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function gE(t) {
        let e, i, s, n, a = rC.items.book[t[0].id].description + "";
        return {
            c() {
                e = J("div"), (i = J("u")).textContent = "Effect", s = K(": "), n = K(a), ti(e, "class", "textsecondary pad svelte-14w0l4b")
            },
            m(t, a) {
                Y(t, e, a), G(e, i), G(e, s), G(e, n)
            },
            p(t, e) {
                1 & e[0] && a !== (a = rC.items.book[t[0].id].description + "") && tn(n, a)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function g6(t) {
        let e, i, s;
        return i = new gP({
            props: {
                level: t[1],
                skill: t[13]
            }
        }), {
            c() {
                e = J("div"), tW(i.$$.fragment), ti(e, "class", "pad svelte-14w0l4b")
            },
            m(t, n) {
                Y(t, e, n), tH(i, e, null), s = !0
            },
            p(t, e) {
                let s = {};
                2 & e[0] && (s.level = t[1]), 8 & e[0] && (s.skill = t[13]), i.$set(s)
            },
            i(t) {
                s || (tR(i.$$.fragment, t), s = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), s = !1
            },
            d(t) {
                t && Q(e), tj(i)
            }
        }
    }
    class gP extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, {
                        skill: a
                    } = i,
                    {
                        level: r
                    } = i,
                    {
                        asItemDescription: l = !1
                    } = i,
                    o = ob.shift.store;
                N(e, o, t => s(10, n = t));
                let c = (t, e = as && as.player) => {
                        if (!e) return "?";
                        let i = fU(t, e);
                        return i % 1 == 0 ? i : i.toFixed(1)
                    },
                    d, u = [],
                    $ = {},
                    h = t => {
                        if (as) return t.onCast && m("on cast", t.onCast, as.player, r), t.onBlock && m("on block", t.onBlock, $, as.player), t.onInterval && m(`every ${t.intervalDuration.toFixed(1)}s`, t.onInterval, $, as.player, as.player), t.onPermanent && m("permanently", t.onPermanent, as.player, r), t
                    },
                    m = (t, e, i, n, r) => {
                        let l = e(i, n, r);
                        if (!l || !0 === l) return;
                        let o = Object.assign({}, l);
                        if (o.actiontype = t, o.parent || (o.parent = []), o.parent.push(a), 4 == o.mode || 5 == o.mode) {
                            let c = pG.get(o.id);
                            u.unshift(h({
                                ...o,
                                ...c
                            }))
                        } else if (a.id === o.id) a.parent || (o.parent = void 0), s(0, a = {
                            ...a,
                            ...o
                        });
                        else {
                            if (a.parent) {
                                let d = a.parent.find(t => t.id == o.id);
                                if (d) return d.parent || (o.parent = void 0), void Object.assign(d, o)
                            }
                            u.unshift(h(o))
                        }
                    };
                return e.$$set = t => {
                    "skill" in t && s(0, a = t.skill), "level" in t && s(1, r = t.level), "asItemDescription" in t && s(2, l = t.asItemDescription)
                }, e.$$.update = () => {
                    1075 & e.$$.dirty[0] && (s(5, $ = {
                        stacks: 1,
                        level: r
                    }), s(5, $.stacks = a.maxStacks ? n ? 1 : a.maxStacks : 1, $), s(0, a.stacks = $.stacks, a), s(3, u = []), a.parent || h(a), a.statsStatic && (s(4, d = new pY), a.statsStatic($, d)))
                }, [a, r, l, u, d, $, o, {
                    1: "Requires no target",
                    16: "Self cast",
                    256: "on Allies",
                    4096: "on Enemy"
                }, c, {
                    0: "Melee attack",
                    1: "Magic attack",
                    2: "Heal",
                    4: "Buff",
                    5: "Stackable buff",
                    6: "Ranged missile",
                    7: "Ranged effect",
                    9: "Effect"
                }]
            }, function t(e) {
                let i, s, n, a, r = [gr, ga],
                    l = [];

                function o(t, e) {
                    return t[0].item ? 0 : 1
                }
                return n = l[s = o(e)] = r[s](e), {
                    c() {
                        i = J("div"), n.c(), ti(i, "class", "container textsecondary svelte-14w0l4b")
                    },
                    m(t, e) {
                        Y(t, i, e), l[s].m(i, null), a = !0
                    },
                    p(t, e) {
                        let a = s;
                        (s = o(t)) === a ? l[s].p(t, e) : (tA(), tF(l[a], 1, 1, () => {
                            l[a] = null
                        }), t8(), (n = l[s]) || (n = l[s] = r[s](t)).c(), tR(n, 1), n.m(i, null))
                    },
                    i(t) {
                        a || (tR(n), a = !0)
                    },
                    o(t) {
                        tF(n), a = !1
                    },
                    d(t) {
                        t && Q(i), l[s].d()
                    }
                }
            }, A, {
                skill: 0,
                level: 1,
                asItemDescription: 2
            }, [-1, -1])
        }
    }
    class gM extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n;
                N(e, e_, t => s(4, n = t));
                let a, r, {
                        amount: l
                    } = i,
                    {
                        isPrice: o = !1
                    } = i;
                return e.$$set = t => {
                    "amount" in t && s(1, l = t.amount), "isPrice" in t && s(2, o = t.isPrice)
                }, e.$$.update = () => {
                    22 & e.$$.dirty && s(3, a = o && l > n), 10 & e.$$.dirty && s(0, r = ln(l, a))
                }, [r, l, o]
            }, function t(e) {
                let i;
                return {
                    c() {
                        i = J("span")
                    },
                    m(t, s) {
                        Y(t, i, s), i.innerHTML = e[0]
                    },
                    p(t, [e]) {
                        1 & e && (i.innerHTML = t[0])
                    },
                    i: C,
                    o: C,
                    d(t) {
                        t && Q(i)
                    }
                }
            }, R, {
                amount: 1,
                isPrice: 2
            })
        }
    }
    class g5 extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n;
                N(e, ef, t => s(4, n = t));
                let a, r, {
                        amount: l
                    } = i,
                    {
                        isPrice: o = !1
                    } = i;
                return e.$$set = t => {
                    "amount" in t && s(1, l = t.amount), "isPrice" in t && s(2, o = t.isPrice)
                }, e.$$.update = () => {
                    22 & e.$$.dirty && s(3, a = o && l > n), 10 & e.$$.dirty && s(0, r = la(l, a))
                }, [r, l, o]
            }, function t(e) {
                let i;
                return {
                    c() {
                        i = J("span")
                    },
                    m(t, s) {
                        Y(t, i, s), i.innerHTML = e[0]
                    },
                    p(t, [e]) {
                        1 & e && (i.innerHTML = t[0])
                    },
                    i: C,
                    o: C,
                    d(t) {
                        t && Q(i)
                    }
                }
            }, R, {
                amount: 1,
                isPrice: 2
            })
        }
    }
    class gD extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n;
                N(e, ep, t => s(2, n = t));
                let {
                    amount: a
                } = i, {
                    isPrice: r = !1
                } = i;
                return e.$$set = t => {
                    "amount" in t && s(0, a = t.amount), "isPrice" in t && s(1, r = t.isPrice)
                }, [a, r, n]
            }, function t(e) {
                let i, s, n, a, r, l;
                return {
                    c() {
                        i = J("span"), s = J("img"), a = J("span"), r = K(e[0]), ti(s, "class", "svgicon texticon"), s.src !== (n = "/assets/ui/icons/gem.svg?v=5699699") && ti(s, "src", n), ti(a, "class", l = !e[1] || e[0] < e[2] ? "textprimary" : "textred")
                    },
                    m(t, e) {
                        Y(t, i, e), G(i, s), G(i, a), G(a, r)
                    },
                    p(t, [e]) {
                        1 & e && tn(r, t[0]), 7 & e && l !== (l = !t[1] || t[0] < t[2] ? "textprimary" : "textred") && ti(a, "class", l)
                    },
                    i: C,
                    o: C,
                    d(t) {
                        t && Q(i)
                    }
                }
            }, R, {
                amount: 0,
                isPrice: 1
            })
        }
    }

    function gT(t, e, i) {
        let s = t.slice();
        return s[10] = e[i], s
    }

    function gA(t, e, i) {
        let s = t.slice();
        return s[13] = e[i], s
    }

    function g8(t, e, i) {
        let s = t.slice();
        return s[13] = e[i], s
    }

    function gR(t, e, i) {
        let s = t.slice();
        return s[18] = e[i], s
    }

    function gF(t, e, i) {
        let s = t.slice();
        return s[10] = e[i], s
    }

    function gN(t) {
        let e, i, s, n, a = t[0].gs + "";
        return {
            c() {
                e = J("span"), i = K("GS: "), s = K(a), n = Z(), ti(e, "class", "textgreen")
            },
            m(t, a) {
                Y(t, e, a), G(e, i), G(e, s), Y(t, n, a)
            },
            p(t, e) {
                1 & e && a !== (a = t[0].gs + "") && tn(s, a)
            },
            d(t) {
                t && Q(e), t && Q(n)
            }
        }
    }

    function gI(t) {
        let e, i, s, n = t[0].dbid + "";
        return {
            c() {
                e = J("span"), i = K("ID: "), s = K(n), ti(e, "class", "textgrey")
            },
            m(t, n) {
                Y(t, e, n), G(e, i), G(e, s)
            },
            p(t, e) {
                1 & e && n !== (n = t[0].dbid + "") && tn(s, n)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function gU(t) {
        let e, i, s, n, a, r, l = "bonus" == t[10][1].type ? "+ " : "",
            o = lt(t[10][0], t[10][1].value) + "",
            c = rC.ui.stats.array[t[10][0]] + "",
            d = "bonus" == t[10][1].type && t[4] && gO(t);
        return {
            c() {
                e = J("div"), i = K(l), s = K(o), n = Z(), a = K(c), r = Z(), d && d.c(), ti(e, "class", "text" + dF(t[10][1].qual)[0] + " svelte-e3ao5j")
            },
            m(t, l) {
                Y(t, e, l), G(e, i), G(e, s), G(e, n), G(e, a), G(e, r), d && d.m(e, null)
            },
            p(t, i) {
                "bonus" == t[10][1].type && t[4] ? d ? d.p(t, i) : ((d = gO(t)).c(), d.m(e, null)) : d && (d.d(1), d = null)
            },
            d(t) {
                t && Q(e), d && d.d()
            }
        }
    }

    function gz(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h = t[0].stats.get(10).value + "",
            m = t[0].stats.get(11).value + "",
            _ = rC.ui.stats.misc.damage + "";
        return {
            c() {
                e = J("div"), i = J("span"), s = K(h), a = K(" - "), r = J("span"), l = K(m), c = Z(), d = J("span"), u = K(_), ti(i, "class", n = "text" + dF(t[0].stats.get(10).qual)[0] + " svelte-e3ao5j"), ti(r, "class", o = "text" + dF(t[0].stats.get(11).qual)[0] + " svelte-e3ao5j"), ti(d, "class", $ = "text" + dF(Math.min(t[0].stats.get(10).qual, t[0].stats.get(11).qual))[0] + " svelte-e3ao5j")
            },
            m(t, n) {
                Y(t, e, n), G(e, i), G(i, s), G(e, a), G(e, r), G(r, l), G(e, c), G(e, d), G(d, u)
            },
            p(t, e) {
                1 & e && h !== (h = t[0].stats.get(10).value + "") && tn(s, h), 1 & e && n !== (n = "text" + dF(t[0].stats.get(10).qual)[0] + " svelte-e3ao5j") && ti(i, "class", n), 1 & e && m !== (m = t[0].stats.get(11).value + "") && tn(l, m), 1 & e && o !== (o = "text" + dF(t[0].stats.get(11).qual)[0] + " svelte-e3ao5j") && ti(r, "class", o), 1 & e && $ !== ($ = "text" + dF(Math.min(t[0].stats.get(10).qual, t[0].stats.get(11).qual))[0] + " svelte-e3ao5j") && ti(d, "class", $)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function gO(t) {
        let e, i, s, n = Math.round(t[10][1].qual) + "";
        return {
            c() {
                e = J("span"), i = K(n), s = K("%")
            },
            m(t, n) {
                Y(t, e, n), G(e, i), G(e, s)
            },
            p: C,
            d(t) {
                t && Q(e)
            }
        }
    }

    function gL(t) {
        let e, i;

        function s(t, i) {
            return (null == e || 1 & i) && (e = !(10 != t[10][0] || !t[0].stats.has(11))), e ? gz : gU
        }
        let n = s(t, -1),
            a = n(t);
        return {
            c() {
                a.c(), i = tt()
            },
            m(t, e) {
                a.m(t, e), Y(t, i, e)
            },
            p(t, e) {
                n === (n = s(t, e)) && a ? a.p(t, e) : (a.d(1), (a = n(t)) && (a.c(), a.m(i.parentNode, i)))
            },
            d(t) {
                a.d(t), t && Q(i)
            }
        }
    }

    function gB(t) {
        let e, i = t[0].logic.custom,
            s = [];
        for (let n = 0; n < i.length; n += 1) s[n] = gq(gR(t, i, n));
        return {
            c() {
                for (let t = 0; t < s.length; t += 1) s[t].c();
                e = tt()
            },
            m(t, i) {
                for (let n = 0; n < s.length; n += 1) s[n].m(t, i);
                Y(t, e, i)
            },
            p(t, n) {
                if (1 & n) {
                    let a;
                    for (i = t[0].logic.custom, a = 0; a < i.length; a += 1) {
                        let r = gR(t, i, a);
                        s[a] ? s[a].p(r, n) : (s[a] = gq(r), s[a].c(), s[a].m(e.parentNode, e))
                    }
                    for (; a < s.length; a += 1) s[a].d(1);
                    s.length = i.length
                }
            },
            d(t) {
                X(s, t), t && Q(e)
            }
        }
    }

    function gq(t) {
        let e, i, s = t[18] + "";
        return {
            c() {
                e = J("span"), i = K(s), ti(e, "class", "textgreen")
            },
            m(t, s) {
                Y(t, e, s), G(e, i)
            },
            p(t, e) {
                1 & e && s !== (s = t[18] + "") && tn(i, s)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function gV(t) {
        let e, i, s, n = t[13][0] + "";
        return {
            c() {
                e = J("div"), i = K(n), ti(e, "class", s = t[13][1] ? "textgreen" : "textred")
            },
            m(t, s) {
                Y(t, e, s), G(e, i)
            },
            p(t, a) {
                1 & a && n !== (n = t[13][0] + "") && tn(i, n), 1 & a && s !== (s = t[13][1] ? "textgreen" : "textred") && ti(e, "class", s)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function gW(t) {
        let e, i, s, n = t[0].logic.bindOnPurchase && gj(t),
            a = t[0].logic.bindOnUse && gG(t),
            r = t[0].logic.bindOnMerchant && gY(t);
        return {
            c() {
                n && n.c(), e = tt(), a && a.c(), i = tt(), r && r.c(), s = tt()
            },
            m(t, l) {
                n && n.m(t, l), Y(t, e, l), a && a.m(t, l), Y(t, i, l), r && r.m(t, l), Y(t, s, l)
            },
            p(t, l) {
                t[0].logic.bindOnPurchase ? n ? n.p(t, l) : ((n = gj(t)).c(), n.m(e.parentNode, e)) : n && (n.d(1), n = null), t[0].logic.bindOnUse ? a ? a.p(t, l) : ((a = gG(t)).c(), a.m(i.parentNode, i)) : a && (a.d(1), a = null), t[0].logic.bindOnMerchant ? r ? r.p(t, l) : ((r = gY(t)).c(), r.m(s.parentNode, s)) : r && (r.d(1), r = null)
            },
            d(t) {
                n && n.d(t), t && Q(e), a && a.d(t), t && Q(i), r && r.d(t), t && Q(s)
            }
        }
    }

    function gH(t) {
        let e, i, s = rC.ui.inventory.bindlevel[t[0].bound] + "";
        return {
            c() {
                e = J("div"), i = K(s), ti(e, "class", "textgreen")
            },
            m(t, s) {
                Y(t, e, s), G(e, i)
            },
            p(t, e) {
                1 & e && s !== (s = rC.ui.inventory.bindlevel[t[0].bound] + "") && tn(i, s)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function gj(t) {
        let e, i, s, n = rC.ui.inventory.bindlevel[t[0].logic.bindOnPurchase] + "";
        return {
            c() {
                e = J("div"), i = K(n), s = K(" on purchase"), ti(e, "class", "textcyan")
            },
            m(t, n) {
                Y(t, e, n), G(e, i), G(e, s)
            },
            p(t, e) {
                1 & e && n !== (n = rC.ui.inventory.bindlevel[t[0].logic.bindOnPurchase] + "") && tn(i, n)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function gG(t) {
        let e, i, s, n = rC.ui.inventory.bindlevel[t[0].logic.bindOnUse] + "";
        return {
            c() {
                e = J("div"), i = K(n), s = K(" on use"), ti(e, "class", "textcyan")
            },
            m(t, n) {
                Y(t, e, n), G(e, i), G(e, s)
            },
            p(t, e) {
                1 & e && n !== (n = rC.ui.inventory.bindlevel[t[0].logic.bindOnUse] + "") && tn(i, n)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function gY(t) {
        let e, i, s, n = rC.ui.inventory.bindlevel[t[0].logic.bindOnMerchant] + "";
        return {
            c() {
                e = J("div"), i = K(n), s = K(" on merchant sale"), ti(e, "class", "textcyan")
            },
            m(t, n) {
                Y(t, e, n), G(e, i), G(e, s)
            },
            p(t, e) {
                1 & e && n !== (n = rC.ui.inventory.bindlevel[t[0].logic.bindOnMerchant] + "") && tn(i, n)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function gQ(t) {
        let e, i, s, n, a, r = t[0].medalValue() > 0 && t[1],
            l = t[0].storeValue() > 0 && t[1],
            o = !(t[0].storeValue() > 0 && t[1]) && t[0].canBeSold(),
            c = t[1] && gX(t),
            d = r && gK(t),
            u = l && gZ(t),
            $ = o && vt(t);
        return {
            c() {
                e = J("div"), c && c.c(), i = tt(), d && d.c(), s = tt(), u && u.c(), n = tt(), $ && $.c(), ti(e, "class", "panel value pack svelte-e3ao5j")
            },
            m(t, r) {
                Y(t, e, r), c && c.m(e, null), G(e, i), d && d.m(e, null), G(e, s), u && u.m(e, null), G(e, n), $ && $.m(e, null), a = !0
            },
            p(t, a) {
                t[1] ? c ? c.p(t, a) : ((c = gX(t)).c(), c.m(e, i)) : c && (c.d(1), c = null), 3 & a && (r = t[0].medalValue() > 0 && t[1]), r ? d ? (d.p(t, a), 3 & a && tR(d, 1)) : ((d = gK(t)).c(), tR(d, 1), d.m(e, s)) : d && (tA(), tF(d, 1, 1, () => {
                    d = null
                }), t8()), 3 & a && (l = t[0].storeValue() > 0 && t[1]), l ? u ? (u.p(t, a), 3 & a && tR(u, 1)) : ((u = gZ(t)).c(), tR(u, 1), u.m(e, n)) : u && (tA(), tF(u, 1, 1, () => {
                    u = null
                }), t8()), 3 & a && (o = !(t[0].storeValue() > 0 && t[1]) && t[0].canBeSold()), o ? $ ? ($.p(t, a), 3 & a && tR($, 1)) : (($ = vt(t)).c(), tR($, 1), $.m(e, null)) : $ && (tA(), tF($, 1, 1, () => {
                    $ = null
                }), t8())
            },
            i(t) {
                a || (tR(d), tR(u), tR($), a = !0)
            },
            o(t) {
                tF(d), tF(u), tF($), a = !1
            },
            d(t) {
                t && Q(e), c && c.d(), d && d.d(), u && u.d(), $ && $.d()
            }
        }
    }

    function gX(t) {
        let e, i = t[0].buyReasons(as && as.player),
            s = [];
        for (let n = 0; n < i.length; n += 1) s[n] = gJ(gA(t, i, n));
        return {
            c() {
                for (let t = 0; t < s.length; t += 1) s[t].c();
                e = tt()
            },
            m(t, i) {
                for (let n = 0; n < s.length; n += 1) s[n].m(t, i);
                Y(t, e, i)
            },
            p(t, n) {
                if (1 & n) {
                    let a;
                    for (i = t[0].buyReasons(as && as.player), a = 0; a < i.length; a += 1) {
                        let r = gA(t, i, a);
                        s[a] ? s[a].p(r, n) : (s[a] = gJ(r), s[a].c(), s[a].m(e.parentNode, e))
                    }
                    for (; a < s.length; a += 1) s[a].d(1);
                    s.length = i.length
                }
            },
            d(t) {
                X(s, t), t && Q(e)
            }
        }
    }

    function gJ(t) {
        let e, i, s = t[13][0] + "";
        return {
            c() {
                ti(e = J("div"), "class", i = t[13][1] ? "textgreen" : "textred")
            },
            m(t, i) {
                Y(t, e, i), e.innerHTML = s
            },
            p(t, n) {
                1 & n && s !== (s = t[13][0] + "") && (e.innerHTML = s), 1 & n && i !== (i = t[13][1] ? "textgreen" : "textred") && ti(e, "class", i)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function gK(t) {
        let e, i, s;
        return i = new g5({
            props: {
                amount: t[0].medalValue(),
                isPrice: !0
            }
        }), {
            c() {
                e = J("div"), tW(i.$$.fragment)
            },
            m(t, n) {
                Y(t, e, n), tH(i, e, null), s = !0
            },
            p(t, e) {
                let s = {};
                1 & e && (s.amount = t[0].medalValue()), i.$set(s)
            },
            i(t) {
                s || (tR(i.$$.fragment, t), s = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), s = !1
            },
            d(t) {
                t && Q(e), tj(i)
            }
        }
    }

    function gZ(t) {
        let e, i, s;
        return i = new gD({
            props: {
                amount: t[0].storeValue(),
                isPrice: !0
            }
        }), {
            c() {
                e = J("div"), tW(i.$$.fragment)
            },
            m(t, n) {
                Y(t, e, n), tH(i, e, null), s = !0
            },
            p(t, e) {
                let s = {};
                1 & e && (s.amount = t[0].storeValue()), i.$set(s)
            },
            i(t) {
                s || (tR(i.$$.fragment, t), s = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), s = !1
            },
            d(t) {
                t && Q(e), tj(i)
            }
        }
    }

    function vt(t) {
        let e, i, s;
        return i = new gM({
            props: {
                amount: t[0].goldValue(t[1]),
                isPrice: t[1]
            }
        }), {
            c() {
                e = J("div"), tW(i.$$.fragment)
            },
            m(t, n) {
                Y(t, e, n), tH(i, e, null), s = !0
            },
            p(t, e) {
                let s = {};
                3 & e && (s.amount = t[0].goldValue(t[1])), 2 & e && (s.isPrice = t[1]), i.$set(s)
            },
            i(t) {
                s || (tR(i.$$.fragment, t), s = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), s = !1
            },
            d(t) {
                t && Q(e), tj(i)
            }
        }
    }

    function ve(t) {
        let e, i, s, n, a, r = [vn, vs],
            l = [];

        function o(t, e) {
            return "book" == t[0].type ? 0 : 1
        }
        i = l[e = o(t)] = r[e](t);
        let c = t[5] && va();
        return {
            c() {
                i.c(), s = tt(), c && c.c(), n = tt()
            },
            m(t, i) {
                l[e].m(t, i), Y(t, s, i), c && c.m(t, i), Y(t, n, i), a = !0
            },
            p(t, a) {
                let d = e;
                (e = o(t)) === d ? l[e].p(t, a) : (tA(), tF(l[d], 1, 1, () => {
                    l[d] = null
                }), t8(), (i = l[e]) || (i = l[e] = r[e](t)).c(), tR(i, 1), i.m(s.parentNode, s)), t[5] ? c || ((c = va()).c(), c.m(n.parentNode, n)) : c && (c.d(1), c = null)
            },
            i(t) {
                a || (tR(i), a = !0)
            },
            o(t) {
                tF(i), a = !1
            },
            d(t) {
                l[e].d(t), t && Q(s), c && c.d(t), t && Q(n)
            }
        }
    }

    function vi(t) {
        let e, i, s = t[3],
            n = [];
        for (let a = 0; a < s.length; a += 1) n[a] = vr(gT(t, s, a));
        return {
            c() {
                e = J("div"), (i = J("div")).textContent = "Equipping this item will have these effects:";
                for (let t = 0; t < n.length; t += 1) n[t].c();
                ti(i, "class", "textgrey"), ti(e, "class", "pack svelte-e3ao5j")
            },
            m(t, s) {
                Y(t, e, s), G(e, i);
                for (let a = 0; a < n.length; a += 1) n[a].m(e, null)
            },
            p(t, i) {
                if (8 & i) {
                    let a;
                    for (s = t[3], a = 0; a < s.length; a += 1) {
                        let r = gT(t, s, a);
                        n[a] ? n[a].p(r, i) : (n[a] = vr(r), n[a].c(), n[a].m(e, null))
                    }
                    for (; a < n.length; a += 1) n[a].d(1);
                    n.length = s.length
                }
            },
            i: C,
            o: C,
            d(t) {
                t && Q(e), X(n, t)
            }
        }
    }

    function vs(t) {
        let e, i, s = r7(t[0].type, t[0].tier) + "";
        return {
            c() {
                e = J("div"), i = K(s), ti(e, "class", "pack description svelte-e3ao5j")
            },
            m(t, s) {
                Y(t, e, s), G(e, i)
            },
            p(t, e) {
                1 & e && s !== (s = r7(t[0].type, t[0].tier) + "") && tn(i, s)
            },
            i: C,
            o: C,
            d(t) {
                t && Q(e)
            }
        }
    }

    function vn(t) {
        let e, i;
        return e = new gP({
            props: {
                level: t[0].logic.skilllevel + 1,
                skill: dC.get(t[0].logic.skillid),
                asItemDescription: !0
            }
        }), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            p(t, i) {
                let s = {};
                1 & i && (s.level = t[0].logic.skilllevel + 1), 1 & i && (s.skill = dC.get(t[0].logic.skillid)), e.$set(s)
            },
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }

    function va(t) {
        let e;
        return {
            c() {
                (e = J("div")).textContent = "Press Shift to compare item.", ti(e, "class", "pack svelte-e3ao5j")
            },
            m(t, i) {
                Y(t, e, i)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function vr(t) {
        let e, i, s, n, a, r, l = t[10][1] > 0 ? "+" : "",
            o = lt(t[10][0], t[10][1]) + "",
            c = rC.ui.stats.array[t[10][0]] + "";
        return {
            c() {
                e = J("div"), i = K(l), s = K(o), n = Z(), a = K(c), ti(e, "class", r = "text" + (t[10][1] > 0 ? "green" : "red"))
            },
            m(t, r) {
                Y(t, e, r), G(e, i), G(e, s), G(e, n), G(e, a)
            },
            p(t, n) {
                8 & n && l !== (l = t[10][1] > 0 ? "+" : "") && tn(i, l), 8 & n && o !== (o = lt(t[10][0], t[10][1]) + "") && tn(s, o), 8 & n && c !== (c = rC.ui.stats.array[t[10][0]] + "") && tn(a, c), 8 & n && r !== (r = "text" + (t[10][1] > 0 ? "green" : "red")) && ti(e, "class", r)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function vl(t) {
        let e, i, s, n;
        return i = new vo({
            props: {
                item: t[2],
                comparison: !0
            }
        }), {
            c() {
                e = J("div"), tW(i.$$.fragment), ti(e, "class", s = "slotdescription border " + dF(t[2].quality)[0] + " comparecontainer svelte-e3ao5j")
            },
            m(t, s) {
                Y(t, e, s), tH(i, e, null), n = !0
            },
            p(t, a) {
                let r = {};
                4 & a && (r.item = t[2]), i.$set(r), (!n || 4 & a && s !== (s = "slotdescription border " + dF(t[2].quality)[0] + " comparecontainer svelte-e3ao5j")) && ti(e, "class", s)
            },
            i(t) {
                n || (tR(i.$$.fragment, t), n = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), n = !1
            },
            d(t) {
                t && Q(e), tj(i)
            }
        }
    }
    class vo extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, {
                        item: a
                    } = i,
                    {
                        comparison: r = !1
                    } = i,
                    {
                        isTrader: l = !1
                    } = i,
                    o = ob.shift.store;
                N(e, o, t => s(4, n = t));
                let c, d, u = a.stats.has(10) ? Array.from(a.stats).filter(t => 11 !== t[0]) : Array.from(a.stats),
                    $ = t => {
                        let e = new Map;
                        return a.stats.forEach((t, i) => {
                            e.set(i, t.value)
                        }), t.stats.forEach((t, i) => {
                            let s = (e.get(i) || 0) - t.value;
                            0 !== s ? e.set(i, s) : e.delete(i)
                        }), Array.from(e)
                    },
                    h;
                return e.$$set = t => {
                    "item" in t && s(0, a = t.item), "comparison" in t && s(8, r = t.comparison), "isTrader" in t && s(1, l = t.isTrader)
                }, e.$$.update = () => {
                    if (273 & e.$$.dirty) {
                        if (as && n && !r) {
                            let t = a.getEquipSlot();
                            if (void 0 !== t && as.player.inventory.slots.has(t)) {
                                let i = as.player.inventory.slots.get(t);
                                s(2, c = void 0 !== i.type ? i : void 0), s(3, d = $(i))
                            }
                        } else s(2, c = void 0), s(3, d = void 0)
                    }
                    257 & e.$$.dirty && s(5, h = !r && void 0 !== a.getEquipSlot())
                }, [a, l, c, d, n, h, o, u, r]
            }, function t(e) {
                let i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v, y, b, x, w, k, C, S, E, P, M = e[4] ? "T" + (e[0].tier + 1) + " " : "",
                    D = rS(e[0].type, e[0].tier) + "",
                    T = e[0].upgrade ? " +" + e[0].upgrade : "",
                    A = (e[0].stacks ? "" : dF(e[0].quality)[1]) + "",
                    R = e[0].type + "",
                    F = e[0].quality && !e[0].stacks ? e[0].quality + "%" : "",
                    N = e[1] || e[0].canBeSold(),
                    I = e[0].gs > 0 && gN(e),
                    U = e[0].dbid && gI(e),
                    z = e[7],
                    O = [];
                for (let L = 0; L < z.length; L += 1) O[L] = gL(gF(e, z, L));
                let B = void 0 !== e[0].logic.custom && gB(e),
                    q = e[0].equipReasons(as && as.player),
                    V = [];
                for (let W = 0; W < q.length; W += 1) V[W] = gV(g8(e, q, W));

                function H(t, e) {
                    return t[0].bound > 0 ? gH : gW
                }
                let j = H(e),
                    te = j(e),
                    ts = N && gQ(e),
                    ta = [vi, ve],
                    tr = [];

                function tl(t, e) {
                    return t[2] ? 0 : 1
                }
                S = tr[C = tl(e)] = ta[C](e);
                let to = e[2] && vl(e);
                return {
                    c() {
                        i = J("div"), s = J("div"), n = J("div"), a = K(M), r = K(D), l = J("span"), o = K(T), d = J("div"), u = K(A), $ = Z(), h = K(R), m = Z(), _ = J("span"), f = K(F), p = J("small"), I && I.c(), g = tt(), U && U.c(), v = Z(), y = J("div");
                        for (let t = 0; t < O.length; t += 1) O[t].c();
                        b = tt(), B && B.c(), x = J("div");
                        for (let C = 0; C < V.length; C += 1) V[C].c();
                        w = tt(), te.c(), ts && ts.c(), k = tt(), S.c(), to && to.c(), E = tt(), ti(l, "class", "textprimary"), ti(n, "class", c = "slottitle text" + dF(e[0].quality)[0] + " svelte-e3ao5j"), ti(d, "class", "type textwhite svelte-e3ao5j"), ti(s, "class", "pack svelte-e3ao5j"), ti(y, "class", "pack svelte-e3ao5j"), ti(x, "class", "pack svelte-e3ao5j"), ti(i, "class", "container svelte-e3ao5j")
                    },
                    m(t, e) {
                        Y(t, i, e), G(i, s), G(s, n), G(n, a), G(n, r), G(n, l), G(l, o), G(s, d), G(d, u), G(d, $), G(d, h), G(d, m), G(d, _), G(_, f), G(s, p), I && I.m(p, null), G(p, g), U && U.m(p, null), G(s, v), G(i, y);
                        for (let c = 0; c < O.length; c += 1) O[c].m(y, null);
                        G(y, b), B && B.m(y, null), G(i, x);
                        for (let S = 0; S < V.length; S += 1) V[S].m(x, null);
                        G(x, w), te.m(x, null), ts && ts.m(i, null), G(i, k), tr[C].m(i, null), to && to.m(t, e), Y(t, E, e), P = !0
                    },
                    p(t, [e]) {
                        if ((!P || 17 & e) && M !== (M = t[4] ? "T" + (t[0].tier + 1) + " " : "") && tn(a, M), (!P || 1 & e) && D !== (D = rS(t[0].type, t[0].tier) + "") && tn(r, D), (!P || 1 & e) && T !== (T = t[0].upgrade ? " +" + t[0].upgrade : "") && tn(o, T), (!P || 1 & e && c !== (c = "slottitle text" + dF(t[0].quality)[0] + " svelte-e3ao5j")) && ti(n, "class", c), (!P || 1 & e) && A !== (A = (t[0].stacks ? "" : dF(t[0].quality)[1]) + "") && tn(u, A), (!P || 1 & e) && R !== (R = t[0].type + "") && tn(h, R), (!P || 1 & e) && F !== (F = t[0].quality && !t[0].stacks ? t[0].quality + "%" : "") && tn(f, F), t[0].gs > 0 ? I ? I.p(t, e) : ((I = gN(t)).c(), I.m(p, g)) : I && (I.d(1), I = null), t[0].dbid ? U ? U.p(t, e) : ((U = gI(t)).c(), U.m(p, null)) : U && (U.d(1), U = null), 145 & e) {
                            let s;
                            for (z = t[7], s = 0; s < z.length; s += 1) {
                                let l = gF(t, z, s);
                                O[s] ? O[s].p(l, e) : (O[s] = gL(l), O[s].c(), O[s].m(y, b))
                            }
                            for (; s < O.length; s += 1) O[s].d(1);
                            O.length = z.length
                        }
                        if (void 0 !== t[0].logic.custom ? B ? B.p(t, e) : ((B = gB(t)).c(), B.m(y, null)) : B && (B.d(1), B = null), 1 & e) {
                            let d;
                            for (q = t[0].equipReasons(as && as.player), d = 0; d < q.length; d += 1) {
                                let $ = g8(t, q, d);
                                V[d] ? V[d].p($, e) : (V[d] = gV($), V[d].c(), V[d].m(x, w))
                            }
                            for (; d < V.length; d += 1) V[d].d(1);
                            V.length = q.length
                        }
                        j === (j = H(t)) && te ? te.p(t, e) : (te.d(1), (te = j(t)) && (te.c(), te.m(x, null))), 3 & e && (N = t[1] || t[0].canBeSold()), N ? ts ? (ts.p(t, e), 3 & e && tR(ts, 1)) : ((ts = gQ(t)).c(), tR(ts, 1), ts.m(i, k)) : ts && (tA(), tF(ts, 1, 1, () => {
                            ts = null
                        }), t8());
                        let m = C;
                        (C = tl(t)) === m ? tr[C].p(t, e) : (tA(), tF(tr[m], 1, 1, () => {
                            tr[m] = null
                        }), t8(), (S = tr[C]) || (S = tr[C] = ta[C](t)).c(), tR(S, 1), S.m(i, null)), t[2] ? to ? (to.p(t, e), 4 & e && tR(to, 1)) : ((to = vl(t)).c(), tR(to, 1), to.m(E.parentNode, E)) : to && (tA(), tF(to, 1, 1, () => {
                            to = null
                        }), t8())
                    },
                    i(t) {
                        P || (tR(ts), tR(S), tR(to), P = !0)
                    },
                    o(t) {
                        tF(ts), tF(S), tF(to), P = !1
                    },
                    d(t) {
                        t && Q(i), I && I.d(), U && U.d(), X(O, t), B && B.d(), X(V, t), te.d(), ts && ts.d(), tr[C].d(), to && to.d(t), t && Q(E)
                    }
                }
            }, A, {
                item: 0,
                comparison: 8,
                isTrader: 1
            })
        }
    }

    function vc(t) {
        let e, i;
        return e = new gP({
            props: {
                level: t[10] || 1,
                skill: {
                    ...dC.get(t[2].id)
                }
            }
        }), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            p(t, i) {
                let s = {};
                1024 & i[0] && (s.level = t[10] || 1), 4 & i[0] && (s.skill = {
                    ...dC.get(t[2].id)
                }), e.$set(s)
            },
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }

    function vd(t) {
        let e, i;
        return e = new vo({
            props: {
                item: t[6]
            }
        }), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            p(t, i) {
                let s = {};
                64 & i[0] && (s.item = t[6]), e.$set(s)
            },
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }

    function vu(t) {
        let e, i, s, n, a = [vd, vc],
            r = [];

        function l(t, e) {
            return t[6] ? 0 : t[2].id >= 0 ? 1 : -1
        }
        return ~(e = l(t)) && (i = r[e] = a[e](t)), {
            c() {
                i && i.c(), s = tt()
            },
            m(t, i) {
                ~e && r[e].m(t, i), Y(t, s, i), n = !0
            },
            p(t, n) {
                let o = e;
                (e = l(t)) === o ? ~e && r[e].p(t, n) : (i && (tA(), tF(r[o], 1, 1, () => {
                    r[o] = null
                }), t8()), ~e ? ((i = r[e]) || (i = r[e] = a[e](t)).c(), tR(i, 1), i.m(s.parentNode, s)) : i = null)
            },
            i(t) {
                n || (tR(i), n = !0)
            },
            o(t) {
                tF(i), n = !1
            },
            d(t) {
                ~e && r[e].d(t), t && Q(s)
            }
        }
    }
    class v$ extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a, r, l, o, c, d = C,
                    u = () => (d(), d = F($, t => s(2, n = t)), $);
                N(e, ey, t => s(26, a = t)), N(e, ev, t => s(28, r = t)), N(e, eC, t => s(29, l = t)), N(e, eb, t => s(30, o = t)), N(e, ex, t => s(31, c = t)), e.$$.on_destroy.push(() => d());
                let {
                    skill: $
                } = i;
                u();
                let {
                    skillslot: h
                } = i, m, _, f, p;
                tv(() => {
                    if (n.hotkey !== m && (void 0 !== _ && y(), void 0 !== (m = n.hotkey))) {
                        null == (p = ob[m]) && (p = ob[m] = {});
                        let t = o9(m, p);
                        _ = t.onPress(g), f = t.onRelease(v)
                    }
                });
                let g = t => {
                        if (as.player && n.id >= 0) {
                            if (n.item) {
                                let e = as.player.inventory.findFirstSlotOfType(n.item.type, n.item.tier);
                                if (void 0 === e) return; {
                                    let i = as.player.inventory.slots.get(e);
                                    if (i.bound < i.logic.bindOnUse) return void lY("error", "Right-click and use the item in your inventory to bind it before using");
                                    L($, n.info[0] = e, n)
                                }
                            }
                            let a = dC.get(n.id);
                            a.envCast > 0 ? uA > 0 ? uN(0, 0, 0) : uN(n.id, a.range, a.envCast) : rp(aF.clientPlayerSkill.packData({
                                id: n.id,
                                info: n.info
                            })), "keydown" === t.type && s(9, D = !0), lL(96)
                        }
                    },
                    v = () => {
                        s(9, D = !1)
                    },
                    y = () => {
                        p && p.mappings && (p.mappings = p.mappings.filter(t => t != m)), p && p.press && (p.press = p.press.filter(t => t != _)), p && p.release && (p.release = p.release.filter(t => t != f)), m = void 0, _ = void 0, f = void 0
                    },
                    b, x, w, k, S, E, P, M, D, T, A, R, I, U, z;
                return ty(y), e.$$set = t => {
                    "skill" in t && u(s(0, $ = t.skill)), "skillslot" in t && s(17, h = t.skillslot)
                }, e.$$.update = () => {
                    131076 & e.$$.dirty[0] && s(1, b = {
                        type: "skill",
                        slot: h,
                        skill: n
                    }), 4 & e.$$.dirty[0] && s(3, x = n.id < 0), 4 & e.$$.dirty[0] && s(25, w = n.item), 67108876 & e.$$.dirty[0] && s(4, k = x ? void 0 : a[n.id]), 16 & e.$$.dirty[0] && k && k.status, 4 & e.$$.dirty[0] && s(5, S = n.item ? "slotitem" : "slotskill"), 268435460 & e.$$.dirty[0] && s(6, E = r && n.item && as.player ? as.player.inventory.findFirstItemOfType(n.item.type, n.item.tier) : void 0), 33554508 & e.$$.dirty[0] && s(7, P = x ? void 0 : w ? E ? rU(E.type, E.tier, E.logic.class, dR(E.quality)) : rU(w.type, w.tier, 0, 0) : rz(n.id)), 301989952 & e.$$.dirty[0] && s(8, M = void 0 !== E && void 0 !== E.stacks ? r[w.type + w.tier] || 0 : void 0), 536870924 & e.$$.dirty[0] && s(10, T = n.item || x ? 0 : l.has(n.id) ? l.get(n.id) : 0), 16 & e.$$.dirty[0] && s(11, A = k ? k.cd : void 0), 16 & e.$$.dirty[0] && s(12, R = k ? k.remaining : void 0), 1348 & e.$$.dirty[0] && s(13, I = n.item && (!E || 0 === M) || !n.item && 0 === T), 1073741828 & e.$$.dirty[0] && s(14, U = void 0 !== o && o === n.id), 4 & e.$$.dirty[0] | 1 & e.$$.dirty[1] && s(15, z = void 0 !== c && c === n.id)
                }, s(9, D = !1), [$, b, n, x, k, S, E, P, M, D, T, A, R, I, U, z, g, h, function t(i) {
                    tb(e, i)
                }, function t(i) {
                    tb(e, i)
                }]
            }, function t(e) {
                let i, s;
                return (i = new fI({
                    props: {
                        describe: e[2].id >= 0 && !e[2].item || void 0 !== e[6],
                        descPos: "bottom:100%;left:50%;transform:translateX(-50%);",
                        ",": !0,
                        clickToUse: !0,
                        status: e[13] ? -1 : void 0 !== e[4] ? e[4].status : 0,
                        id: "sk" + e[2].hotkey,
                        data: e[2].id >= 0 || void 0 !== e[6] ? e[2] : void 0,
                        auto: e[15],
                        queued: e[14],
                        meta: e[1],
                        css: e[5],
                        stacks: e[8],
                        cd: e[11],
                        img: e[7],
                        remaining: e[12],
                        key: e[2].hotkey,
                        border: e[14] || e[9] ? "auto" : e[13] || e[15] || e[3] || e[11] ? "grey" : e[6] ? dF(e[6].quality)[0] : "white",
                        $$slots: {
                            default: [vu]
                        },
                        $$scope: {
                            ctx: e
                        }
                    }
                })).$on("discard", e[18]), i.$on("move", e[19]), i.$on("use", e[16]), {
                    c() {
                        tW(i.$$.fragment)
                    },
                    m(t, e) {
                        tH(i, t, e), s = !0
                    },
                    p(t, e) {
                        let s = {};
                        68 & e[0] && (s.describe = t[2].id >= 0 && !t[2].item || void 0 !== t[6]), 8208 & e[0] && (s.status = t[13] ? -1 : void 0 !== t[4] ? t[4].status : 0), 4 & e[0] && (s.id = "sk" + t[2].hotkey), 68 & e[0] && (s.data = t[2].id >= 0 || void 0 !== t[6] ? t[2] : void 0), 32768 & e[0] && (s.auto = t[15]), 16384 & e[0] && (s.queued = t[14]), 2 & e[0] && (s.meta = t[1]), 32 & e[0] && (s.css = t[5]), 256 & e[0] && (s.stacks = t[8]), 2048 & e[0] && (s.cd = t[11]), 128 & e[0] && (s.img = t[7]), 4096 & e[0] && (s.remaining = t[12]), 4 & e[0] && (s.key = t[2].hotkey), 59976 & e[0] && (s.border = t[14] || t[9] ? "auto" : t[13] || t[15] || t[3] || t[11] ? "grey" : t[6] ? dF(t[6].quality)[0] : "white"), 1092 & e[0] | 8 & e[1] && (s.$$scope = {
                            dirty: e,
                            ctx: t
                        }), i.$set(s)
                    },
                    i(t) {
                        s || (tR(i.$$.fragment, t), s = !0)
                    },
                    o(t) {
                        tF(i.$$.fragment, t), s = !1
                    },
                    d(t) {
                        tj(i, t)
                    }
                }
            }, A, {
                skill: 0,
                skillslot: 17
            }, [-1, -1])
        }
    }
    let vh = Object.freeze({
            __proto__: null,
            startSkills: [31]
        }),
        vm = Object.freeze({
            __proto__: null,
            startSkills: [4]
        }),
        v_ = Object.freeze({
            __proto__: null
        }),
        vf = Object.freeze({
            __proto__: null
        }),
        vp = Object.freeze({
            __proto__: null,
            startSkills: [12]
        }),
        vg = [Object.freeze({
            __proto__: null,
            startSkills: [1, 21]
        }), vm, vh, vp, vf, v_];

    function vv(t, e, i) {
        let s = t.slice();
        return s[8] = e[i], s[10] = i, s
    }

    function vy(t) {
        let e, i;
        return (e = new v$({
            props: {
                skill: t[8],
                skillslot: t[10]
            }
        })).$on("discard", t[1]), e.$on("move", t[0]), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            p: C,
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }
    class v0 extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a, r;
                N(e, i9, t => s(3, n = t)), N(e, sb, t => s(4, a = t)), N(e, eh, t => s(5, r = t));
                let l = as.player.name,
                    o = n[l];
                o || (o = L(i9, n[l] = [], n));
                for (let c = 0; c < a; ++c)
                    if (void 0 === n[l][c]) {
                        let d = vg[as.player.class].startSkills[c];
                        n[l].push({
                            id: void 0 !== d && dC.get(d).autoSkillbar ? d : -1,
                            type: 0,
                            info: []
                        }), 4 === c || 5 === c ? (L(i9, n[l][c].id = 100, n), L(i9, n[l][c].item = {
                            type: "misc",
                            tier: c - 4
                        }, n)) : 11 === c && L(i9, n[l][11].id = 40, n)
                    } for (let u = 0; u < a; ++u) void 0 === eL[u] && eL.push(tX({
                    id: -1,
                    type: 0,
                    info: []
                }));
                n[l].forEach((t, e) => {
                    eL[e] && (t.hotkey = sO["kbSkillbar" + (e + 1)], eL[e].set(t))
                }), eL.forEach((t, e) => {
                    t.subscribe(t => {
                        i9.update(i => (i[l][e] = t, i))
                    })
                });
                let $ = t => {
                        let {
                            from: e,
                            to: i
                        } = t.detail;
                        e !== i && ("item" == e.type ? eL[i.slot].update(t => (t.id = e.item.logic.useSkill, t.item = {
                            type: e.item.type,
                            tier: e.item.tier
                        }, t)) : "skill" == e.type && (eL[i.slot].update(t => (t.id = e.skill.id, t.item = e.skill.item, t)), void 0 !== e.slot && eL[e.slot].update(h)))
                    },
                    h = t => (t.id = -1, t.item = void 0, t);
                return [$, t => {
                    eL[r.meta.slot].update(h)
                }]
            }, function t(e) {
                let i, s, n = eL,
                    a = [];
                for (let r = 0; r < n.length; r += 1) a[r] = vy(vv(e, n, r));
                let l = t => tF(a[t], 1, 1, () => {
                    a[t] = null
                });
                return {
                    c() {
                        i = J("div");
                        for (let t = 0; t < a.length; t += 1) a[t].c();
                        ti(i, "id", "skillbar"), ti(i, "class", "panel-black bar svelte-1v6qmvo")
                    },
                    m(t, e) {
                        Y(t, i, e);
                        for (let n = 0; n < a.length; n += 1) a[n].m(i, null);
                        s = !0
                    },
                    p(t, [e]) {
                        if (3 & e) {
                            let s;
                            for (n = eL, s = 0; s < n.length; s += 1) {
                                let r = vv(t, n, s);
                                a[s] ? (a[s].p(r, e), tR(a[s], 1)) : (a[s] = vy(r), a[s].c(), tR(a[s], 1), a[s].m(i, null))
                            }
                            for (tA(), s = n.length; s < a.length; s += 1) l(s);
                            t8()
                        }
                    },
                    i(t) {
                        if (!s) {
                            for (let e = 0; e < n.length; e += 1) tR(a[e]);
                            s = !0
                        }
                    },
                    o(t) {
                        a = a.filter(Boolean);
                        for (let e = 0; e < a.length; e += 1) tF(a[e]);
                        s = !1
                    },
                    d(t) {
                        t && Q(i), X(a, t)
                    }
                }
            }, R, {})
        }
    }

    function vb(t) {
        let e, i;
        return e = new vo({
            props: {
                isTrader: t[6],
                item: t[9]
            }
        }), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            p(t, i) {
                let s = {};
                64 & i && (s.isTrader = t[6]), 512 & i && (s.item = t[9]), e.$set(s)
            },
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }

    function vx(t) {
        let e, i, s = t[9] && vb(t);
        return {
            c() {
                s && s.c(), e = tt()
            },
            m(t, n) {
                s && s.m(t, n), Y(t, e, n), i = !0
            },
            p(t, i) {
                t[9] ? s ? (s.p(t, i), 512 & i && tR(s, 1)) : ((s = vb(t)).c(), tR(s, 1), s.m(e.parentNode, e)) : s && (tA(), tF(s, 1, 1, () => {
                    s = null
                }), t8())
            },
            i(t) {
                i || (tR(s), i = !0)
            },
            o(t) {
                tF(s), i = !1
            },
            d(t) {
                s && s.d(t), t && Q(e)
            }
        }
    }
    class vw extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a, r = C,
                    l = () => (r(), r = F(o, t => s(9, n = t)), o);
                N(e, ey, t => s(24, a = t)), e.$$.on_destroy.push(() => r());
                let {
                    item: o
                } = i;
                l();
                let {
                    filter: c = ""
                } = i, {
                    invslot: d
                } = i, {
                    pickable: u = !0
                } = i, {
                    text: $
                } = i, {
                    descRoot: h
                } = i, {
                    descPos: m
                } = i, {
                    hover: _
                } = i, {
                    isTrader: f = !1
                } = i, {
                    clearOnMove: p = !1
                } = i, {
                    id: g = ""
                } = i, v = t => !(!0 !== t && !n.moving) || !!t && !(n.type.includes(t) || n.logic.level > t || rC.items[n.type]["book" === n.type ? n.logic.skillid : n.tier].name.toLowerCase().includes(t)), y, b, x, w, k, S, E;
                return e.$$set = t => {
                    "item" in t && l(s(0, o = t.item)), "filter" in t && s(15, c = t.filter), "invslot" in t && s(16, d = t.invslot), "pickable" in t && s(1, u = t.pickable), "text" in t && s(2, $ = t.text), "descRoot" in t && s(3, h = t.descRoot), "descPos" in t && s(4, m = t.descPos), "hover" in t && s(5, _ = t.hover), "isTrader" in t && s(6, f = t.isTrader), "clearOnMove" in t && s(17, p = t.clearOnMove), "id" in t && s(7, g = t.id)
                }, e.$$.update = () => {
                    66048 & e.$$.dirty && s(8, y = n ? rU(n.type, n.tier, n.logic ? n.logic.class : 0, dR(n.quality)) : d > 100 ? rO(d) : void 0), 197121 & e.$$.dirty && s(10, b = {
                        type: "item",
                        slot: d,
                        item: n,
                        store: p ? o : void 0
                    }), 33344 & e.$$.dirty && s(11, x = n && !f && v(c)), 2560 & e.$$.dirty && s(12, w = n ? dF(n.quality)[0] + (x ? " grey" : "") : "grey"), 512 & e.$$.dirty && s(13, k = n && (n.upgrade ? "+" + n.upgrade : n.stacks)), 16777728 & e.$$.dirty && s(23, S = n && n.logic.use ? n.logic.useSkill && a[n.logic.useSkill] : void 0), 8388608 & e.$$.dirty && s(14, E = S ? S.cd : void 0)
                }, [o, u, $, h, m, _, f, g, y, n, b, x, w, k, E, c, d, p, function t(i) {
                    tb(e, i)
                }, function t(i) {
                    tb(e, i)
                }, function t(i) {
                    tb(e, i)
                }, function t(i) {
                    tb(e, i)
                }, function t(i) {
                    tb(e, i)
                }]
            }, function t(e) {
                let i, s;
                return (i = new fI({
                    props: {
                        describe: void 0 !== e[9],
                        cd: e[14],
                        id: e[7],
                        hover: e[5],
                        descPos: e[4],
                        descRoot: e[3],
                        pickable: e[1],
                        status: e[11] ? -1 : 0,
                        meta: e[10],
                        img: e[8],
                        border: e[12],
                        stacks: e[13],
                        data: e[9],
                        key: e[2],
                        $$slots: {
                            default: [vx]
                        },
                        $$scope: {
                            ctx: e
                        }
                    }
                })).$on("discard", e[18]), i.$on("use", e[19]), i.$on("click", e[20]), i.$on("context", e[21]), i.$on("move", e[22]), {
                    c() {
                        tW(i.$$.fragment)
                    },
                    m(t, e) {
                        tH(i, t, e), s = !0
                    },
                    p(t, [e]) {
                        let s = {};
                        512 & e && (s.describe = void 0 !== t[9]), 16384 & e && (s.cd = t[14]), 128 & e && (s.id = t[7]), 32 & e && (s.hover = t[5]), 16 & e && (s.descPos = t[4]), 8 & e && (s.descRoot = t[3]), 2 & e && (s.pickable = t[1]), 2048 & e && (s.status = t[11] ? -1 : 0), 1024 & e && (s.meta = t[10]), 256 & e && (s.img = t[8]), 4096 & e && (s.border = t[12]), 8192 & e && (s.stacks = t[13]), 512 & e && (s.data = t[9]), 4 & e && (s.key = t[2]), 67109440 & e && (s.$$scope = {
                            dirty: e,
                            ctx: t
                        }), i.$set(s)
                    },
                    i(t) {
                        s || (tR(i.$$.fragment, t), s = !0)
                    },
                    o(t) {
                        tF(i.$$.fragment, t), s = !1
                    },
                    d(t) {
                        tj(i, t)
                    }
                }
            }, A, {
                item: 0,
                filter: 15,
                invslot: 16,
                pickable: 1,
                text: 2,
                descRoot: 3,
                descPos: 4,
                hover: 5,
                isTrader: 6,
                clearOnMove: 17,
                id: 7
            })
        }
    }

    function v1(t, e, i) {
        let s = t.slice();
        return s[15] = e[i], s[17] = i, s
    }

    function v9(t) {
        let e, i;
        return (e = new vw({
            props: {
                id: "bag" + t[17],
                item: t[15],
                invslot: t[17],
                filter: t[0].toLowerCase()
            }
        })).$on("use", t[8]), e.$on("context", t[7]), e.$on("move", t[6]), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            p(t, i) {
                let s = {};
                2 & i && (s.item = t[15]), 1 & i && (s.filter = t[0].toLowerCase()), e.$set(s)
            },
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }

    function v3(t) {
        let e, i, s, n, a, r, l, o, c, d = t[1].filter(vk),
            u = [];
        for (let $ = 0; $ < d.length; $ += 1) u[$] = v9(v1(t, d, $));
        let h = t => tF(u[t], 1, 1, () => {
            u[t] = null
        });
        return n = new gM({
            props: {
                amount: t[4]
            }
        }), r = new gD({
            props: {
                amount: t[5]
            }
        }), {
            c() {
                e = J("input"), i = J("div");
                for (let l = 0; l < u.length; l += 1) u[l].c();
                s = J("div"), tW(n.$$.fragment), a = J("a"), tW(r.$$.fragment), ti(e, "class", "filter svelte-1axz35n"), ti(e, "type", "text"), ti(e, "placeholder", rC.ui.filter), ti(i, "class", "slotcontainer svelte-1axz35n"), tr(i, "grid-template-columns", "repeat(" + t[3] + ", auto)"), ti(s, "class", "panel-black gold svelte-1axz35n"), ti(a, "class", "panel-black gold svelte-1axz35n"), tr(a, "margin-right", "3px"), ti(a, "target", "_blank"), ti(a, "href", "/store")
            },
            m(d, $) {
                Y(d, e, $), ta(e, t[0]), Y(d, i, $);
                for (let h = 0; h < u.length; h += 1) u[h].m(i, null);
                Y(d, s, $), tH(n, s, null), Y(d, a, $), tH(r, a, null), l = !0, o || (c = te(e, "input", t[9]), o = !0)
            },
            p(t, s) {
                if (1 & s && e.value !== t[0] && ta(e, t[0]), 451 & s) {
                    let a;
                    for (d = t[1].filter(vk), a = 0; a < d.length; a += 1) {
                        let o = v1(t, d, a);
                        u[a] ? (u[a].p(o, s), tR(u[a], 1)) : (u[a] = v9(o), u[a].c(), tR(u[a], 1), u[a].m(i, null))
                    }
                    for (tA(), a = d.length; a < u.length; a += 1) h(a);
                    t8()
                }(!l || 8 & s) && tr(i, "grid-template-columns", "repeat(" + t[3] + ", auto)");
                let c = {};
                16 & s && (c.amount = t[4]), n.$set(c);
                let $ = {};
                32 & s && ($.amount = t[5]), r.$set($)
            },
            i(t) {
                if (!l) {
                    for (let e = 0; e < d.length; e += 1) tR(u[e]);
                    tR(n.$$.fragment, t), tR(r.$$.fragment, t), l = !0
                }
            },
            o(t) {
                u = u.filter(Boolean);
                for (let e = 0; e < u.length; e += 1) tF(u[e]);
                tF(n.$$.fragment, t), tF(r.$$.fragment, t), l = !1
            },
            d(t) {
                t && Q(e), t && Q(i), X(u, t), t && Q(s), tj(n), t && Q(a), tj(r), o = !1, c()
            }
        }
    }
    let vk = (t, e) => e < 101;
    class v2 extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a, r, l, o, c, d, u, $;
                N(e, eg, t => s(1, n = t)), N(e, eh, t => s(11, a = t)), N(e, eT, t => s(12, r = t)), N(e, e8, t => s(13, l = t)), N(e, eE, t => s(14, o = t)), N(e, ih, t => s(2, c = t)), N(e, i$, t => s(3, d = t)), N(e, e_, t => s(4, u = t)), N(e, ep, t => s(5, $ = t));
                let h = "",
                    m = t => {
                        let {
                            from: e,
                            to: i
                        } = t.detail;
                        if (e !== i && "item" == e.type && void 0 !== e.slot && void 0 !== i.slot && e.slot !== i.slot) {
                            if ($1("itemmove", `${e.slot} ${i.slot}`), e.slot >= 101) return;
                            e.item.stacks && (e.item.stacks = ""), e.item.moving = !0, i.item ? (i.item.stacks && (i.item.stacks = ""), n[e.slot].set(i.item), i.item.moving = !0) : n[e.slot] && n[e.slot].set(void 0), n[i.slot].set(e.item)
                        }
                    },
                    _ = t => L(ih, c = !1);
                return [h, n, c, d, u, $, m, t => {
                    if (!t.detail.item || a) return;
                    let e = [];
                    if (r) e.push(_K.itemstash(t.detail.slot));
                    else {
                        if (t.detail.item.canEquip(as.player)) {
                            let i = t.detail.item.getBestEquipslot(as.player.inventory);
                            void 0 !== i && e.push(_K.itemmove(t.detail.slot, i)), t.detail.item.logic.use && e.push(_K.itemuse(t.detail.slot, t.detail.item.logic.useSkill, t.detail.item.bound, t.detail.item.logic.bindOnUse))
                        }
                        l && t.detail.item.canBeSold() && e.push(_K.itemsell(t.detail.item.quality, t.detail.item.upgrade, t.detail.slot, t.detail.item.type, t.detail.item.tier)), t.detail.item.stacks > 1 && (e.push(_K.itemsplithalf(t.detail.slot)), e.push(_K.itemsplitone(t.detail.slot))), e.push(_K.itemcopyid(t.detail.item.dbid)), t.detail.item.canBeDropped() && e.push(_K.itemdrop(t.detail.item.quality, t.detail.item.upgrade, t.detail.slot, t.detail.item.type, t.detail.item.tier))
                    }
                    et.set({
                        x: t.detail.e.pageX - t.detail.e.layerX,
                        y: t.detail.e.pageY + (46 - t.detail.e.layerY),
                        opts: e
                    })
                }, t => {
                    t.detail.item && (r ? $1("itemstash", "" + t.detail.slot) : o ? (eP.set(t.detail.item), t.detail.item.type && lL(d7[t.detail.item.type].sound)) : l && t.detail.item.canBeSold() ? fe(t.detail.item.quality, t.detail.item.upgrade, t.detail.slot, t.detail.item.type, t.detail.item.tier) : t.detail.item.canBeDropped() && fi(t.detail.item.quality, t.detail.item.upgrade, t.detail.slot, t.detail.item.type, t.detail.item.tier))
                }, function t() {
                    s(0, h = this.value)
                }, _]
            }, function t(e) {
                let i, s, n;
                return (s = new fg({
                    props: {
                        title: rC.ui.inventory.name,
                        pad: "5",
                        icon: "bag",
                        $$slots: {
                            default: [v3]
                        },
                        $$scope: {
                            ctx: e
                        }
                    }
                })).$on("close", e[10]), {
                    c() {
                        i = J("div"), tW(s.$$.fragment), tr(i, "display", e[2] ? "block" : "none"), ti(i, "class", "l-corner-lr container svelte-1axz35n")
                    },
                    m(t, e) {
                        Y(t, i, e), tH(s, i, null), n = !0
                    },
                    p(t, [e]) {
                        let a = {};
                        262203 & e && (a.$$scope = {
                            dirty: e,
                            ctx: t
                        }), s.$set(a), (!n || 4 & e) && tr(i, "display", t[2] ? "block" : "none")
                    },
                    i(t) {
                        n || (tR(s.$$.fragment, t), n = !0)
                    },
                    o(t) {
                        tF(s.$$.fragment, t), n = !1
                    },
                    d(t) {
                        t && Q(i), tj(s)
                    }
                }
            }, A, {})
        }
    }

    function v4(t, e, i) {
        let s = t.slice();
        return s[11] = e[i], s[13] = i, s
    }

    function vC(t) {
        let e, i, s;
        return (i = new fg({
            props: {
                title: t[5][t[1]],
                pad: "5",
                icon: "trophy",
                $$slots: {
                    default: [v7]
                },
                $$scope: {
                    ctx: t
                }
            }
        })).$on("close", t[10]), {
            c() {
                e = J("div"), tW(i.$$.fragment), ti(e, "class", "l-corner-lr container svelte-m4f7d2")
            },
            m(t, n) {
                Y(t, e, n), tH(i, e, null), s = !0
            },
            p(t, e) {
                let s = {};
                2 & e && (s.title = t[5][t[1]]), 16414 & e && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }), i.$set(s)
            },
            i(t) {
                s || (tR(i.$$.fragment, t), s = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), s = !1
            },
            d(t) {
                t && Q(e), tj(i)
            }
        }
    }

    function vS(t, e) {
        let i, s, n, a, r;

        function l(...t) {
            return e[7](e[11], ...t)
        }
        return s = new fw({
            props: {
                size: "0.9em",
                fract: Math.round(100 * e[11][1].amount / e[2][0][1].amount),
                barcol: "bgc" + e[11][1].class,
                left: `${e[13]+1}. ${e[11][0]}`,
                right: `${rQ(e[11][1].amount)} (${rX(e[11][1].dps)})`
            }
        }), {
            key: t,
            first: null,
            c() {
                i = J("div"), tW(s.$$.fragment), this.first = i
            },
            m(t, e) {
                Y(t, i, e), tH(s, i, null), n = !0, a || (r = te(i, "click", l), a = !0)
            },
            p(t, i) {
                e = t;
                let n = {};
                4 & i && (n.fract = Math.round(100 * e[11][1].amount / e[2][0][1].amount)), 4 & i && (n.barcol = "bgc" + e[11][1].class), 4 & i && (n.left = `${e[13]+1}. ${e[11][0]}`), 4 & i && (n.right = `${rQ(e[11][1].amount)} (${rX(e[11][1].dps)})`), s.$set(n)
            },
            i(t) {
                n || (tR(s.$$.fragment, t), n = !0)
            },
            o(t) {
                tF(s.$$.fragment, t), n = !1
            },
            d(t) {
                t && Q(i), tj(s), a = !1, r()
            }
        }
    }

    function v7(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $ = [],
            h = new Map,
            m = t[5][t[1]] + "",
            _ = t[2],
            f = t => t[11][1].id;
        for (let p = 0; p < _.length; p += 1) {
            let g = v4(t, _, p),
                v = f(g);
            h.set(v, $[p] = vS(v, g))
        }
        return {
            c() {
                e = J("div");
                for (let c = 0; c < $.length; c += 1) $[c].c();
                i = J("div"), s = J("div"), n = K(m), a = J("div"), r = K("Party"), (o = J("div")).textContent = "Reset", ti(e, "class", "wrapper svelte-m4f7d2"), ti(s, "class", "btn grey"), ti(a, "class", l = "btn " + (t[4] ? "grey active" : "black")), ti(o, "class", "btn grey"), ti(i, "class", "grid buttons marg-top svelte-m4f7d2"), tr(i, "grid-template-columns", "2fr 1fr 1fr")
            },
            m(l, h) {
                Y(l, e, h);
                for (let m = 0; m < $.length; m += 1) $[m].m(e, null);
                Y(l, i, h), G(i, s), G(s, n), G(i, a), G(a, r), G(i, o), c = !0, d || (u = [te(s, "click", t[6]), te(a, "click", t[8]), te(o, "click", t[9])], d = !0)
            },
            p(t, i) {
                if (12 & i) {
                    let s = t[2];
                    tA(), $ = tL($, i, f, 1, t, s, h, e, tO, vS, null, v4), t8()
                }(!c || 2 & i) && m !== (m = t[5][t[1]] + "") && tn(n, m), (!c || 16 & i && l !== (l = "btn " + (t[4] ? "grey active" : "black"))) && ti(a, "class", l)
            },
            i(t) {
                if (!c) {
                    for (let e = 0; e < _.length; e += 1) tR($[e]);
                    c = !0
                }
            },
            o(t) {
                for (let e = 0; e < $.length; e += 1) tF($[e]);
                c = !1
            },
            d(t) {
                t && Q(e);
                for (let s = 0; s < $.length; s += 1) $[s].d();
                t && Q(i), d = !1, D(u)
            }
        }
    }
    class vE extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a, r, l, o;
                N(e, ip, t => s(0, n = t)), N(e, ix, t => s(1, a = t)), N(e, eU, t => s(2, r = t)), N(e, iw, t => s(3, l = t)), N(e, ib, t => s(4, o = t));
                let c = [rC.ui.stats.misc.damage, rC.ui.stats.misc.healing],
                    d = t => {
                        et.set({
                            x: t.pageX,
                            y: t.pageY - 50,
                            opts: c.map((t, e) => ({
                                name: t,
                                fun() {
                                    ix.set(e), lJ.clear()
                                }
                            }))
                        })
                    },
                    u = (t, e) => {
                        L(iw, l = l ? 0 : t[0])
                    },
                    $ = t => L(ib, o = !o),
                    h = t => L(ip, n = !1);
                return [n, a, r, l, o, c, d, u, $, t => lJ.clear(), h]
            }, function t(e) {
                let i, s, n = e[0] && vC(e);
                return {
                    c() {
                        n && n.c(), i = tt()
                    },
                    m(t, e) {
                        n && n.m(t, e), Y(t, i, e), s = !0
                    },
                    p(t, [e]) {
                        t[0] ? n ? (n.p(t, e), 1 & e && tR(n, 1)) : ((n = vC(t)).c(), tR(n, 1), n.m(i.parentNode, i)) : n && (tA(), tF(n, 1, 1, () => {
                            n = null
                        }), t8())
                    },
                    i(t) {
                        s || (tR(n), s = !0)
                    },
                    o(t) {
                        tF(n), s = !1
                    },
                    d(t) {
                        n && n.d(t), t && Q(i)
                    }
                }
            }, A, {})
        }
    }

    function v6(t) {
        let e, i, s, n, a, r = t[0].area + "";
        return {
            c() {
                e = J("p"), i = K(r), n = Z(), ti(e, "class", "text location textgreen svelte-dujqu3")
            },
            m(t, s) {
                Y(t, e, s), G(e, i), Y(t, n, s), a = !0
            },
            p(t, e) {
                (!a || 1 & e) && r !== (r = t[0].area + "") && tn(i, r)
            },
            i(t) {
                a || (t4(() => {
                    s || (s = tI(e, $8, {}, !0)), s.run(1)
                }), a = !0)
            },
            o(t) {
                s || (s = tI(e, $8, {}, !1)), s.run(0), a = !1
            },
            d(t) {
                t && Q(e), t && s && s.end(), t && Q(n)
            }
        }
    }

    function vP(t) {
        let e, i, s, n, a = t[0].error + "";
        return {
            c() {
                e = J("p"), i = K(a), ti(e, "class", "text error textred svelte-dujqu3")
            },
            m(t, s) {
                Y(t, e, s), G(e, i), n = !0
            },
            p(t, e) {
                (!n || 1 & e) && a !== (a = t[0].error + "") && tn(i, a)
            },
            i(t) {
                n || (s && s.end(1), n = !0)
            },
            o(t) {
                s = function t(e, i, s) {
                    let n, a = i(e, s),
                        r = !0,
                        l = tT;

                    function o() {
                        let {
                            delay: t = 0,
                            duration: i = 300,
                            easing: s = S,
                            tick: o = C,
                            css: c
                        } = a || tN;
                        c && (n = tm(e, 1, 0, i, t, s, c));
                        let d = q() + t,
                            u = d + i;
                        t4(() => t5(e, !1, "start")), j(t => {
                            if (r) {
                                if (t >= u) return o(0, 1), t5(e, !1, "end"), --l.r || D(l.c), !1;
                                if (t >= d) {
                                    let n = s((t - d) / i);
                                    o(1 - n, n)
                                }
                            }
                            return r
                        })
                    }
                    return l.r += 1, T(a) ? tM().then(() => {
                        a = a(), o()
                    }) : o(), {
                        end(t) {
                            t && a.tick && a.tick(1, 0), r && (n && t_(e, n), r = !1)
                        }
                    }
                }(e, $8, {}), n = !1
            },
            d(t) {
                t && Q(e), t && s && s.end()
            }
        }
    }
    class vM extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n = {},
                    a = {};
                return ei.subscribe(t => {
                    s(0, n[t.type] = t.text, n), a[t.type] && clearTimeout(a[t.type]), a[t.type] = setTimeout(() => {
                        s(0, n[t.type] = void 0, n)
                    }, t.time || 1e3)
                }), [n]
            }, function t(e) {
                let i, s, n, a = e[0].area && v6(e),
                    r = e[0].error && vP(e);
                return {
                    c() {
                        i = J("div"), a && a.c(), s = tt(), r && r.c(), ti(i, "class", "l-ui")
                    },
                    m(t, e) {
                        Y(t, i, e), a && a.m(i, null), G(i, s), r && r.m(i, null), n = !0
                    },
                    p(t, [e]) {
                        t[0].area ? a ? (a.p(t, e), 1 & e && tR(a, 1)) : ((a = v6(t)).c(), tR(a, 1), a.m(i, s)) : a && (tA(), tF(a, 1, 1, () => {
                            a = null
                        }), t8()), t[0].error ? r ? (r.p(t, e), 1 & e && tR(r, 1)) : ((r = vP(t)).c(), tR(r, 1), r.m(i, null)) : r && (tA(), tF(r, 1, 1, () => {
                            r = null
                        }), t8())
                    },
                    i(t) {
                        n || (tR(a), tR(r), n = !0)
                    },
                    o(t) {
                        tF(a), tF(r), n = !1
                    },
                    d(t) {
                        t && Q(i), a && a.d(), r && r.d()
                    }
                }
            }, A, {})
        }
    }

    function v5(t, e, i) {
        let s = t.slice();
        return s[5] = e[i], s
    }

    function vD(t) {
        let e, i, s, n, a, r;
        return i = new fg({
            props: {
                title: "Request",
                close: !1,
                $$slots: {
                    default: [vA]
                },
                $$scope: {
                    ctx: t
                }
            }
        }), {
            c() {
                e = J("div"), tW(i.$$.fragment), ti(e, "class", "absCentered container svelte-1dzs2t1")
            },
            m(s, l) {
                Y(s, e, l), tH(i, e, null), n = !0, a || (r = te(e, "outroend", t[4]), a = !0)
            },
            p(t, e) {
                let s = {};
                258 & e && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }), i.$set(s)
            },
            i(t) {
                n || (tR(i.$$.fragment, t), t4(() => {
                    s || (s = tI(e, $8, {
                        duration: 100
                    }, !0)), s.run(1)
                }), n = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), s || (s = tI(e, $8, {
                    duration: 100
                }, !1)), s.run(0), n = !1
            },
            d(t) {
                t && Q(e), tj(i), t && s && s.end(), a = !1, r()
            }
        }
    }

    function vT(t) {
        let e, i, s, n, a, r, l, o, c, d = t[5].text + "",
            u = (t[5].unavailable || "") + "",
            $ = (t[5].additional || "") + "";

        function h(...e) {
            return t[3](t[5], ...e)
        }
        return {
            c() {
                e = J("div"), i = K(d), s = Z(), n = K(u), a = Z(), r = K($), ti(e, "class", l = "choice " + (t[5].unavailable ? "unavailable textgrey" : "") + " svelte-1dzs2t1")
            },
            m(t, l) {
                Y(t, e, l), G(e, i), G(e, s), G(e, n), G(e, a), G(e, r), o || (c = te(e, "click", h), o = !0)
            },
            p(s, a) {
                t = s, 2 & a && d !== (d = t[5].text + "") && tn(i, d), 2 & a && u !== (u = (t[5].unavailable || "") + "") && tn(n, u), 2 & a && $ !== ($ = (t[5].additional || "") + "") && tn(r, $), 2 & a && l !== (l = "choice " + (t[5].unavailable ? "unavailable textgrey" : "") + " svelte-1dzs2t1") && ti(e, "class", l)
            },
            d(t) {
                t && Q(e), o = !1, c()
            }
        }
    }

    function vA(t) {
        let e, i, s, n, a = t[1][0].title + "",
            r = t[1][0].text + "",
            l = t[1][0].choices,
            o = [];
        for (let c = 0; c < l.length; c += 1) o[c] = vT(v5(t, l, c));
        return {
            c() {
                e = J("div"), i = J("h3"), s = K(a), n = J("p");
                for (let t = 0; t < o.length; t += 1) o[t].c();
                ti(i, "class", "textprimary"), ti(e, "class", "container svelte-1dzs2t1")
            },
            m(t, a) {
                Y(t, e, a), G(e, i), G(i, s), G(e, n), n.innerHTML = r;
                for (let l = 0; l < o.length; l += 1) o[l].m(e, null)
            },
            p(t, i) {
                if (2 & i && a !== (a = t[1][0].title + "") && tn(s, a), 2 & i && r !== (r = t[1][0].text + "") && (n.innerHTML = r), 6 & i) {
                    let c;
                    for (l = t[1][0].choices, c = 0; c < l.length; c += 1) {
                        let d = v5(t, l, c);
                        o[c] ? o[c].p(d, i) : (o[c] = vT(d), o[c].c(), o[c].m(e, null))
                    }
                    for (; c < o.length; c += 1) o[c].d(1);
                    o.length = l.length
                }
            },
            d(t) {
                t && Q(e), X(o, t)
            }
        }
    }
    class v8 extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n;
                N(e, ee, t => s(1, n = t));
                let a = !1,
                    r = async t => {
                        t && await t(), $M(), s(0, a = !0)
                    }, l = t => {
                        r(t.fun)
                    }, o = () => {
                        s(0, a = !1)
                    };
                return [a, n, r, l, o]
            }, function t(e) {
                let i, s, n = e[1].length && !e[0] && vD(e);
                return {
                    c() {
                        n && n.c(), i = tt()
                    },
                    m(t, e) {
                        n && n.m(t, e), Y(t, i, e), s = !0
                    },
                    p(t, [e]) {
                        t[1].length && !t[0] ? n ? (n.p(t, e), 3 & e && tR(n, 1)) : ((n = vD(t)).c(), tR(n, 1), n.m(i.parentNode, i)) : n && (tA(), tF(n, 1, 1, () => {
                            n = null
                        }), t8())
                    },
                    i(t) {
                        s || (tR(n), s = !0)
                    },
                    o(t) {
                        tF(n), s = !1
                    },
                    d(t) {
                        n && n.d(t), t && Q(i)
                    }
                }
            }, A, {})
        }
    }

    function vR(t) {
        let e, i, s, n, a = t[0][0].text + "",
            r = t[0][0].icon && vF(t);
        return {
            c() {
                e = J("div"), r && r.c(), i = J("div"), ti(e, "class", "notification panel-black border grey svelte-9nlpzp")
            },
            m(l, o) {
                Y(l, e, o), r && r.m(e, null), G(e, i), i.innerHTML = a, s || (n = te(e, "click", t[2]), s = !0)
            },
            p(t, s) {
                t[0][0].icon ? r ? r.p(t, s) : ((r = vF(t)).c(), r.m(e, i)) : r && (r.d(1), r = null), 1 & s && a !== (a = t[0][0].text + "") && (i.innerHTML = a)
            },
            d(t) {
                t && Q(e), r && r.d(), s = !1, n()
            }
        }
    }

    function vF(t) {
        let e, i, s;
        return {
            c() {
                ti(e = J("img"), "class", i = "icon " + t[0][0].css + " svelte-9nlpzp"), e.src !== (s = "/assets/ui/" + t[0][0].icon) && ti(e, "src", s)
            },
            m(t, i) {
                Y(t, e, i)
            },
            p(t, n) {
                1 & n && i !== (i = "icon " + t[0][0].css + " svelte-9nlpzp") && ti(e, "class", i), 1 & n && e.src !== (s = "/assets/ui/" + t[0][0].icon) && ti(e, "src", s)
            },
            d(t) {
                t && Q(e)
            }
        }
    }
    class vN extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a;
                return N(e, tJ, t => s(0, n = t)), N(e, el, t => s(1, a = t)), [n, a, () => {
                    tJ.update(t => (t.shift(), t))
                }]
            }, function t(e) {
                let i, s = e[0].length && !e[1] && vR(e);
                return {
                    c() {
                        s && s.c(), i = tt()
                    },
                    m(t, e) {
                        s && s.m(t, e), Y(t, i, e)
                    },
                    p(t, [e]) {
                        t[0].length && !t[1] ? s ? s.p(t, e) : ((s = vR(t)).c(), s.m(i.parentNode, i)) : s && (s.d(1), s = null)
                    },
                    i: C,
                    o: C,
                    d(t) {
                        s && s.d(t), t && Q(i)
                    }
                }
            }, A, {})
        }
    }

    function vI(t, e, i) {
        let s = t.slice();
        return s[5] = e[i], s
    }

    function vU(t) {
        let e, i;
        return {
            c() {
                e = J("div"), i = K(t[0]), ti(e, "class", "btn border grey")
            },
            m(t, s) {
                Y(t, e, s), G(e, i)
            },
            p(t, e) {
                1 & e && tn(i, t[0])
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function vz(t) {
        let e, i, s, n, a, r;

        function l(...e) {
            return t[2](t[5], ...e)
        }

        function o(...e) {
            return t[4](t[5], ...e)
        }
        return {
            c() {
                e = J("div"), ti(i = J("img"), "class", "svgicon"), i.src !== (s = "/assets/ui/icons/" + t[5].img + ".svg?v=5699699") && ti(i, "src", s), ti(e, "id", n = "sys" + t[5].img), ti(e, "class", "btn border black")
            },
            m(s, n) {
                Y(s, e, n), G(e, i), a || (r = [te(e, "mouseenter", l), te(e, "mouseleave", t[3]), te(e, "click", o)], a = !0)
            },
            p(e, i) {
                t = e
            },
            d(t) {
                t && Q(e), a = !1, D(r)
            }
        }
    }
    class vO extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n = [{
                        img: "gem",
                        desc: rC.ui.elixir.subscription,
                        store: iv
                    }, {
                        img: "char",
                        desc: rC.ui.headers.character,
                        store: i1
                    }, {
                        img: "book",
                        desc: rC.ui.headers.skills,
                        store: i_
                    }, {
                        img: "bag",
                        desc: rC.ui.inventory.name,
                        store: ih
                    }, {
                        img: "pvp",
                        desc: rC.ui.headers.pvp,
                        store: i0
                    }, {
                        img: "clan",
                        desc: rC.ui.clan.heading,
                        store: iy
                    }, {
                        img: "trophy",
                        desc: rC.ui.headers.dpsMeter,
                        store: ip
                    }, {
                        img: "cog",
                        desc: rC.ui.settings.name,
                        store: im
                    }, {
                        img: "fullscreen",
                        desc: rC.ui.headers.fullscreen,
                        fun() {
                            document.fullscreenElement ? document.exitFullscreen() : document.documentElement.requestFullscreen()
                        }
                    }, {
                        img: "back",
                        desc: rC.ui.headers.menuReturn,
                        fun() {
                            document.location.href = "/"
                        }
                    }],
                    a = "",
                    r = (t, e) => s(0, a = t.desc),
                    l = t => s(0, a = "");
                return [a, n, r, l, (t, e) => {
                    t.fun ? t.fun() : t.store.update(t => !t)
                }]
            }, function t(e) {
                let i, s, n = "" !== e[0] && vU(e),
                    a = e[1],
                    r = [];
                for (let l = 0; l < a.length; l += 1) r[l] = vz(vI(e, a, l));
                return {
                    c() {
                        i = J("div"), n && n.c(), s = tt();
                        for (let t = 0; t < r.length; t += 1) r[t].c();
                        ti(i, "class", "btnbar svelte-133q4bd")
                    },
                    m(t, e) {
                        Y(t, i, e), n && n.m(i, null), G(i, s);
                        for (let a = 0; a < r.length; a += 1) r[a].m(i, null)
                    },
                    p(t, [e]) {
                        if ("" !== t[0] ? n ? n.p(t, e) : ((n = vU(t)).c(), n.m(i, s)) : n && (n.d(1), n = null), 3 & e) {
                            let l;
                            for (a = t[1], l = 0; l < a.length; l += 1) {
                                let o = vI(t, a, l);
                                r[l] ? r[l].p(o, e) : (r[l] = vz(o), r[l].c(), r[l].m(i, null))
                            }
                            for (; l < r.length; l += 1) r[l].d(1);
                            r.length = a.length
                        }
                    },
                    i: C,
                    o: C,
                    d(t) {
                        t && Q(i), n && n.d(), X(r, t)
                    }
                }
            }, A, {})
        }
    }
    class vL extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n;
                N(e, ig, t => s(0, n = t));
                let a = t => L(ig, n = !n);
                return [n, a]
            }, function t(e) {
                let i, s, n, a, r, l, o, c;
                return {
                    c() {
                        i = J("div"), (s = J("a")).innerHTML = '<img class="svgicon" src="/assets/ui/icons/instagram.svg?v=5699699">', (n = J("a")).innerHTML = '<img class="svgicon" src="/assets/ui/icons/reddit.svg?v=5699699">', (a = J("a")).innerHTML = '<img class="svgicon" src="/assets/ui/icons/discord.svg?v=5699699">', (r = J("a")).innerHTML = '<img class="svgicon" src="/assets/ui/icons/twitter.svg?v=5699699">', (l = J("div")).innerHTML = '<img class="svgicon" src="/assets/ui/icons/twitch.svg?v=5699699">', ti(s, "class", "btn border black"), ti(s, "target", "_blank"), ti(s, "rel", "noopener noreferrer"), ti(s, "href", "https://www.instagram.com/hordesio.official"), ti(n, "class", "btn border black"), ti(n, "target", "_blank"), ti(n, "rel", "noopener noreferrer"), ti(n, "href", "https://www.reddit.com/r/Hordesio"), ti(a, "class", "btn border black"), ti(a, "target", "_blank"), ti(a, "rel", "noopener noreferrer"), ti(a, "href", "https://discord.gg/hordes"), ti(r, "class", "btn border black"), ti(r, "target", "_blank"), ti(r, "rel", "noopener noreferrer"), ti(r, "href", "https://twitter.com/hordesio"), ti(l, "class", "btn border black"), ti(i, "class", "btnbar svelte-1wol45y")
                    },
                    m(t, d) {
                        Y(t, i, d), G(i, s), G(i, n), G(i, a), G(i, r), G(i, l), o || (c = te(l, "click", e[1]), o = !0)
                    },
                    p: C,
                    i: C,
                    o: C,
                    d(t) {
                        t && Q(i), o = !1, c()
                    }
                }
            }, A, {})
        }
    }
    class vB extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a = C,
                    r = () => (a(), a = F(l, t => s(2, n = t)), l);
                e.$$.on_destroy.push(() => a());
                let {
                    store: l
                } = i;
                r();
                let {
                    cb: o
                } = i, c = t => {
                    L(l, n = !n), o && o(n)
                };
                return e.$$set = t => {
                    "store" in t && r(s(0, l = t.store)), "cb" in t && s(1, o = t.cb)
                }, [l, o, n, c]
            }, function t(e) {
                let i, s, n, a;
                return {
                    c() {
                        ti(i = J("div"), "class", s = "btn checkbox " + (e[2] ? "active" : ""))
                    },
                    m(t, s) {
                        Y(t, i, s), n || (a = te(i, "click", e[3]), n = !0)
                    },
                    p(t, [e]) {
                        4 & e && s !== (s = "btn checkbox " + (t[2] ? "active" : "")) && ti(i, "class", s)
                    },
                    i: C,
                    o: C,
                    d(t) {
                        t && Q(i), n = !1, a()
                    }
                }
            }, A, {
                store: 0,
                cb: 1
            })
        }
    }

    function vq(t, e, i) {
        let s = t.slice();
        return s[71] = e[i], s[73] = i, s
    }

    function vV(t, e, i) {
        let s = t.slice();
        return s[68] = e[i], s
    }

    function vW(t, e, i) {
        let s = t.slice();
        return s[65] = e[i], s[66] = e, s[67] = i, s
    }

    function vH(t, e, i) {
        let s = t.slice();
        return s[74] = e[i], s
    }

    function vj(t) {
        let e, i, s;
        return (i = new fg({
            props: {
                title: rC.ui.settings.name,
                icon: "cog",
                $$slots: {
                    default: [yi]
                },
                $$scope: {
                    ctx: t
                }
            }
        })).$on("close", t[64]), {
            c() {
                e = J("div"), tW(i.$$.fragment), ti(e, "class", "container svelte-ntyx09")
            },
            m(t, n) {
                Y(t, e, n), tH(i, e, null), s = !0
            },
            p(t, e) {
                let s = {};
                536870899 & e[0] | 32768 & e[2] && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }), i.$set(s)
            },
            i(t) {
                s || (tR(i.$$.fragment, t), s = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), s = !1
            },
            d(t) {
                t && Q(e), tj(i)
            }
        }
    }

    function vG(t) {
        let e, i, s, n, a, r = t[74].name + "";

        function l(...e) {
            return t[33](t[74], ...e)
        }
        return {
            c() {
                e = J("div"), i = K(r), ti(e, "class", s = "choice " + (t[74] == t[1] ? "active" : ""))
            },
            m(t, s) {
                Y(t, e, s), G(e, i), n || (a = te(e, "click", l), n = !0)
            },
            p(i, n) {
                t = i, 2 & n[0] && s !== (s = "choice " + (t[74] == t[1] ? "active" : "")) && ti(e, "class", s)
            },
            d(t) {
                t && Q(e), n = !1, a()
            }
        }
    }

    function vY(t) {
        let e, i, s, n, a, r;
        i = new vB({
            props: {
                store: iF
            }
        });
        let l = rC.ui.chat.types,
            o = [];
        for (let c = 0; c < l.length; c += 1) o[c] = vZ(vq(t, l, c));
        return {
            c() {
                (e = J("div")).textContent = "" + rC.ui.settings.chatbubbles, tW(i.$$.fragment), (s = J("div")).textContent = "" + rC.ui.settings.combatlog, n = J("div");
                for (let t = 0; t < o.length; t += 1) o[t].c();
                a = tt(), ti(s, "class", "textprimary")
            },
            m(t, l) {
                Y(t, e, l), tH(i, t, l), Y(t, s, l), Y(t, n, l);
                for (let c = 0; c < o.length; c += 1) o[c].m(t, l);
                Y(t, a, l), r = !0
            },
            p(t, e) {
                if (268435456 & e[0]) {
                    let i;
                    for (l = rC.ui.chat.types, i = 0; i < l.length; i += 1) {
                        let s = vq(t, l, i);
                        o[i] ? o[i].p(s, e) : (o[i] = vZ(s), o[i].c(), o[i].m(a.parentNode, a))
                    }
                    for (; i < o.length; i += 1) o[i].d(1);
                    o.length = l.length
                }
            },
            i(t) {
                r || (tR(i.$$.fragment, t), r = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), r = !1
            },
            d(t) {
                t && Q(e), tj(i, t), t && Q(s), t && Q(n), X(o, t), t && Q(a)
            }
        }
    }

    function vQ(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v, y, b, x, w, k, C, S, E, P, M, T, A, R, F, N, I, U, z, O, L, B, q, V, W, H, j, tt, tr, to, tc, td, tu, t$, th, tm, t_, tf, tp, tg, tv, ty, t0, tb, tx, tw, t1, t9, t3, tk, t2, tC, tS, t7, tE, t6, tP, tM, t5, tD, tT, tA, t8, tN, tI, tU, tz, tO, tL, tB, tq, tV, tG, tY, tQ, tX, tJ, tK, tZ, et, ee, ei, es, en, ea, er, el, eo, ec, ed, eu, e$, eh, em, e_, ef, ep, eg, ev, ey, e0, eb, ex, ew, e1, e9, e3, ek, e2, e4, eC, eS, e7, eE, e6, eP, eM, e5 = rC.ui.settings.language + "",
            eD = t[19].toFixed(1) + "",
            eT = t[20].toFixed(1) + "",
            eA = rC.ui.settings.invwidth + "",
            e8 = rC.ui.settings.stashwidth + "",
            eR = rC.ui.settings.stashheight + "",
            eF = t[30],
            eN = [];
        for (let eI = 0; eI < eF.length; eI += 1) eN[eI] = yt(vV(t, eF, eI));
        return f = new vB({
            props: {
                store: iq
            }
        }), x = new vB({
            props: {
                store: iC
            }
        }), k = new vB({
            props: {
                store: iE
            }
        }), S = new vB({
            props: {
                store: iS
            }
        }), P = new vB({
            props: {
                store: i6
            }
        }), T = new vB({
            props: {
                store: i7
            }
        }), R = new vB({
            props: {
                store: iP
            }
        }), N = new vB({
            props: {
                store: i5
            }
        }), U = new vB({
            props: {
                store: iT
            }
        }), O = new vB({
            props: {
                store: iM
            }
        }), V = new vB({
            props: {
                store: iB
            }
        }), t_ = new vB({
            props: {
                store: iI
            }
        }), tp = new vB({
            props: {
                store: iN
            }
        }), tv = new vB({
            props: {
                store: iU
            }
        }), t0 = new vB({
            props: {
                store: iD
            }
        }), t1 = new vB({
            props: {
                store: iW,
                cb: t[31]
            }
        }), t3 = new vB({
            props: {
                store: iH
            }
        }), t2 = new vB({
            props: {
                store: st
            }
        }), tq = new vB({
            props: {
                store: iY
            }
        }), tQ = new vB({
            props: {
                store: iX
            }
        }), tJ = new vB({
            props: {
                store: iJ
            }
        }), es = new vB({
            props: {
                store: iA
            }
        }), ea = new vB({
            props: {
                store: i8
            }
        }), {
            c() {
                e = J("div"), i = K(e5), s = Z(), n = J("br"), (a = J("small")).textContent = "Requires reload", r = J("select");
                for (let D = 0; D < eN.length; D += 1) eN[D].c();
                (l = J("div")).textContent = "" + rC.ui.settings.tutorial, o = J("div"), (c = J("div")).textContent = "Restart", (d = J("div")).textContent = "" + rC.ui.settings.resettutorial, (u = J("div")).textContent = "Disable", ($ = J("div")).textContent = "" + rC.ui.settings.disabletutorial, (h = J("div")).textContent = "FPS / Ping", m = J("div"), (_ = J("div")).textContent = "Show FPS / Ping", tW(f.$$.fragment), (p = J("div")).textContent = "Nameplates", g = J("div"), (v = J("div")).textContent = "Draw range", y = J("input"), (b = J("div")).textContent = "Monster bars", tW(x.$$.fragment), (w = J("div")).textContent = "Monster names", tW(k.$$.fragment), (C = J("div")).textContent = "Friendly player bars", tW(S.$$.fragment), (E = J("div")).textContent = "Friendly player names", tW(P.$$.fragment), (M = J("div")).textContent = "Enemy player bars", tW(T.$$.fragment), (A = J("div")).textContent = "Enemy player names", tW(R.$$.fragment), (F = J("div")).textContent = "Always show level", tW(N.$$.fragment), (I = J("div")).textContent = "Class color bars", tW(U.$$.fragment), (z = J("div")).textContent = "Transparency", tW(O.$$.fragment), (L = J("div")).textContent = "Drops", B = J("div"), (q = J("div")).textContent = "Show Drop Quality%", tW(V.$$.fragment), W = J("div"), H = K("Drop Quality% Minimum"), j = J("br"), tt = J("small"), tr = K(t[17]), to = K("%"), tc = J("input"), (td = J("div")).innerHTML = 'Exclude Drop Types<br><small class="textgrey">Requires reload</small>', tu = J("input"), (t$ = J("div")).textContent = "Damage & Healing", th = J("div"), (tm = J("div")).textContent = "Incoming damage", tW(t_.$$.fragment), (tf = J("div")).textContent = "Incoming healing", tW(tp.$$.fragment), (tg = J("div")).textContent = "Incoming mana", tW(tv.$$.fragment), (ty = J("div")).textContent = "Prevent overlapping numbers", tW(t0.$$.fragment), (tb = J("div")).textContent = "Icons & Buffs", tx = J("div"), (tw = J("div")).innerHTML = 'Cooldown text (skills)<br><small class="textgrey">Requires reload</small>', tW(t1.$$.fragment), (t9 = J("div")).textContent = "Cooldown text (buffs)", tW(t3.$$.fragment), (tk = J("div")).textContent = "Show your buffs only", tW(t2.$$.fragment), tC = J("div"), tS = K("Buff timeout flash interval"), t7 = J("br"), tE = J("small"), t6 = K(eD), tP = K("s"), tM = J("input"), t5 = J("div"), tD = K("Buff timeout flash duration"), tT = J("br"), tA = J("small"), t8 = K(eT), tN = K("s"), tI = J("input"), (tU = J("div")).textContent = "Buff maximum", tz = J("input"), (tO = J("div")).textContent = "Buff maximum (party)", tL = J("input"), (tB = J("div")).textContent = "Limited party buff update rate", tW(tq.$$.fragment), (tV = J("div")).textContent = "Unitframes", tG = J("div"), (tY = J("div")).textContent = "Show self in party", tW(tQ.$$.fragment), (tX = J("div")).textContent = "Party mana", tW(tJ.$$.fragment), (tK = J("div")).textContent = "Party frame width", tZ = J("input"), (et = J("div")).textContent = "Map", ee = J("div"), (ei = J("div")).textContent = "" + rC.ui.settings.mapshowmonsters, tW(es.$$.fragment), (en = J("div")).textContent = "" + rC.ui.settings.maplowqual, tW(ea.$$.fragment), (er = J("div")).textContent = "" + rC.ui.inventory.name, el = J("div"), eo = J("div"), ec = K("Protected item quality"), ed = J("br"), eu = J("small"), e$ = K(t[24]), eh = K("%"), em = J("input"), e_ = J("div"), ef = K(eA), ep = J("br"), eg = J("small"), ev = K(t[25]), ey = J("input"), (e0 = J("div")).textContent = "Stash", eb = J("div"), ex = J("div"), ew = K(e8), e1 = J("br"), e9 = J("small"), e3 = K(t[26]), ek = J("input"), e2 = J("div"), e4 = K(eR), eC = J("br"), eS = J("small"), e7 = K(t[27]), eE = J("input"), ti(a, "class", "textgrey"), void 0 === t[15] && t4(() => t[48].call(r)), ti(l, "class", "textprimary"), ti(d, "class", "btn blue"), ti($, "class", "btn orange"), ti(h, "class", "textprimary"), ti(p, "class", "textprimary"), ti(y, "type", "range"), ti(L, "class", "textprimary"), ti(tt, "class", "textgrey"), ti(tc, "type", "range"), ti(tc, "min", "0"), ti(tc, "max", "100"), ti(tu, "type", "text"), ti(tu, "placeholder", "misc, gold, ..."), ti(t$, "class", "textprimary"), ti(tb, "class", "textprimary"), ti(tE, "class", "textgrey"), ti(tM, "type", "range"), ti(tM, "min", "0"), ti(tM, "max", "1"), ti(tM, "step", "0.1"), ti(tA, "class", "textgrey"), ti(tI, "type", "range"), ti(tI, "min", "0"), ti(tI, "max", "5"), ti(tI, "step", "0.1"), ti(tz, "placeholder", "14"), ti(tz, "type", "number"), ti(tz, "min", "0"), ti(tL, "placeholder", "8"), ti(tL, "type", "number"), ti(tL, "min", "0"), ti(tV, "class", "textprimary"), ti(tZ, "type", "range"), ti(tZ, "min", "50"), ti(tZ, "max", "400"), ti(et, "class", "textprimary"), ti(er, "class", "textprimary"), ti(eu, "class", "textgrey"), ti(em, "type", "range"), ti(em, "min", "0"), ti(em, "max", "110"), ti(eg, "class", "textgrey"), ti(ey, "type", "range"), ti(ey, "min", "4"), ti(ey, "max", "10"), ti(e0, "class", "textprimary"), ti(e9, "class", "textgrey"), ti(ek, "type", "range"), ti(ek, "min", "6"), ti(ek, "max", "20"), ti(eS, "class", "textgrey"), ti(eE, "type", "range"), ti(eE, "min", "50"), ti(eE, "max", "500")
            },
            m(D, Q) {
                Y(D, e, Q), G(e, i), G(e, s), G(e, n), G(e, a), Y(D, r, Q);
                for (let X = 0; X < eN.length; X += 1) eN[X].m(r, null);
                tl(r, t[15]), Y(D, l, Q), Y(D, o, Q), Y(D, c, Q), Y(D, d, Q), Y(D, u, Q), Y(D, $, Q), Y(D, h, Q), Y(D, m, Q), Y(D, _, Q), tH(f, D, Q), Y(D, p, Q), Y(D, g, Q), Y(D, v, Q), Y(D, y, Q), ta(y, t[16]), Y(D, b, Q), tH(x, D, Q), Y(D, w, Q), tH(k, D, Q), Y(D, C, Q), tH(S, D, Q), Y(D, E, Q), tH(P, D, Q), Y(D, M, Q), tH(T, D, Q), Y(D, A, Q), tH(R, D, Q), Y(D, F, Q), tH(N, D, Q), Y(D, I, Q), tH(U, D, Q), Y(D, z, Q), tH(O, D, Q), Y(D, L, Q), Y(D, B, Q), Y(D, q, Q), tH(V, D, Q), Y(D, W, Q), G(W, H), G(W, j), G(W, tt), G(tt, tr), G(tt, to), Y(D, tc, Q), ta(tc, t[17]), Y(D, td, Q), Y(D, tu, Q), ta(tu, t[18]), Y(D, t$, Q), Y(D, th, Q), Y(D, tm, Q), tH(t_, D, Q), Y(D, tf, Q), tH(tp, D, Q), Y(D, tg, Q), tH(tv, D, Q), Y(D, ty, Q), tH(t0, D, Q), Y(D, tb, Q), Y(D, tx, Q), Y(D, tw, Q), tH(t1, D, Q), Y(D, t9, Q), tH(t3, D, Q), Y(D, tk, Q), tH(t2, D, Q), Y(D, tC, Q), G(tC, tS), G(tC, t7), G(tC, tE), G(tE, t6), G(tE, tP), Y(D, tM, Q), ta(tM, t[19]), Y(D, t5, Q), G(t5, tD), G(t5, tT), G(t5, tA), G(tA, t8), G(tA, tN), Y(D, tI, Q), ta(tI, t[20]), Y(D, tU, Q), Y(D, tz, Q), ta(tz, t[21]), Y(D, tO, Q), Y(D, tL, Q), ta(tL, t[22]), Y(D, tB, Q), tH(tq, D, Q), Y(D, tV, Q), Y(D, tG, Q), Y(D, tY, Q), tH(tQ, D, Q), Y(D, tX, Q), tH(tJ, D, Q), Y(D, tK, Q), Y(D, tZ, Q), ta(tZ, t[23]), Y(D, et, Q), Y(D, ee, Q), Y(D, ei, Q), tH(es, D, Q), Y(D, en, Q), tH(ea, D, Q), Y(D, er, Q), Y(D, el, Q), Y(D, eo, Q), G(eo, ec), G(eo, ed), G(eo, eu), G(eu, e$), G(eu, eh), Y(D, em, Q), ta(em, t[24]), Y(D, e_, Q), G(e_, ef), G(e_, ep), G(e_, eg), G(eg, ev), Y(D, ey, Q), ta(ey, t[25]), Y(D, e0, Q), Y(D, eb, Q), Y(D, ex, Q), G(ex, ew), G(ex, e1), G(ex, e9), G(e9, e3), Y(D, ek, Q), ta(ek, t[26]), Y(D, e2, Q), G(e2, e4), G(e2, eC), G(e2, eS), G(eS, e7), Y(D, eE, Q), ta(eE, t[27]), e6 = !0, eP || (eM = [te(r, "change", t[48]), te(r, "change", t[31]), te(d, "click", t[49]), te($, "click", t[50]), te(y, "change", t[51]), te(y, "input", t[51]), te(tc, "change", t[52]), te(tc, "input", t[52]), te(tu, "input", t[53]), te(tu, "change", t[31]), te(tM, "change", t[54]), te(tM, "input", t[54]), te(tI, "change", t[55]), te(tI, "input", t[55]), te(tz, "input", t[56]), te(tL, "input", t[57]), te(tZ, "change", t[58]), te(tZ, "input", t[58]), te(em, "change", t[59]), te(em, "input", t[59]), te(ey, "change", t[60]), te(ey, "input", t[60]), te(ek, "change", t[61]), te(ek, "input", t[61]), te(eE, "change", t[62]), te(eE, "input", t[62])], eP = !0)
            },
            p(t, e) {
                if (1073741824 & e[0]) {
                    let i;
                    for (eF = t[30], i = 0; i < eF.length; i += 1) {
                        let s = vV(t, eF, i);
                        eN[i] ? eN[i].p(s, e) : (eN[i] = yt(s), eN[i].c(), eN[i].m(r, null))
                    }
                    for (; i < eN.length; i += 1) eN[i].d(1);
                    eN.length = eF.length
                }
                1073774592 & e[0] && tl(r, t[15]), 65536 & e[0] && ta(y, t[16]), (!e6 || 131072 & e[0]) && tn(tr, t[17]), 131072 & e[0] && ta(tc, t[17]), 262144 & e[0] && tu.value !== t[18] && ta(tu, t[18]), (!e6 || 524288 & e[0]) && eD !== (eD = t[19].toFixed(1) + "") && tn(t6, eD), 524288 & e[0] && ta(tM, t[19]), (!e6 || 1048576 & e[0]) && eT !== (eT = t[20].toFixed(1) + "") && tn(t8, eT), 1048576 & e[0] && ta(tI, t[20]), 2097152 & e[0] && ts(tz.value) !== t[21] && ta(tz, t[21]), 4194304 & e[0] && ts(tL.value) !== t[22] && ta(tL, t[22]), 8388608 & e[0] && ta(tZ, t[23]), (!e6 || 16777216 & e[0]) && tn(e$, t[24]), 16777216 & e[0] && ta(em, t[24]), (!e6 || 33554432 & e[0]) && tn(ev, t[25]), 33554432 & e[0] && ta(ey, t[25]), (!e6 || 67108864 & e[0]) && tn(e3, t[26]), 67108864 & e[0] && ta(ek, t[26]), (!e6 || 134217728 & e[0]) && tn(e7, t[27]), 134217728 & e[0] && ta(eE, t[27])
            },
            i(t) {
                e6 || (tR(f.$$.fragment, t), tR(x.$$.fragment, t), tR(k.$$.fragment, t), tR(S.$$.fragment, t), tR(P.$$.fragment, t), tR(T.$$.fragment, t), tR(R.$$.fragment, t), tR(N.$$.fragment, t), tR(U.$$.fragment, t), tR(O.$$.fragment, t), tR(V.$$.fragment, t), tR(t_.$$.fragment, t), tR(tp.$$.fragment, t), tR(tv.$$.fragment, t), tR(t0.$$.fragment, t), tR(t1.$$.fragment, t), tR(t3.$$.fragment, t), tR(t2.$$.fragment, t), tR(tq.$$.fragment, t), tR(tQ.$$.fragment, t), tR(tJ.$$.fragment, t), tR(es.$$.fragment, t), tR(ea.$$.fragment, t), e6 = !0)
            },
            o(t) {
                tF(f.$$.fragment, t), tF(x.$$.fragment, t), tF(k.$$.fragment, t), tF(S.$$.fragment, t), tF(P.$$.fragment, t), tF(T.$$.fragment, t), tF(R.$$.fragment, t), tF(N.$$.fragment, t), tF(U.$$.fragment, t), tF(O.$$.fragment, t), tF(V.$$.fragment, t), tF(t_.$$.fragment, t), tF(tp.$$.fragment, t), tF(tv.$$.fragment, t), tF(t0.$$.fragment, t), tF(t1.$$.fragment, t), tF(t3.$$.fragment, t), tF(t2.$$.fragment, t), tF(tq.$$.fragment, t), tF(tQ.$$.fragment, t), tF(tJ.$$.fragment, t), tF(es.$$.fragment, t), tF(ea.$$.fragment, t), e6 = !1
            },
            d(t) {
                t && Q(e), t && Q(r), X(eN, t), t && Q(l), t && Q(o), t && Q(c), t && Q(d), t && Q(u), t && Q($), t && Q(h), t && Q(m), t && Q(_), tj(f, t), t && Q(p), t && Q(g), t && Q(v), t && Q(y), t && Q(b), tj(x, t), t && Q(w), tj(k, t), t && Q(C), tj(S, t), t && Q(E), tj(P, t), t && Q(M), tj(T, t), t && Q(A), tj(R, t), t && Q(F), tj(N, t), t && Q(I), tj(U, t), t && Q(z), tj(O, t), t && Q(L), t && Q(B), t && Q(q), tj(V, t), t && Q(W), t && Q(tc), t && Q(td), t && Q(tu), t && Q(t$), t && Q(th), t && Q(tm), tj(t_, t), t && Q(tf), tj(tp, t), t && Q(tg), tj(tv, t), t && Q(ty), tj(t0, t), t && Q(tb), t && Q(tx), t && Q(tw), tj(t1, t), t && Q(t9), tj(t3, t), t && Q(tk), tj(t2, t), t && Q(tC), t && Q(tM), t && Q(t5), t && Q(tI), t && Q(tU), t && Q(tz), t && Q(tO), t && Q(tL), t && Q(tB), tj(tq, t), t && Q(tV), t && Q(tG), t && Q(tY), tj(tQ, t), t && Q(tX), tj(tJ, t), t && Q(tK), t && Q(tZ), t && Q(et), t && Q(ee), t && Q(ei), tj(es, t), t && Q(en), tj(ea, t), t && Q(er), t && Q(el), t && Q(eo), t && Q(em), t && Q(e_), t && Q(ey), t && Q(e0), t && Q(eb), t && Q(ex), t && Q(ek), t && Q(e2), t && Q(eE), eP = !1, D(eM)
            }
        }
    }

    function vX(t) {
        let e, i, s, n, a, r, l, o, c, d;
        return {
            c() {
                (e = J("div")).textContent = "" + rC.ui.settings.sfxvolume, i = J("input"), (s = J("div")).innerHTML = 'External SFX Multiplier<br><small class="textgrey">Spells not cast by you can be reduced in volume. 100% = No sound reduction, 50% = half volume.</small>', n = J("input"), (a = J("div")).textContent = "" + rC.ui.settings.musicvolume, r = J("input"), (l = J("div")).textContent = "" + rC.ui.settings.ambiencevolume, o = J("input"), ti(i, "type", "range"), ti(n, "type", "range"), ti(r, "type", "range"), ti(o, "type", "range")
            },
            m(u, $) {
                Y(u, e, $), Y(u, i, $), ta(i, t[11]), Y(u, s, $), Y(u, n, $), ta(n, t[12]), Y(u, a, $), Y(u, r, $), ta(r, t[13]), Y(u, l, $), Y(u, o, $), ta(o, t[14]), c || (d = [te(i, "change", t[44]), te(i, "input", t[44]), te(n, "change", t[45]), te(n, "input", t[45]), te(r, "change", t[46]), te(r, "input", t[46]), te(o, "change", t[47]), te(o, "input", t[47])], c = !0)
            },
            p(t, e) {
                2048 & e[0] && ta(i, t[11]), 4096 & e[0] && ta(n, t[12]), 8192 & e[0] && ta(r, t[13]), 16384 & e[0] && ta(o, t[14])
            },
            i: C,
            o: C,
            d(t) {
                t && Q(e), t && Q(i), t && Q(s), t && Q(n), t && Q(a), t && Q(r), t && Q(l), t && Q(o), c = !1, D(d)
            }
        }
    }

    function vJ(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v, y, b, x, w, k, C, S, E, P, M, T, A, R, F, N = rC.ui.settings.mousesensitivity + "",
            I = t[9].toFixed(2) + "";
        d = new vB({
            props: {
                store: si
            }
        }), $ = new vB({
            props: {
                store: ss
            }
        }), m = new vB({
            props: {
                store: sn
            }
        }), f = new vB({
            props: {
                store: sa
            }
        });
        let U = Object.keys(t[0]).filter(ys).map(t[41]),
            z = [];
        for (let O = 0; O < U.length; O += 1) z[O] = ye(vW(t, U, O));
        return {
            c() {
                (e = J("div")).textContent = "" + rC.ui.settings.camera, i = J("div"), s = J("div"), n = K(N), a = Z(), r = J("span"), l = K(I), o = J("input"), (c = J("div")).textContent = "" + rC.ui.settings.invertmousex, tW(d.$$.fragment), (u = J("div")).textContent = "" + rC.ui.settings.invertmousey, tW($.$$.fragment), (h = J("div")).textContent = "" + rC.ui.settings.lockedcamera, tW(m.$$.fragment), (_ = J("div")).textContent = "" + rC.ui.settings.pointerlock, tW(f.$$.fragment), (p = J("div")).textContent = "Skillbar", g = J("div"), v = J("div"), y = K("Skillbar slots "), b = J("span"), x = K(t[10]), w = J("br"), (k = J("small")).textContent = "Requires reload", C = J("input"), (S = J("div")).textContent = "" + rC.ui.settings.keybindings, E = J("div"), (P = J("small")).textContent = "Requires reload", (M = J("small")).textContent = "To reset, leave field blank.";
                for (let D = 0; D < z.length; D += 1) z[D].c();
                T = tt(), ti(e, "class", "textprimary"), ti(r, "class", "textgrey"), ti(o, "type", "range"), ti(o, "step", "0.05"), ti(o, "min", "0.1"), ti(o, "max", "3"), ti(p, "class", "textprimary"), ti(b, "class", "textgrey"), ti(k, "class", "textgrey"), ti(C, "type", "range"), ti(C, "min", "10"), ti(C, "max", "24"), ti(S, "class", "textprimary"), ti(P, "class", "textgrey"), ti(M, "class", "textprimary")
            },
            m(D, N) {
                Y(D, e, N), Y(D, i, N), Y(D, s, N), G(s, n), G(s, a), G(s, r), G(r, l), Y(D, o, N), ta(o, t[9]), Y(D, c, N), tH(d, D, N), Y(D, u, N), tH($, D, N), Y(D, h, N), tH(m, D, N), Y(D, _, N), tH(f, D, N), Y(D, p, N), Y(D, g, N), Y(D, v, N), G(v, y), G(v, b), G(b, x), G(v, w), G(v, k), Y(D, C, N), ta(C, t[10]), Y(D, S, N), Y(D, E, N), Y(D, P, N), Y(D, M, N);
                for (let I = 0; I < z.length; I += 1) z[I].m(D, N);
                Y(D, T, N), A = !0, R || (F = [te(o, "change", t[39]), te(o, "input", t[39]), te(C, "change", t[40]), te(C, "input", t[40]), te(C, "change", t[31])], R = !0)
            },
            p(t, e) {
                if ((!A || 512 & e[0]) && I !== (I = t[9].toFixed(2) + "") && tn(l, I), 512 & e[0] && ta(o, t[9]), (!A || 1024 & e[0]) && tn(x, t[10]), 1024 & e[0] && ta(C, t[10]), 1 & e[0] | 2 & e[1]) {
                    let i;
                    for (U = Object.keys(t[0]).filter(ys).map(t[41]), i = 0; i < U.length; i += 1) {
                        let s = vW(t, U, i);
                        z[i] ? z[i].p(s, e) : (z[i] = ye(s), z[i].c(), z[i].m(T.parentNode, T))
                    }
                    for (; i < z.length; i += 1) z[i].d(1);
                    z.length = U.length
                }
            },
            i(t) {
                A || (tR(d.$$.fragment, t), tR($.$$.fragment, t), tR(m.$$.fragment, t), tR(f.$$.fragment, t), A = !0)
            },
            o(t) {
                tF(d.$$.fragment, t), tF($.$$.fragment, t), tF(m.$$.fragment, t), tF(f.$$.fragment, t), A = !1
            },
            d(t) {
                t && Q(e), t && Q(i), t && Q(s), t && Q(o), t && Q(c), tj(d, t), t && Q(u), tj($, t), t && Q(h), tj(m, t), t && Q(_), tj(f, t), t && Q(p), t && Q(g), t && Q(v), t && Q(C), t && Q(S), t && Q(E), t && Q(P), t && Q(M), X(z, t), t && Q(T), R = !1, D(F)
            }
        }
    }

    function vK(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v, y, b, x, w, k, C, S, E, P, M, T, A, R, F, N, I, U, z, O, L, B, q, V, W, H, j, X, Z, tt, ts, tn, tr, tl = rC.ui.settings.grass + "",
            to = rC.ui.settings.fxaa + "",
            tc = rC.ui.settings.bloom + "",
            td = rC.ui.settings.disableoffscreen + "",
            tu = rC.ui.settings.clouds + "",
            t$ = rC.ui.settings.shadows + "";
        return f = new vB({
            props: {
                cb: t[31],
                store: eY
            }
        }), b = new vB({
            props: {
                cb: t[31],
                store: eJ
            }
        }), S = new vB({
            props: {
                store: eQ
            }
        }), A = new vB({
            props: {
                cb: t[31],
                store: eK
            }
        }), F = new vB({
            props: {
                store: eZ
            }
        }), I = new vB({
            props: {
                cb: t[31],
                store: ie
            }
        }), V = new vB({
            props: {
                cb: t[31],
                store: eX
            }
        }), X = new vB({
            props: {
                store: eG
            }
        }), tt = new vB({
            props: {
                cb: t[31],
                store: ii
            }
        }), {
            c() {
                (e = J("div")).textContent = "" + rC.ui.settings.resolution, i = J("input"), (s = J("div")).textContent = "" + rC.ui.settings.viewrange, n = J("input"), (a = J("div")).innerHTML = 'Anisotropy<br><small class="textgrey">Requires reload</small>', r = J("input"), l = J("div"), o = K(tl), c = J("br"), (d = J("small")).textContent = "Requires reload", u = J("input"), $ = J("div"), h = K(to), m = J("br"), (_ = J("small")).textContent = "Requires reload", tW(f.$$.fragment), p = J("div"), g = K(tc), v = J("br"), (y = J("small")).textContent = "Requires reload", tW(b.$$.fragment), x = J("div"), w = K(td), k = J("br"), (C = J("small")).textContent = "Improves Performance but mutes offscreen action", tW(S.$$.fragment), E = J("div"), P = K(tu), M = J("br"), (T = J("small")).textContent = "Requires reload", tW(A.$$.fragment), (R = J("div")).textContent = "" + rC.ui.settings.particles, tW(F.$$.fragment), (N = J("div")).textContent = "Fog pattern", tW(I.$$.fragment), (U = J("div")).textContent = "Shadows", z = J("div"), O = J("div"), L = K(t$), B = J("br"), (q = J("small")).textContent = "Requires reload", tW(V.$$.fragment), (W = J("div")).innerHTML = 'Shadow resolution<br><small class="textgrey">Requires reload</small>', H = J("input"), (j = J("div")).innerHTML = "Real time environment shadows<br>", tW(X.$$.fragment), (Z = J("div")).innerHTML = 'Shadows on creatures<br><small class="textgrey">Requires reload</small>', tW(tt.$$.fragment), ti(i, "type", "range"), ti(i, "min", "30"), ti(i, "step", "10"), ti(n, "type", "range"), ti(n, "min", "30"), ti(r, "type", "range"), ti(r, "min", "0"), ti(r, "max", "4"), ti(d, "class", "textgrey"), ti(u, "type", "range"), ti(u, "min", "0"), ti(u, "max", "100"), ti(_, "class", "textgrey"), ti(y, "class", "textgrey"), ti(C, "class", "textgrey"), ti(T, "class", "textgrey"), ti(U, "class", "textprimary"), ti(q, "class", "textgrey"), ti(H, "type", "range"), ti(H, "min", "0"), ti(H, "max", "4")
            },
            m(D, Q) {
                Y(D, e, Q), Y(D, i, Q), ta(i, t[4]), Y(D, s, Q), Y(D, n, Q), ta(n, t[5]), Y(D, a, Q), Y(D, r, Q), ta(r, t[6]), Y(D, l, Q), G(l, o), G(l, c), G(l, d), Y(D, u, Q), ta(u, t[7]), Y(D, $, Q), G($, h), G($, m), G($, _), tH(f, D, Q), Y(D, p, Q), G(p, g), G(p, v), G(p, y), tH(b, D, Q), Y(D, x, Q), G(x, w), G(x, k), G(x, C), tH(S, D, Q), Y(D, E, Q), G(E, P), G(E, M), G(E, T), tH(A, D, Q), Y(D, R, Q), tH(F, D, Q), Y(D, N, Q), tH(I, D, Q), Y(D, U, Q), Y(D, z, Q), Y(D, O, Q), G(O, L), G(O, B), G(O, q), tH(V, D, Q), Y(D, W, Q), Y(D, H, Q), ta(H, t[8]), Y(D, j, Q), tH(X, D, Q), Y(D, Z, Q), tH(tt, D, Q), ts = !0, tn || (tr = [te(i, "change", t[34]), te(i, "input", t[34]), te(n, "change", t[35]), te(n, "input", t[35]), te(r, "change", t[36]), te(r, "input", t[36]), te(r, "change", t[31]), te(u, "change", t[37]), te(u, "input", t[37]), te(u, "change", t[31]), te(H, "change", t[38]), te(H, "input", t[38]), te(H, "change", t[31])], tn = !0)
            },
            p(t, e) {
                16 & e[0] && ta(i, t[4]), 32 & e[0] && ta(n, t[5]), 64 & e[0] && ta(r, t[6]), 128 & e[0] && ta(u, t[7]), 256 & e[0] && ta(H, t[8])
            },
            i(t) {
                ts || (tR(f.$$.fragment, t), tR(b.$$.fragment, t), tR(S.$$.fragment, t), tR(A.$$.fragment, t), tR(F.$$.fragment, t), tR(I.$$.fragment, t), tR(V.$$.fragment, t), tR(X.$$.fragment, t), tR(tt.$$.fragment, t), ts = !0)
            },
            o(t) {
                tF(f.$$.fragment, t), tF(b.$$.fragment, t), tF(S.$$.fragment, t), tF(A.$$.fragment, t), tF(F.$$.fragment, t), tF(I.$$.fragment, t), tF(V.$$.fragment, t), tF(X.$$.fragment, t), tF(tt.$$.fragment, t), ts = !1
            },
            d(t) {
                t && Q(e), t && Q(i), t && Q(s), t && Q(n), t && Q(a), t && Q(r), t && Q(l), t && Q(u), t && Q($), tj(f, t), t && Q(p), tj(b, t), t && Q(x), tj(S, t), t && Q(E), tj(A, t), t && Q(R), tj(F, t), t && Q(N), tj(I, t), t && Q(U), t && Q(z), t && Q(O), tj(V, t), t && Q(W), t && Q(H), t && Q(j), tj(X, t), t && Q(Z), tj(tt, t), tn = !1, D(tr)
            }
        }
    }

    function vZ(t) {
        let e, i, s, n, a, r, l = t[71] + "";

        function o(...e) {
            return t[63](t[73], ...e)
        }
        return {
            c() {
                e = J("div"), i = K(l), ti(s = J("div"), "class", n = "btn checkbox " + (t[28][t[73]] ? "active" : ""))
            },
            m(t, n) {
                Y(t, e, n), G(e, i), Y(t, s, n), a || (r = te(s, "click", o), a = !0)
            },
            p(e, i) {
                t = e, 268435456 & i[0] && n !== (n = "btn checkbox " + (t[28][t[73]] ? "active" : "")) && ti(s, "class", n)
            },
            d(t) {
                t && Q(e), t && Q(s), a = !1, r()
            }
        }
    }

    function yt(t) {
        let e, i, s, n = t[68].name + "";
        return {
            c() {
                e = J("option"), i = K(n), e.__value = s = t[68].val, e.value = e.__value
            },
            m(t, s) {
                Y(t, e, s), G(e, i)
            },
            p: C,
            d(t) {
                t && Q(e)
            }
        }
    }

    function ye(t) {
        let e, i, s, n, a, r = t[65].k.slice(2) + "";

        function l() {
            t[42].call(s, t[65])
        }

        function o(...e) {
            return t[43](t[65], ...e)
        }
        return {
            c() {
                e = J("div"), i = K(r), ti(s = J("input"), "type", "text")
            },
            m(r, c) {
                Y(r, e, c), G(e, i), Y(r, s, c), ta(s, t[0].current[t[65].k]), n || (a = [te(s, "input", l), te(s, "change", o)], n = !0)
            },
            p(e, n) {
                t = e, 1 & n[0] && r !== (r = t[65].k.slice(2) + "") && tn(i, r), 1 & n[0] && s.value !== t[0].current[t[65].k] && ta(s, t[0].current[t[65].k])
            },
            d(t) {
                t && Q(e), t && Q(s), n = !1, D(a)
            }
        }
    }

    function yi(t) {
        let e, i, s, n, a, r, l, o, c, d = t[1].name + "",
            u = t[29],
            $ = [];
        for (let h = 0; h < u.length; h += 1) $[h] = vG(vH(t, u, h));
        let m = [vK, vJ, vX, vQ, vY],
            _ = [];

        function f(t, e) {
            return "gfx" == t[1].id ? 0 : "controls" == t[1].id ? 1 : "audio" == t[1].id ? 2 : "ui" == t[1].id ? 3 : "chat" == t[1].id ? 4 : -1
        }
        return ~(l = f(t)) && (o = _[l] = m[l](t)), {
            c() {
                e = J("div"), i = J("div");
                for (let t = 0; t < $.length; t += 1) $[t].c();
                s = J("div"), n = J("h3"), a = K(d), r = J("div"), o && o.c(), ti(n, "class", "textprimary"), ti(r, "class", "settings svelte-ntyx09"), ti(s, "class", "menu panel-black scrollbar svelte-ntyx09"), ti(e, "class", "divide svelte-ntyx09")
            },
            m(t, o) {
                Y(t, e, o), G(e, i);
                for (let d = 0; d < $.length; d += 1) $[d].m(i, null);
                G(e, s), G(s, n), G(n, a), G(s, r), ~l && _[l].m(r, null), c = !0
            },
            p(t, e) {
                if (536870914 & e[0]) {
                    let s;
                    for (u = t[29], s = 0; s < u.length; s += 1) {
                        let n = vH(t, u, s);
                        $[s] ? $[s].p(n, e) : ($[s] = vG(n), $[s].c(), $[s].m(i, null))
                    }
                    for (; s < $.length; s += 1) $[s].d(1);
                    $.length = u.length
                }(!c || 2 & e[0]) && d !== (d = t[1].name + "") && tn(a, d);
                let h = l;
                (l = f(t)) === h ? ~l && _[l].p(t, e) : (o && (tA(), tF(_[h], 1, 1, () => {
                    _[h] = null
                }), t8()), ~l ? ((o = _[l]) || (o = _[l] = m[l](t)).c(), tR(o, 1), o.m(r, null)) : o = null)
            },
            i(t) {
                c || (tR(o), c = !0)
            },
            o(t) {
                tF(o), c = !1
            },
            d(t) {
                t && Q(e), X($, t), ~l && _[l].d()
            }
        }
    }
    let ys = t => "kb" == t.slice(0, 2);
    class yn extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v, y, b, x, w, k, C, S, E, P, M;
                N(e, im, t => s(3, n = t)), N(e, eW, t => s(4, a = t)), N(e, eV, t => s(5, r = t)), N(e, it, t => s(6, l = t)), N(e, eH, t => s(7, o = t)), N(e, ej, t => s(8, c = t)), N(e, se, t => s(9, d = t)), N(e, sb, t => s(10, u = t)), N(e, ia, t => s(11, $ = t)), N(e, ir, t => s(12, h = t)), N(e, il, t => s(13, m = t)), N(e, is, t => s(14, _ = t)), N(e, io, t => s(15, f = t)), N(e, i4, t => s(16, p = t)), N(e, iL, t => s(17, g = t)), N(e, iO, t => s(18, v = t)), N(e, ij, t => s(19, y = t)), N(e, iG, t => s(20, b = t)), N(e, iK, t => s(21, x = t)), N(e, iZ, t => s(22, w = t)), N(e, iQ, t => s(23, k = t)), N(e, iV, t => s(24, C = t)), N(e, i$, t => s(25, S = t)), N(e, id, t => s(26, E = t)), N(e, iu, t => s(27, P = t)), N(e, i3, t => s(28, M = t));
                let D = [{
                        id: "ui",
                        name: rC.ui.settings.interface
                    }, {
                        id: "gfx",
                        name: rC.ui.settings.graphics
                    }, {
                        id: "controls",
                        name: rC.ui.settings.controls
                    }, {
                        id: "chat",
                        name: rC.ui.settings.chat
                    }, {
                        id: "audio",
                        name: rC.ui.settings.audio
                    }],
                    T = D[0],
                    A = [{
                        val: "en",
                        name: "English"
                    }, {
                        val: "de",
                        name: "German"
                    }, {
                        val: "ru",
                        name: "Russian"
                    }, {
                        val: "zh",
                        name: "Chinese"
                    }, {
                        val: "pt",
                        name: "Portugese"
                    }, {
                        val: "es",
                        name: "Spanish"
                    }, {
                        val: "fr",
                        name: "French"
                    }, {
                        val: "ro",
                        name: "Romanian"
                    }, {
                        val: "it",
                        name: "Italian"
                    }, {
                        val: "nl",
                        name: "Dutch"
                    }, {
                        val: "vi",
                        name: "Vietnamese"
                    }, {
                        val: "hu",
                        name: "Hungarian"
                    }, {
                        val: "ro",
                        name: "Romanian"
                    }, {
                        val: "cs",
                        name: "Czech"
                    }, {
                        val: "pl",
                        name: "Polish"
                    }],
                    R = !1,
                    F = () => {
                        s(2, R = !0)
                    },
                    I = (t, e) => {
                        e.set("" === t ? void 0 : t), s(2, R = !0)
                    },
                    U = (t, e) => {
                        s(1, T = t)
                    },
                    z = (t, e) => {
                        I(sO[t.k], t.s)
                    },
                    O = (t, e) => L(i3, M[t] = M[t] ? 0 : 1, M),
                    B = () => {
                        L(im, n = !1), R && window.location.reload()
                    };
                return [sB, T, R, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v, y, b, x, w, k, C, S, E, P, M, D, A, F, I, U, function t() {
                    a = ts(this.value), eW.set(a)
                }, function t() {
                    r = ts(this.value), eV.set(r)
                }, function t() {
                    l = ts(this.value), it.set(l)
                }, function t() {
                    o = ts(this.value), eH.set(o)
                }, function t() {
                    c = ts(this.value), ej.set(c)
                }, function t() {
                    d = ts(this.value), se.set(d)
                }, function t() {
                    u = ts(this.value), sb.set(u)
                }, t => ({
                    k: t,
                    s: sB[t]
                }), function t(e) {
                    sO[e.k] = this.value, s(0, sB)
                }, z, function t() {
                    $ = ts(this.value), ia.set($)
                }, function t() {
                    h = ts(this.value), ir.set(h)
                }, function t() {
                    m = ts(this.value), il.set(m)
                }, function t() {
                    _ = ts(this.value), is.set(_)
                }, function t() {
                    f = to(this), io.set(f), s(30, A)
                }, t => iR.set(0), t => iR.set(dq.length), function t() {
                    p = ts(this.value), i4.set(p)
                }, function t() {
                    g = ts(this.value), iL.set(g)
                }, function t() {
                    v = this.value, iO.set(v)
                }, function t() {
                    y = ts(this.value), ij.set(y)
                }, function t() {
                    b = ts(this.value), iG.set(b)
                }, function t() {
                    x = ts(this.value), iK.set(x)
                }, function t() {
                    w = ts(this.value), iZ.set(w)
                }, function t() {
                    k = ts(this.value), iQ.set(k)
                }, function t() {
                    C = ts(this.value), iV.set(C)
                }, function t() {
                    S = ts(this.value), i$.set(S)
                }, function t() {
                    E = ts(this.value), id.set(E)
                }, function t() {
                    P = ts(this.value), iu.set(P)
                }, O, B]
            }, function t(e) {
                let i, s, n = e[3] && vj(e);
                return {
                    c() {
                        n && n.c(), i = tt()
                    },
                    m(t, e) {
                        n && n.m(t, e), Y(t, i, e), s = !0
                    },
                    p(t, e) {
                        t[3] ? n ? (n.p(t, e), 8 & e[0] && tR(n, 1)) : ((n = vj(t)).c(), tR(n, 1), n.m(i.parentNode, i)) : n && (tA(), tF(n, 1, 1, () => {
                            n = null
                        }), t8())
                    },
                    i(t) {
                        s || (tR(n), s = !0)
                    },
                    o(t) {
                        tF(n), s = !1
                    },
                    d(t) {
                        n && n.d(t), t && Q(i)
                    }
                }
            }, A, {}, [-1, -1, -1])
        }
    }
    let ya = (t, e, i, s, n, a) => yr(t, n, a) && yl(s, n, a) && yd(i, n, a) && y$(e, n, a),
        yr = (t, e, i) => t >= dL[e + i].level,
        yl = (t, e, i) => void 0 === dL[e + i].class || t === dL[e + i].class,
        yo = (t, e) => t + dC.get(e).skillpoints,
        yc = t => t.reduce(yo, 0),
        yd = (t, e, i) => "book" !== e || yu(t, dL[e + i].skillid) === dL[e + i].skilllevel,
        yu = (t, e) => t.reduce((t, i) => t + (i === e), 0),
        y$ = (t, e, i) => void 0 === dL[e + i].requiredSkill || t.indexOf(dL[e + i].requiredSkill) > 0,
        yh = (t, e, i) => void 0 === dL[e + i].buyElo || t >= dL[e + i].buyElo;

    function ym(t, e, i) {
        let s = t.slice();
        return s[23] = e[i], s
    }

    function y_(t, e, i) {
        let s = t.slice();
        return s[28] = e[i], s[30] = i, s
    }

    function yf(t, e, i) {
        let s = t.slice();
        return s[23] = e[i], s
    }

    function yp(t) {
        let e, i, s;
        return (i = new fg({
            props: {
                title: rC.ui.headers.skills,
                icon: "book",
                $$slots: {
                    default: [yC]
                },
                $$scope: {
                    ctx: t
                }
            }
        })).$on("close", t[15]), {
            c() {
                e = J("div"), tW(i.$$.fragment), ti(e, "class", "l-upperLeftModal container svelte-e2mar4")
            },
            m(n, a) {
                Y(n, e, a), tH(i, e, null), t[16](e), s = !0
            },
            p(t, e) {
                let s = {};
                255 & e[0] | 1 & e[1] && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }), i.$set(s)
            },
            i(t) {
                s || (tR(i.$$.fragment, t), s = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), s = !1
            },
            d(s) {
                s && Q(e), tj(i), t[16](null)
            }
        }
    }

    function yg(t) {
        let e, i;
        return e = new gP({
            props: {
                level: Math.max(1, t[23].level),
                skill: dC.get(t[23].id)
            }
        }), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            p(t, i) {
                let s = {};
                2 & i[0] && (s.level = Math.max(1, t[23].level)), 2 & i[0] && (s.skill = dC.get(t[23].id)), e.$set(s)
            },
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }

    function yv(t) {
        let e;
        return {
            c() {
                (e = J("div")).textContent = "Default", ti(e, "class", "textgrey")
            },
            m(t, i) {
                Y(t, e, i)
            },
            p: C,
            d(t) {
                t && Q(e)
            }
        }
    }

    function yy(t) {
        let e, i = Array(dC.get(t[23].id).skilllevels),
            s = [];
        for (let n = 0; n < i.length; n += 1) s[n] = yw(y_(t, i, n));
        return {
            c() {
                e = J("div");
                for (let t = 0; t < s.length; t += 1) s[t].c();
                ti(e, "class", "skillpoints svelte-e2mar4")
            },
            m(t, i) {
                Y(t, e, i);
                for (let n = 0; n < s.length; n += 1) s[n].m(e, null)
            },
            p(t, n) {
                if (6 & n[0]) {
                    let a;
                    for (i = Array(dC.get(t[23].id).skilllevels), a = 0; a < i.length; a += 1) {
                        let r = y_(t, i, a);
                        s[a] ? s[a].p(r, n) : (s[a] = yw(r), s[a].c(), s[a].m(e, null))
                    }
                    for (; a < s.length; a += 1) s[a].d(1);
                    s.length = i.length
                }
            },
            d(t) {
                t && Q(e), X(s, t)
            }
        }
    }

    function y0(t) {
        let e;
        return {
            c() {
                ti(e = J("div"), "class", "border grey")
            },
            m(t, i) {
                Y(t, e, i)
            },
            p: C,
            d(t) {
                t && Q(e)
            }
        }
    }

    function yb(t) {
        let e;
        return {
            c() {
                ti(e = J("div"), "class", "btn incbtn grey svelte-e2mar4")
            },
            m(t, i) {
                Y(t, e, i)
            },
            p: C,
            d(t) {
                t && Q(e)
            }
        }
    }

    function yx(t) {
        let e, i;
        return {
            c() {
                ti(e = J("div"), "class", i = "btn incbtn " + (t[2] ? "green" : "white") + " svelte-e2mar4")
            },
            m(t, i) {
                Y(t, e, i)
            },
            p(t, s) {
                4 & s[0] && i !== (i = "btn incbtn " + (t[2] ? "green" : "white") + " svelte-e2mar4") && ti(e, "class", i)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function yw(t) {
        let e;

        function i(t, e) {
            return t[30] + 1 <= t[23].level ? yx : t[30] + 1 <= t[23].learned ? yb : y0
        }
        let s = i(t),
            n = s(t);
        return {
            c() {
                n.c(), e = tt()
            },
            m(t, i) {
                n.m(t, i), Y(t, e, i)
            },
            p(t, a) {
                s === (s = i(t)) && n ? n.p(t, a) : (n.d(1), (n = s(t)) && (n.c(), n.m(e.parentNode, e)))
            },
            d(t) {
                n.d(t), t && Q(e)
            }
        }
    }

    function y1(t) {
        let e, i, s, n, a, r, l;

        function o(...e) {
            return t[12](t[23], ...e)
        }

        function c(t, e) {
            return (null == a || 66 & e[0]) && (a = !!(t[6] >= dC.get(t[23].id).skillpoints && t[23].level < dC.get(t[23].id).skilllevels && t[23].level < t[23].learned)), a ? y3 : y9
        }
        let d = c(t, [-1]),
            u = d(t);
        return {
            c() {
                e = J("div"), i = J("div"), s = K("-"), u.c(), ti(i, "class", n = "btn incbtn " + (t[23].level > 0 ? "grey" : "black disabled") + " svelte-e2mar4"), ti(e, "class", "skillpoints svelte-e2mar4")
            },
            m(t, n) {
                Y(t, e, n), G(e, i), G(i, s), u.m(e, null), r || (l = te(i, "click", o), r = !0)
            },
            p(s, a) {
                t = s, 2 & a[0] && n !== (n = "btn incbtn " + (t[23].level > 0 ? "grey" : "black disabled") + " svelte-e2mar4") && ti(i, "class", n), d === (d = c(t, a)) && u ? u.p(t, a) : (u.d(1), (u = d(t)) && (u.c(), u.m(e, null)))
            },
            d(t) {
                t && Q(e), u.d(), r = !1, l()
            }
        }
    }

    function y9(t) {
        let e;
        return {
            c() {
                (e = J("div")).textContent = "+", ti(e, "class", "btn incbtn black disabled svelte-e2mar4")
            },
            m(t, i) {
                Y(t, e, i)
            },
            p: C,
            d(t) {
                t && Q(e)
            }
        }
    }

    function y3(t) {
        let e, i, s;

        function n(...e) {
            return t[13](t[23], ...e)
        }
        return {
            c() {
                (e = J("div")).textContent = "+", ti(e, "id", "tutsetskillpoint"), ti(e, "class", "btn incbtn green svelte-e2mar4")
            },
            m(t, a) {
                Y(t, e, a), i || (s = te(e, "click", n), i = !0)
            },
            p(e, i) {
                t = e
            },
            d(t) {
                t && Q(e), i = !1, s()
            }
        }
    }

    function yk(t) {
        let e, i, s, n, a, r, l, o, c, d, u = rC.items.book[t[23].id].name + "",
            $ = t[23].engineOnly ? "" : "Lv. " + t[23].level;

        function h(t, e) {
            return t[23].engineOnly ? yv : yy
        }
        i = new fI({
            props: {
                descPos: "left:100%;top:0;",
                descRoot: t[0],
                border: "white",
                data: {},
                pickable: t[23].pickable,
                meta: {
                    type: "skill",
                    skill: dC.get(t[23].id)
                },
                css: "slotskill",
                img: `/assets/ui/skills/${t[23].id}.${rF}?v=5699699`,
                $$slots: {
                    default: [yg]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        let m = h(t),
            _ = m(t),
            f = !t[23].engineOnly && y1(t);
        return {
            c() {
                e = J("div"), tW(i.$$.fragment), s = J("div"), n = J("div"), a = K(u), r = Z(), _.c(), l = J("div"), o = J("div"), c = K($), f && f.c(), ti(n, "class", "textprimary name svelte-e2mar4"), ti(o, "class", "name svelte-e2mar4"), ti(e, "class", "panel-bright skillbox svelte-e2mar4")
            },
            m(t, u) {
                Y(t, e, u), tH(i, e, null), G(e, s), G(s, n), G(n, a), G(s, r), _.m(s, null), G(e, l), G(l, o), G(o, c), f && f.m(l, null), d = !0
            },
            p(t, e) {
                let n = {};
                1 & e[0] && (n.descRoot = t[0]), 2 & e[0] && (n.pickable = t[23].pickable), 2 & e[0] && (n.meta = {
                    type: "skill",
                    skill: dC.get(t[23].id)
                }), 2 & e[0] && (n.img = `/assets/ui/skills/${t[23].id}.${rF}?v=5699699`), 2 & e[0] | 1 & e[1] && (n.$$scope = {
                    dirty: e,
                    ctx: t
                }), i.$set(n), (!d || 2 & e[0]) && u !== (u = rC.items.book[t[23].id].name + "") && tn(a, u), m === (m = h(t)) && _ ? _.p(t, e) : (_.d(1), (_ = m(t)) && (_.c(), _.m(s, null))), (!d || 2 & e[0]) && $ !== ($ = t[23].engineOnly ? "" : "Lv. " + t[23].level) && tn(c, $), t[23].engineOnly ? f && (f.d(1), f = null) : f ? f.p(t, e) : ((f = y1(t)).c(), f.m(l, null))
            },
            i(t) {
                d || (tR(i.$$.fragment, t), d = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), d = !1
            },
            d(t) {
                t && Q(e), tj(i), _.d(), f && f.d()
            }
        }
    }

    function y2(t) {
        let e, i;
        return e = new gP({
            props: {
                level: 1,
                skill: t[23]
            }
        }), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            p(t, i) {
                let s = {};
                32 & i[0] && (s.skill = t[23]), e.$set(s)
            },
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }

    function y4(t) {
        let e, i, s, n, a, r, l, o, c, d = rC.items.book[t[23].id].name + "",
            u = t[23].minlevel + "";
        return i = new fI({
            props: {
                descPos: "left:100%;top:0;",
                descRoot: t[0],
                border: "grey filtered",
                data: {},
                pickable: !1,
                meta: {
                    type: "skill",
                    skill: t[23]
                },
                css: "slotskill",
                img: `/assets/ui/skills/${t[23].id}.${rF}?v=5699699`,
                $$slots: {
                    default: [y2]
                },
                $$scope: {
                    ctx: t
                }
            }
        }), {
            c() {
                e = J("div"), tW(i.$$.fragment), s = J("div"), n = J("div"), a = K(d), r = J("div"), l = K("Learnable Lv. "), o = K(u), ti(n, "class", "name svelte-e2mar4"), ti(s, "class", "textgrey"), ti(e, "class", "panel-bright skillbox svelte-e2mar4")
            },
            m(t, d) {
                Y(t, e, d), tH(i, e, null), G(e, s), G(s, n), G(n, a), G(s, r), G(r, l), G(r, o), c = !0
            },
            p(t, e) {
                let s = {};
                1 & e[0] && (s.descRoot = t[0]), 32 & e[0] && (s.meta = {
                    type: "skill",
                    skill: t[23]
                }), 32 & e[0] && (s.img = `/assets/ui/skills/${t[23].id}.${rF}?v=5699699`), 32 & e[0] | 1 & e[1] && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }), i.$set(s), (!c || 32 & e[0]) && d !== (d = rC.items.book[t[23].id].name + "") && tn(a, d), (!c || 32 & e[0]) && u !== (u = t[23].minlevel + "") && tn(o, u)
            },
            i(t) {
                c || (tR(i.$$.fragment, t), c = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), c = !1
            },
            d(t) {
                t && Q(e), tj(i)
            }
        }
    }

    function yC(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g = (t[4] ? t[4] : `Skill points: ${t[3]} / ${t[7][24]}`) + "",
            v = t[1],
            y = [];
        for (let b = 0; b < v.length; b += 1) y[b] = yk(yf(t, v, b));
        let x = t => tF(y[t], 1, 1, () => {
                y[t] = null
            }),
            w = Array.from(dC.values()).filter(t[14]).sort(yS),
            k = [];
        for (let C = 0; C < w.length; C += 1) k[C] = y4(ym(t, w, C));
        let S = t => tF(k[t], 1, 1, () => {
            k[t] = null
        });
        return {
            c() {
                e = J("div"), i = J("div"), s = J("span"), n = K(g), r = J("div"), l = K("Reset"), c = J("div"), d = K("Apply"), $ = Z(), h = J("div");
                for (let _ = 0; _ < y.length; _ += 1) y[_].c();
                m = tt();
                for (let f = 0; f < k.length; f += 1) k[f].c();
                ti(s, "class", a = t[4] ? "textred" : "textprimary"), ti(r, "class", o = "btn grey " + (t[2] ? "" : "disabled")), ti(c, "id", "tutapplyskills"), ti(c, "class", u = "btn " + (t[2] ? "green" : "grey disabled")), ti(i, "class", "panel-black bar svelte-e2mar4"), ti(h, "id", "skilllist"), ti(h, "class", "scrollbar skilllist svelte-e2mar4"), ti(e, "class", "flexer svelte-e2mar4")
            },
            m(a, o) {
                Y(a, e, o), G(e, i), G(i, s), G(s, n), G(i, r), G(r, l), G(i, c), G(c, d), G(e, $), G(e, h);
                for (let u = 0; u < y.length; u += 1) y[u].m(h, null);
                G(h, m);
                for (let g = 0; g < k.length; g += 1) k[g].m(h, null);
                _ = !0, f || (p = [te(r, "click", t[11]), te(c, "click", t[9])], f = !0)
            },
            p(t, e) {
                if ((!_ || 152 & e[0]) && g !== (g = (t[4] ? t[4] : `Skill points: ${t[3]} / ${t[7][24]}`) + "") && tn(n, g), (!_ || 16 & e[0] && a !== (a = t[4] ? "textred" : "textprimary")) && ti(s, "class", a), (!_ || 4 & e[0] && o !== (o = "btn grey " + (t[2] ? "" : "disabled"))) && ti(r, "class", o), (!_ || 4 & e[0] && u !== (u = "btn " + (t[2] ? "green" : "grey disabled"))) && ti(c, "class", u), 1095 & e[0]) {
                    let i;
                    for (v = t[1], i = 0; i < v.length; i += 1) {
                        let l = yf(t, v, i);
                        y[i] ? (y[i].p(l, e), tR(y[i], 1)) : (y[i] = yk(l), y[i].c(), tR(y[i], 1), y[i].m(h, m))
                    }
                    for (tA(), i = v.length; i < y.length; i += 1) x(i);
                    t8()
                }
                if (33 & e[0]) {
                    let d;
                    for (w = Array.from(dC.values()).filter(t[14]).sort(yS), d = 0; d < w.length; d += 1) {
                        let $ = ym(t, w, d);
                        k[d] ? (k[d].p($, e), tR(k[d], 1)) : (k[d] = y4($), k[d].c(), tR(k[d], 1), k[d].m(h, null))
                    }
                    for (tA(), d = w.length; d < k.length; d += 1) S(d);
                    t8()
                }
            },
            i(t) {
                if (!_) {
                    for (let e = 0; e < v.length; e += 1) tR(y[e]);
                    for (let i = 0; i < w.length; i += 1) tR(k[i]);
                    _ = !0
                }
            },
            o(t) {
                y = y.filter(Boolean);
                for (let e = 0; e < y.length; e += 1) tF(y[e]);
                k = k.filter(Boolean);
                for (let i = 0; i < k.length; i += 1) tF(k[i]);
                _ = !1
            },
            d(t) {
                t && Q(e), X(y, t), X(k, t), f = !1, D(p)
            }
        }
    }
    let yS = (t, e) => t.minlevel - e.minlevel;
    class y7 extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a, r, l, o, c;
                N(e, eS, t => s(4, n = t)), N(e, eC, t => s(19, a = t)), N(e, e4, t => s(5, r = t)), N(e, eI, t => s(7, l = t)), N(e, i_, t => s(8, o = t));
                let d = t => {
                        let e = [];
                        return t.forEach((t, i) => {
                            if (!t.engineOnly)
                                for (let s = 0; s < t.level; ++s) e.push(t.id)
                        }), e
                    },
                    u = () => {
                        $1("skillconfig", _), s(2, h = !1), L(eS, n = void 0), dY(28, 100)
                    },
                    $ = [],
                    h = !1,
                    m = (t, e) => {
                        s(1, $ = []), t.forEach((t, i) => {
                            let s = dC.get(i);
                            $.push({
                                id: i,
                                level: t,
                                minlevel: s.minlevel,
                                learned: e.get(i) || 0,
                                engineOnly: s.engineOnly,
                                pickable: void 0 !== s.onCast
                            })
                        }), e.forEach((e, i) => {
                            if (!t.has(i)) {
                                let s = dC.get(i);
                                $.push({
                                    id: i,
                                    level: 0,
                                    minlevel: s.minlevel,
                                    learned: e,
                                    engineOnly: s.engineOnly,
                                    pickable: void 0 !== s.onCast
                                })
                            }
                        }), $.sort((t, e) => t.id - e.id), f = d($), s(3, p = yc(f))
                    },
                    _ = [],
                    f = [],
                    p = 0,
                    g = (t, e) => {
                        t.level += e, s(1, $), dY(27, 100), y()
                    },
                    v = () => {
                        m(a, r), y()
                    },
                    y = () => {
                        _ = d($), s(3, p = yc(_)), s(2, h = _.length && _.sort().join(",") !== f.sort().join(","))
                    },
                    b = (t, e) => g(t, -1),
                    x = (t, e) => g(t, 1),
                    w = t => t.class === as.player.class && !t.engineOnly && !r.has(t.id),
                    k = () => {
                        L(i_, o = !1)
                    },
                    C;
                return e.$$.update = () => {
                    524320 & e.$$.dirty[0] && m(a, r), 16 & e.$$.dirty[0] && n && s(2, h = !0), 136 & e.$$.dirty[0] && s(6, C = l[24] - p)
                }, [c, $, h, p, n, r, C, l, o, u, g, v, b, x, w, k, function t(e) {
                    tw[e ? "unshift" : "push"](() => {
                        s(0, c = e)
                    })
                }]
            }, function t(e) {
                let i, s, n = e[8] && yp(e);
                return {
                    c() {
                        n && n.c(), i = tt()
                    },
                    m(t, e) {
                        n && n.m(t, e), Y(t, i, e), s = !0
                    },
                    p(t, e) {
                        t[8] ? n ? (n.p(t, e), 256 & e[0] && tR(n, 1)) : ((n = yp(t)).c(), tR(n, 1), n.m(i.parentNode, i)) : n && (tA(), tF(n, 1, 1, () => {
                            n = null
                        }), t8())
                    },
                    i(t) {
                        s || (tR(n), s = !0)
                    },
                    o(t) {
                        tF(n), s = !1
                    },
                    d(t) {
                        n && n.d(t), t && Q(i)
                    }
                }
            }, A, {}, [-1, -1])
        }
    }

    function yE(t, e, i) {
        let s = t.slice();
        return s[19] = e[i], s[21] = i, s
    }

    function y6(t) {
        let e, i, s = t[1],
            n = [];
        for (let a = 0; a < s.length; a += 1) n[a] = yM(yE(t, s, a));
        let r = null;
        return s.length || (r = yP()), {
            c() {
                e = J("div");
                for (let t = 0; t < n.length; t += 1) n[t].c();
                i = tt(), r && r.c(), ti(e, "class", "divider")
            },
            m(t, s) {
                Y(t, e, s);
                for (let a = 0; a < n.length; a += 1) n[a].m(t, s);
                Y(t, i, s), r && r.m(t, s)
            },
            p(t, e) {
                if (74 & e) {
                    let a;
                    for (s = t[1], a = 0; a < s.length; a += 1) {
                        let l = yE(t, s, a);
                        n[a] ? n[a].p(l, e) : (n[a] = yM(l), n[a].c(), n[a].m(i.parentNode, i))
                    }
                    for (; a < n.length; a += 1) n[a].d(1);
                    n.length = s.length, s.length ? r && (r.d(1), r = null) : r || ((r = yP()).c(), r.m(i.parentNode, i))
                }
            },
            d(t) {
                t && Q(e), X(n, t), t && Q(i), r && r.d(t)
            }
        }
    }

    function yP(t) {
        let e;
        return {
            c() {
                (e = J("div")).textContent = "No results", ti(e, "class", "textgrey result svelte-17jb1r5")
            },
            m(t, i) {
                Y(t, e, i)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function yM(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $ = t[19].name + "",
            h = t[19].type + "",
            m = (t[19].level || 1) + "";

        function _(...e) {
            return t[14](t[21], ...e)
        }
        return {
            c() {
                e = J("div"), i = J("span"), s = K($), n = J("span"), a = K(h), r = J("span"), l = K("Lv. "), o = K(m), ti(n, "class", "textgrey infocol svelte-17jb1r5"), ti(r, "class", "infocol svelte-17jb1r5"), ti(e, "class", c = "result " + (t[21] === t[3] ? "sel" : "") + " svelte-17jb1r5")
            },
            m(t, c) {
                Y(t, e, c), G(e, i), G(i, s), G(e, n), G(n, a), G(e, r), G(r, l), G(r, o), d || (u = te(e, "mousedown", _), d = !0)
            },
            p(i, n) {
                t = i, 2 & n && $ !== ($ = t[19].name + "") && tn(s, $), 2 & n && h !== (h = t[19].type + "") && tn(a, h), 2 & n && m !== (m = (t[19].level || 1) + "") && tn(o, m), 8 & n && c !== (c = "result " + (t[21] === t[3] ? "sel" : "") + " svelte-17jb1r5") && ti(e, "class", c)
            },
            d(t) {
                t && Q(e), d = !1, u()
            }
        }
    }
    class y5 extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n = t0(),
                    a = dB.filter(t => t.level <= 45).map(t => ({
                        name: rS(t.type, t.tier),
                        type: t.type,
                        tier: t.tier,
                        level: t.level
                    })),
                    r = () => {
                        let t = u.toLowerCase();
                        t.length ? s(1, h = a.filter(e => e.type === t || e.name.toLowerCase().includes(t)).slice(0, $)) : s(1, h = []), _ >= h.length && f(h.length - 1)
                    },
                    l, o, {
                        type: c
                    } = i,
                    {
                        tier: d
                    } = i,
                    {
                        name: u = ""
                    } = i,
                    {
                        limit: $ = 5
                    } = i,
                    h = [],
                    m = !1,
                    _ = -1,
                    f = t => {
                        s(3, _ = t), _ >= 0 ? (s(0, u = (l = h[_]).name), s(8, c = l.type), s(9, d = l.tier)) : (l = void 0, s(0, u = ""), s(8, c = "all"), s(9, d = "all"))
                    },
                    p = t => {
                        t.target == o && ((38 === t.keyCode || 40 === t.keyCode) && h.length ? (f(aB(_ + (38 === t.keyCode ? -1 : 1), h.length)), t.preventDefault()) : 13 != t.keyCode && 27 != t.keyCode || o.blur())
                    },
                    g = t => {
                        s(2, m = !1), f(Math.min(Math.max(0, _), h.length - 1)), _ >= 0 && n("finalize")
                    };
                tg(() => {
                    document.addEventListener("keydown", p)
                }), ty(() => {
                    document.removeEventListener("keydown", p), s(4, o = void 0)
                });
                let v = t => s(2, m = !0),
                    y = (t, e) => f(t);
                return e.$$set = t => {
                    "type" in t && s(8, c = t.type), "tier" in t && s(9, d = t.tier), "name" in t && s(0, u = t.name), "limit" in t && s(10, $ = t.limit)
                }, [u, h, m, _, o, r, f, g, c, d, $, function t(e) {
                    tw[e ? "unshift" : "push"](() => {
                        s(4, o = e)
                    })
                }, function t() {
                    s(0, u = this.value)
                }, v, y]
            }, function t(e) {
                let i, s, n, a, r, l, o = e[2] && y6(e);
                return {
                    c() {
                        i = J("div"), s = J("div"), n = J("input"), o && o.c(), ti(n, "placeholder", rC.ui.merchant.itemSearch), ti(n, "type", "search"), ti(s, "class", a = "container input " + (e[2] ? "focus" : "")), ti(i, "class", "navbtn finder")
                    },
                    m(t, a) {
                        Y(t, i, a), G(i, s), G(s, n), e[11](n), ta(n, e[0]), o && o.m(s, null), r || (l = [te(n, "input", e[12]), te(n, "input", e[5]), te(n, "focus", e[13]), te(n, "blur", e[7])], r = !0)
                    },
                    p(t, [e]) {
                        1 & e && ta(n, t[0]), t[2] ? o ? o.p(t, e) : ((o = y6(t)).c(), o.m(s, null)) : o && (o.d(1), o = null), 4 & e && a !== (a = "container input " + (t[2] ? "focus" : "")) && ti(s, "class", a)
                    },
                    i: C,
                    o: C,
                    d(t) {
                        t && Q(i), e[11](null), o && o.d(), r = !1, D(l)
                    }
                }
            }, A, {
                type: 8,
                tier: 9,
                name: 0,
                limit: 10
            })
        }
    }
    let yD = t => 9 + Math.ceil(.015 * t);

    function yT(t, e, i) {
        let s = t.slice();
        return s[53] = e[i], s
    }

    function yA(t, e, i) {
        let s = t.slice();
        return s[56] = e[i], s[58] = i, s
    }

    function y8(t) {
        let e, i, s;
        return (i = new fg({
            props: {
                title: "Merchant",
                $$slots: {
                    default: [yq]
                },
                $$scope: {
                    ctx: t
                }
            }
        })).$on("close", t[46]), {
            c() {
                e = J("div"), tW(i.$$.fragment), ti(e, "class", "l-upperLeftModal container svelte-afakdv")
            },
            m(t, n) {
                Y(t, e, n), tH(i, e, null), s = !0
            },
            p(t, e) {
                let s = {};
                917503 & e[0] | 268435456 & e[1] && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }), i.$set(s)
            },
            i(t) {
                s || (tR(i.$$.fragment, t), s = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), s = !1
            },
            d(t) {
                t && Q(e), tj(i)
            }
        }
    }

    function yR(t) {
        let e, i, s, n, a, r = t[56] + "";

        function l(...e) {
            return t[40](t[56], ...e)
        }
        return {
            c() {
                e = J("div"), i = K(r), ti(e, "class", s = "choice " + (t[56] == t[1] ? "active" : "") + " svelte-afakdv")
            },
            m(t, s) {
                Y(t, e, s), G(e, i), n || (a = te(e, "click", l), n = !0)
            },
            p(i, n) {
                t = i, 2 & n[0] && s !== (s = "choice " + (t[56] == t[1] ? "active" : "") + " svelte-afakdv") && ti(e, "class", s)
            },
            d(t) {
                t && Q(e), n = !1, a()
            }
        }
    }

    function yF(t) {
        let e;
        return {
            c() {
                ti(e = J("div"), "class", "divider svelte-afakdv")
            },
            m(t, i) {
                Y(t, e, i)
            },
            p: C,
            d(t) {
                t && Q(e)
            }
        }
    }

    function yN(t) {
        var e;
        let i, s = (null === (e = t)[56] ? yF : yR)(t);
        return {
            c() {
                s.c(), i = tt()
            },
            m(t, e) {
                s.m(t, e), Y(t, i, e)
            },
            p(t, e) {
                s.p(t, e)
            },
            d(t) {
                s.d(t), t && Q(i)
            }
        }
    }

    function yI(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v, y, b = rS(t[53].temp.type, t[53].temp.tier) + "",
            x = (t[53].temp.logic.level || 1) + "",
            w = t[53].temp.owner + "",
            k = t[25](t[53].temp.auction.getTime()) + "",
            C = t[8] && t[53].temp.stacks > 0 ? t[53].temp.stacks + " x " : "";

        function S(...e) {
            return t[43](t[53], ...e)
        }
        return i = new vw({
            props: {
                descPos: "right:0;top:0;",
                descRoot: t[0],
                pickable: !1,
                item: t[53]
            }
        }), f = new gM({
            props: {
                amount: t[8] && t[53].temp.stacks > 0 ? Math.ceil(t[53].temp.auctionprice / t[53].temp.stacks) : t[53].temp.auctionprice
            }
        }), {
            c() {
                e = J("div"), tW(i.$$.fragment), s = J("span"), n = K(b), r = J("span"), l = K(x), c = J("span"), d = K(w), u = J("span"), $ = K(k), h = J("div"), m = J("span"), _ = K(C), tW(f.$$.fragment), ti(s, "class", a = "marg text" + dF(t[53].temp.quality)[0] + " svelte-afakdv"), tr(s, "margin-left", "6px"), ti(r, "class", o = "marg " + (as.player.level >= t[53].temp.logic.level ? "textgreen" : "textred") + " svelte-afakdv"), ti(c, "class", "marg svelte-afakdv"), ti(u, "class", "marg svelte-afakdv"), ti(m, "class", "textgreen"), ti(h, "class", "marg svelte-afakdv"), tr(h, "text-align", "end"), ti(e, "class", p = "buy " + (t[16] == t[53] ? "selected" : "") + " item panel-black svelte-afakdv")
            },
            m(t, a) {
                Y(t, e, a), tH(i, e, null), G(e, s), G(s, n), G(e, r), G(r, l), G(e, c), G(c, d), G(e, u), G(u, $), G(e, h), G(h, m), G(m, _), tH(f, h, null), g = !0, v || (y = te(e, "click", S), v = !0)
            },
            p(c, u) {
                t = c;
                let h = {};
                1 & u[0] && (h.descRoot = t[0]), 32768 & u[0] && (h.item = t[53]), i.$set(h), (!g || 32768 & u[0]) && b !== (b = rS(t[53].temp.type, t[53].temp.tier) + "") && tn(n, b), (!g || 32768 & u[0] && a !== (a = "marg text" + dF(t[53].temp.quality)[0] + " svelte-afakdv")) && ti(s, "class", a), (!g || 32768 & u[0]) && x !== (x = (t[53].temp.logic.level || 1) + "") && tn(l, x), (!g || 32768 & u[0] && o !== (o = "marg " + (as.player.level >= t[53].temp.logic.level ? "textgreen" : "textred") + " svelte-afakdv")) && ti(r, "class", o), (!g || 32768 & u[0]) && w !== (w = t[53].temp.owner + "") && tn(d, w), (!g || 32768 & u[0]) && k !== (k = t[25](t[53].temp.auction.getTime()) + "") && tn($, k), (!g || 33024 & u[0]) && C !== (C = t[8] && t[53].temp.stacks > 0 ? t[53].temp.stacks + " x " : "") && tn(_, C);
                let m = {};
                33024 & u[0] && (m.amount = t[8] && t[53].temp.stacks > 0 ? Math.ceil(t[53].temp.auctionprice / t[53].temp.stacks) : t[53].temp.auctionprice), f.$set(m), (!g || 98304 & u[0] && p !== (p = "buy " + (t[16] == t[53] ? "selected" : "") + " item panel-black svelte-afakdv")) && ti(e, "class", p)
            },
            i(t) {
                g || (tR(i.$$.fragment, t), tR(f.$$.fragment, t), g = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), tF(f.$$.fragment, t), g = !1
            },
            d(t) {
                t && Q(e), tj(i), tj(f), v = !1, y()
            }
        }
    }

    function yU(t) {
        let e, i, s, n, a = [yL, yO],
            r = [];

        function l(t, e) {
            return t[16].temp.owner !== as.player.name ? 0 : 1
        }
        return s = r[i = l(t)] = a[i](t), {
            c() {
                e = J("section"), s.c(), ti(e, "class", "confirm panel-black svelte-afakdv")
            },
            m(t, s) {
                Y(t, e, s), r[i].m(e, null), n = !0
            },
            p(t, n) {
                let o = i;
                (i = l(t)) === o ? r[i].p(t, n) : (tA(), tF(r[o], 1, 1, () => {
                    r[o] = null
                }), t8(), (s = r[i]) || (s = r[i] = a[i](t)).c(), tR(s, 1), s.m(e, null))
            },
            i(t) {
                n || (tR(s), n = !0)
            },
            o(t) {
                tF(s), n = !1
            },
            d(t) {
                t && Q(e), r[i].d()
            }
        }
    }

    function yz(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v, y, b, x, w, k, C = (t[18] ? rS(t[18].type, t[18].tier) : rC.ui.merchant.dragitem) + "",
            S = rC.ui.merchant.price + "",
            E = rC.ui.merchant.fee + "",
            P = rC.ui.merchant.post + "";
        (i = new vw({
            props: {
                descPos: "left:100%;bottom:100%;",
                clearOnMove: !0,
                invslot: void 0,
                pickable: !0,
                item: eP
            }
        })).$on("discard", t[24]), i.$on("move", t[23]), i.$on("click", t[24]), i.$on("context", t[24]), d = new gM({
            props: {
                amount: t[11]
            }
        }), f = new gM({
            props: {
                amount: t[13]
            }
        });
        let M = t[18] && t[18].stacks > 0 && yB(t);
        return {
            c() {
                e = J("section"), tW(i.$$.fragment), s = J("span"), n = K(C), r = J("div"), l = J("span"), o = K(S), c = K(": "), tW(d.$$.fragment), u = Z(), $ = J("br"), h = J("span"), m = K(E), _ = K(": "), tW(f.$$.fragment), p = J("input"), M && M.c(), g = J("div"), v = K(P), ti(s, "class", a = "marg text" + (t[18] ? dF(t[18].quality)[0] : "grey") + " svelte-afakdv"), ti(l, "class", "textwhite"), ti(h, "class", "textgrey"), ti(r, "class", "marg svelte-afakdv"), tr(r, "text-align", "end"), ti(p, "class", "marg svelte-afakdv"), ti(p, "type", "number"), ti(p, "placeholder", rC.ui.merchant.setPrice), ti(g, "class", y = "marg btn formatted secondary " + (t[14] ? "" : "disabled") + " svelte-afakdv"), ti(e, "class", b = "post " + (t[18] && t[18].stacks > 0 ? "postStacks" : "") + " panel-black svelte-afakdv")
            },
            m(a, y) {
                Y(a, e, y), tH(i, e, null), G(e, s), G(s, n), G(e, r), G(r, l), G(l, o), G(l, c), tH(d, l, null), G(l, u), G(r, $), G(r, h), G(h, m), G(h, _), tH(f, h, null), G(e, p), ta(p, t[10]), M && M.m(e, null), G(e, g), G(g, v), x = !0, w || (k = [te(p, "input", t[44]), te(g, "click", t[22])], w = !0)
            },
            p(t, i) {
                (!x || 262144 & i[0]) && C !== (C = (t[18] ? rS(t[18].type, t[18].tier) : rC.ui.merchant.dragitem) + "") && tn(n, C), (!x || 262144 & i[0] && a !== (a = "marg text" + (t[18] ? dF(t[18].quality)[0] : "grey") + " svelte-afakdv")) && ti(s, "class", a);
                let r = {};
                2048 & i[0] && (r.amount = t[11]), d.$set(r);
                let l = {};
                8192 & i[0] && (l.amount = t[13]), f.$set(l), 1024 & i[0] && ts(p.value) !== t[10] && ta(p, t[10]), t[18] && t[18].stacks > 0 ? M ? M.p(t, i) : ((M = yB(t)).c(), M.m(e, g)) : M && (M.d(1), M = null), (!x || 16384 & i[0] && y !== (y = "marg btn formatted secondary " + (t[14] ? "" : "disabled") + " svelte-afakdv")) && ti(g, "class", y), (!x || 262144 & i[0] && b !== (b = "post " + (t[18] && t[18].stacks > 0 ? "postStacks" : "") + " panel-black svelte-afakdv")) && ti(e, "class", b)
            },
            i(t) {
                x || (tR(i.$$.fragment, t), tR(d.$$.fragment, t), tR(f.$$.fragment, t), x = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), tF(d.$$.fragment, t), tF(f.$$.fragment, t), x = !1
            },
            d(t) {
                t && Q(e), tj(i), tj(d), tj(f), M && M.d(), w = !1, D(k)
            }
        }
    }

    function yO(t) {
        let e, i, s, n, a, r, l, o, c, d, u = rS(t[16].temp.type, t[16].temp.tier) + "";
        return {
            c() {
                e = J("span"), i = K("Stop "), s = J("span"), n = K(u), r = K(" from being listed?"), (l = J("div")).textContent = "" + rC.ui.cancel, (o = J("div")).textContent = "" + rC.ui.merchant.delist, ti(s, "class", a = "text" + dF(t[16].temp.quality)[0] + " svelte-afakdv"), ti(e, "class", "marg svelte-afakdv"), ti(l, "class", "marg btn formatted grey svelte-afakdv"), ti(o, "class", "marg btn formatted orange svelte-afakdv")
            },
            m(a, u) {
                Y(a, e, u), G(e, i), G(e, s), G(s, n), G(e, r), Y(a, l, u), Y(a, o, u), c || (d = [te(l, "click", t[27]), te(o, "click", t[29])], c = !0)
            },
            p(t, e) {
                65536 & e[0] && u !== (u = rS(t[16].temp.type, t[16].temp.tier) + "") && tn(n, u), 65536 & e[0] && a !== (a = "text" + dF(t[16].temp.quality)[0] + " svelte-afakdv") && ti(s, "class", a)
            },
            i: C,
            o: C,
            d(t) {
                t && Q(e), t && Q(l), t && Q(o), c = !1, D(d)
            }
        }
    }

    function yL(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v, y = rC.ui.merchant.buyItem[0] + "",
            b = t[16].temp.stacks > 0 ? t[16].temp.stacks + " x " : "",
            x = rS(t[16].temp.type, t[16].temp.tier) + "",
            w = rC.ui.merchant.buyItem[1] + "",
            k = rC.ui.merchant.buyItem[2] + "";
        return $ = new gM({
            props: {
                amount: t[16].temp.auctionprice
            }
        }), {
            c() {
                e = J("span"), i = K(y), s = Z(), n = J("span"), a = K(b), r = J("span"), l = K(x), c = Z(), d = K(w), u = Z(), tW($.$$.fragment), h = Z(), m = K(k), (_ = J("div")).textContent = "" + rC.ui.cancel, (f = J("div")).textContent = "" + rC.ui.merchant.buy, ti(n, "class", "textgreen"), ti(r, "class", o = "text" + dF(t[16].temp.quality)[0] + " svelte-afakdv"), ti(e, "class", "marg svelte-afakdv"), ti(_, "class", "marg btn formatted grey svelte-afakdv"), ti(f, "class", "marg btn formatted secondary svelte-afakdv")
            },
            m(o, y) {
                Y(o, e, y), G(e, i), G(e, s), G(e, n), G(n, a), G(e, r), G(r, l), G(e, c), G(e, d), G(e, u), tH($, e, null), G(e, h), G(e, m), Y(o, _, y), Y(o, f, y), p = !0, g || (v = [te(_, "click", t[27]), te(f, "click", t[28])], g = !0)
            },
            p(t, e) {
                (!p || 65536 & e[0]) && b !== (b = t[16].temp.stacks > 0 ? t[16].temp.stacks + " x " : "") && tn(a, b), (!p || 65536 & e[0]) && x !== (x = rS(t[16].temp.type, t[16].temp.tier) + "") && tn(l, x), (!p || 65536 & e[0] && o !== (o = "text" + dF(t[16].temp.quality)[0] + " svelte-afakdv")) && ti(r, "class", o);
                let i = {};
                65536 & e[0] && (i.amount = t[16].temp.auctionprice), $.$set(i)
            },
            i(t) {
                p || (tR($.$$.fragment, t), p = !0)
            },
            o(t) {
                tF($.$$.fragment, t), p = !1
            },
            d(t) {
                t && Q(e), tj($), t && Q(_), t && Q(f), g = !1, D(v)
            }
        }
    }

    function yB(t) {
        let e, i, s, n, a, r, l;
        return {
            c() {
                e = J("select"), (i = J("option")).textContent = "Total", (n = J("option")).textContent = "Per Unit", i.__value = s = !1, i.value = i.__value, n.__value = a = !0, n.value = n.__value, ti(e, "class", "marg formatted svelte-afakdv"), void 0 === t[12] && t4(() => t[45].call(e))
            },
            m(s, a) {
                Y(s, e, a), G(e, i), G(e, n), tl(e, t[12]), r || (l = te(e, "change", t[45]), r = !0)
            },
            p(t, i) {
                4096 & i[0] && tl(e, t[12])
            },
            d(t) {
                t && Q(e), r = !1, l()
            }
        }
    }

    function yq(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v, y, b, x, w, k, C, S, E, P, M, T, A, R, F, N, I, U, z, O, L, B, q, V, W, H, j, tt, ts, ta, tl, to, tc, td = rC.ui.merchant.search + "",
            tu = rC.ui.merchant.previous + "",
            t$ = rC.ui.merchant.next + "",
            th = rC.ui.merchant.results + "",
            tm = t[9] + 1 + "",
            t_ = Math.ceil(t[19] / 50) + "",
            tf = t[30](t[5], "time", t[6]) + "",
            tp = rC.ui.merchant.time + "",
            tg = (t[7] ? rC.ui.merchant.perUnit : rC.ui.merchant.total) + "",
            tv = t[30](t[5], "price", t[6]) + "",
            ty = rC.ui.merchant.price + "";

        function t0(e) {
            t[33].call(null, e)
        }

        function tb(e) {
            t[34].call(null, e)
        }

        function tx(e) {
            t[35].call(null, e)
        }
        let t1 = {
            limit: 10
        };
        void 0 !== t[3] && (t1.name = t[3]), void 0 !== t[2] && (t1.tier = t[2]), void 0 !== t[1] && (t1.type = t[1]), s = new y5({
            props: t1
        }), tw.push(() => tV(s, "name", t0)), tw.push(() => tV(s, "tier", tb)), tw.push(() => tV(s, "type", tx)), s.$on("finalize", t[21]);
        let t9 = t[20],
            t3 = [];
        for (let tk = 0; tk < t9.length; tk += 1) t3[tk] = yN(yA(t, t9, tk));
        let t2 = t[15],
            t4 = [];
        for (let tS = 0; tS < t2.length; tS += 1) t4[tS] = yI(yT(t, t2, tS));
        let t7 = t => tF(t4[t], 1, 1, () => {
                t4[t] = null
            }),
            tE = [yz, yU],
            t6 = [];

        function tP(t, e) {
            return t[16] ? 1 : 0
        }
        return ta = t6[ts = tP(t)] = tE[ts](t), {
            c() {
                e = J("div"), i = J("section"), tW(s.$$.fragment), l = J("span"), o = J("div"), c = K(td), u = J("div"), $ = K(tu), m = J("div"), _ = K(t$), p = J("section");
                for (let n = 0; n < t3.length; n += 1) t3[n].c();
                g = J("section"), v = J("div"), y = J("div"), b = J("div"), x = J("span"), w = J("span"), k = K(t[19]), C = Z(), S = K(th), E = K(" ("), P = K(tm), M = K("/"), T = K(t_), A = K(")"), (R = J("span")).textContent = "Lv.", (F = J("span")).textContent = "" + rC.ui.merchant.owner, N = J("span"), I = K(tf), U = K(tp), O = J("span"), L = K(tg), q = J("span"), V = K(tv), W = K(ty), H = Z(), tt = J("div");
                for (let a = 0; a < t4.length; a += 1) t4[a].c();
                ta.c(), ti(o, "class", d = "btn formatted secondary " + (t[4] ? "" : "disabled")), ti(u, "class", h = "btn formatted grey " + (t[4] && t[9] > 0 ? "" : "disabled")), ti(m, "class", f = "btn formatted grey " + (t[4] && 50 == t[15].length ? "" : "disabled")), ti(i, "class", "search panel-black svelte-afakdv"), ti(p, "class", "choices border grey scrollbar svelte-afakdv"), ti(w, "class", "btn black disabled textgrey"), ti(R, "class", "btn black disabled textgrey"), ti(F, "class", "btn black disabled textgrey"), ti(N, "class", z = "btn grey " + (t[4] ? "" : "disabled") + " " + ("time" == t[5] ? "textprimary active" : "")), ti(O, "class", B = "btn grey " + (t[4] ? "" : "disabled") + " " + (t[7] ? "textgreen" : "")), tr(O, "text-align", "end"), ti(q, "class", j = "btn grey " + (t[4] ? "" : "disabled") + " " + ("price" == t[5] ? "textprimary active" : "")), tr(q, "text-align", "end"), ti(b, "class", "buytblhead svelte-afakdv"), ti(y, "class", "scrollbar scrollbar-fix"), ti(tt, "class", "scrollbar scrollbar-fix"), ti(v, "class", "buytable svelte-afakdv"), ti(g, "class", "items border grey svelte-afakdv"), ti(e, "class", "layout svelte-afakdv")
            },
            m(n, a) {
                Y(n, e, a), G(e, i), tH(s, i, null), G(i, l), G(i, o), G(o, c), G(i, u), G(u, $), G(i, m), G(m, _), t[39](i), G(e, p);
                for (let r = 0; r < t3.length; r += 1) t3[r].m(p, null);
                G(e, g), G(g, v), G(v, y), G(y, b), G(b, x), G(b, w), G(w, k), G(w, C), G(w, S), G(w, E), G(w, P), G(w, M), G(w, T), G(w, A), G(b, R), G(b, F), G(b, N), G(N, I), G(N, U), G(b, O), G(O, L), G(b, q), G(q, V), G(q, W), G(q, H), G(v, tt);
                for (let d = 0; d < t4.length; d += 1) t4[d].m(tt, null);
                t6[ts].m(e, null), tl = !0, to || (tc = [te(o, "click", t[36]), te(u, "click", t[37]), te(m, "click", t[38]), te(N, "click", t[41]), te(O, "click", t[32]), te(q, "click", t[42])], to = !0)
            },
            p(t, i) {
                let l = {};
                if (!n && 8 & i[0] && (n = !0, l.name = t[3], tC(() => n = !1)), !a && 4 & i[0] && (a = !0, l.tier = t[2], tC(() => a = !1)), !r && 2 & i[0] && (r = !0, l.type = t[1], tC(() => r = !1)), s.$set(l), (!tl || 16 & i[0] && d !== (d = "btn formatted secondary " + (t[4] ? "" : "disabled"))) && ti(o, "class", d), (!tl || 528 & i[0] && h !== (h = "btn formatted grey " + (t[4] && t[9] > 0 ? "" : "disabled"))) && ti(u, "class", h), (!tl || 32784 & i[0] && f !== (f = "btn formatted grey " + (t[4] && 50 == t[15].length ? "" : "disabled"))) && ti(m, "class", f), 3146254 & i[0]) {
                    let c;
                    for (t9 = t[20], c = 0; c < t9.length; c += 1) {
                        let $ = yA(t, t9, c);
                        t3[c] ? t3[c].p($, i) : (t3[c] = yN($), t3[c].c(), t3[c].m(p, null))
                    }
                    for (; c < t3.length; c += 1) t3[c].d(1);
                    t3.length = t9.length
                }
                if ((!tl || 524288 & i[0]) && tn(k, t[19]), (!tl || 512 & i[0]) && tm !== (tm = t[9] + 1 + "") && tn(P, tm), (!tl || 524288 & i[0]) && t_ !== (t_ = Math.ceil(t[19] / 50) + "") && tn(T, t_), (!tl || 96 & i[0]) && tf !== (tf = t[30](t[5], "time", t[6]) + "") && tn(I, tf), (!tl || 48 & i[0] && z !== (z = "btn grey " + (t[4] ? "" : "disabled") + " " + ("time" == t[5] ? "textprimary active" : ""))) && ti(N, "class", z), (!tl || 128 & i[0]) && tg !== (tg = (t[7] ? rC.ui.merchant.perUnit : rC.ui.merchant.total) + "") && tn(L, tg), (!tl || 144 & i[0] && B !== (B = "btn grey " + (t[4] ? "" : "disabled") + " " + (t[7] ? "textgreen" : ""))) && ti(O, "class", B), (!tl || 96 & i[0]) && tv !== (tv = t[30](t[5], "price", t[6]) + "") && tn(V, tv), (!tl || 48 & i[0] && j !== (j = "btn grey " + (t[4] ? "" : "disabled") + " " + ("price" == t[5] ? "textprimary active" : ""))) && ti(q, "class", j), 100761857 & i[0]) {
                    let _;
                    for (t2 = t[15], _ = 0; _ < t2.length; _ += 1) {
                        let g = yT(t, t2, _);
                        t4[_] ? (t4[_].p(g, i), tR(t4[_], 1)) : (t4[_] = yI(g), t4[_].c(), tR(t4[_], 1), t4[_].m(tt, null))
                    }
                    for (tA(), _ = t2.length; _ < t4.length; _ += 1) t7(_);
                    t8()
                }
                let v = ts;
                (ts = tP(t)) === v ? t6[ts].p(t, i) : (tA(), tF(t6[v], 1, 1, () => {
                    t6[v] = null
                }), t8(), (ta = t6[ts]) || (ta = t6[ts] = tE[ts](t)).c(), tR(ta, 1), ta.m(e, null))
            },
            i(t) {
                if (!tl) {
                    tR(s.$$.fragment, t);
                    for (let e = 0; e < t2.length; e += 1) tR(t4[e]);
                    tR(ta), tl = !0
                }
            },
            o(t) {
                tF(s.$$.fragment, t), t4 = t4.filter(Boolean);
                for (let e = 0; e < t4.length; e += 1) tF(t4[e]);
                tF(ta), tl = !1
            },
            d(i) {
                i && Q(e), tj(s), t[39](null), X(t3, i), X(t4, i), t6[ts].d(), to = !1, D(tc)
            }
        }
    }
    class yV extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a, r, l, o;
                N(e, e5, t => s(49, t)), N(e, eE, t => s(17, n = t)), N(e, eP, t => s(18, a = t)), N(e, e6, t => s(50, r = t)), N(e, eM, t => s(19, l = t));
                let c = [rC.ui.all, rC.ui.merchant.filtermine, null, "bow", "hammer", "staff", "sword", null, "orb", "quiver", "shield", "totem", null, "armlet", "armor", "boot", "glove", null, "amulet", "bag", "ring", null, "book", "rune", "misc", null, "mount", "pet", "box"],
                    d = c[0],
                    u = "all",
                    $ = "",
                    h = !0,
                    m = "price",
                    _ = 1,
                    f = !1,
                    p = !1,
                    g = 0,
                    v = () => {
                        if (h && n) {
                            s(16, R = void 0);
                            let t = c.indexOf(d);
                            $1("itemauctionfind", `${t} ${1===t?"all":u} ${"time"===m?0:f?2:1} ${_} ${g}`), s(4, h = !1)
                        }
                    },
                    y, b, x, w, k = !1,
                    C = () => {
                        w && $1("itemauctionpost", `${a.dbid} ${b}`)
                    },
                    S = t => {
                        let {
                            from: e,
                            to: i
                        } = t.detail;
                        e !== i && "item" == e.type && eP.set(e.item)
                    },
                    E = t => {
                        a && a.type && lL(d7[a.type].sound), eP.set()
                    },
                    P, M = [],
                    D = [],
                    T = () => {
                        if (P = Date.now(), r.length) {
                            let t = r.map(t => t.dbid);
                            fetch("/api/item/get", {
                                method: "POST",
                                body: JSON.stringify({
                                    auction: 1,
                                    ids: t
                                })
                            }).then(async t => {
                                let e = await t.json();
                                e.fail ? console.error(e) : (s(15, D.length = 0, D), r.forEach((t, i) => {
                                    let s = e.find(e => e.id === t.dbid);
                                    s && (s.store = M[i] || (M[i] = tX()), s.store.temp = t, t.hydrate(s), D.push(s.store))
                                }), s(8, p = f), s(4, h = !0))
                            })
                        } else s(8, p = f), s(4, h = !0), s(15, D.length = 0, D)
                    },
                    A = t => {
                        let e = Math.ceil((t - P) / 6e4);
                        return e < 60 ? e + " m" : Math.ceil(e / 60) + " h"
                    },
                    R, F = t => {
                        s(16, R = t)
                    },
                    I = () => {
                        s(16, R = void 0)
                    },
                    U = () => {
                        $1("itemauctionbuy", R.temp.dbid + ""), I()
                    },
                    z = () => {
                        $1("itemauctioncancel", R.temp.dbid + ""), I()
                    },
                    O = (t, e, i) => t == e ? 1 == i ? "\uD83E\uDC15 " : "\uD83E\uDC17 " : "",
                    B = t => {
                        s(9, g = 0), t == m ? s(6, _ = 1 == _ ? 0 : 1) : s(5, m = t), v()
                    },
                    q = () => {
                        s(7, f = !f), "price" == m ? v() : s(8, p = f)
                    };
                eP.subscribe(t => {
                    void 0 !== t && (s(1, d = t.type), s(2, u = t.tier), s(6, _ = 1), s(5, m = "price"), s(7, f = !0), s(9, g = 0), v())
                });
                let V = t => {
                        s(9, g = 0), v()
                    },
                    W = t => {
                        s(9, g--, g), v()
                    },
                    H = t => {
                        s(9, g++, g), v()
                    },
                    j = (t, e) => {
                        s(1, d = t), s(3, $ = ""), s(2, u = "all"), s(9, g = 0), v()
                    },
                    G = t => B("time"),
                    Y = t => B("price"),
                    Q = (t, e) => F(t),
                    X = () => {
                        L(eE, n = void 0), s(3, $ = ""), s(2, u = "all")
                    };
                return e.$$.update = () => {
                    131072 & e.$$.dirty[0] | 262144 & e.$$.dirty[1] && n && v(), 131072 & e.$$.dirty[0] && (n ? s(16, R = void 0) : L(eP, a = void 0)), 269312 & e.$$.dirty[0] && (s(10, y = aL(y, 0, 2147483646)), s(11, b = a ? aL((parseInt(y) || 0) * (k && a.stacks || 1), 0, 2147483646) : 0), s(13, x = Number.isInteger(b) ? yD(b) : 0), s(14, w = Number.isInteger(b) && b > 0 && a && a.canBeTraded())), 524288 & e.$$.dirty[1] && T()
                }, [o, d, u, $, h, m, _, f, p, g, y, b, k, x, w, D, R, n, a, l, c, v, C, S, E, A, F, I, U, z, O, B, q, function t(e) {
                    s(3, $ = e)
                }, function t(e) {
                    s(2, u = e)
                }, function t(e) {
                    s(1, d = e)
                }, V, W, H, function t(e) {
                    tw[e ? "unshift" : "push"](() => {
                        s(0, o = e)
                    })
                }, j, G, Y, Q, function t() {
                    s(10, y = ts(this.value)), s(18, a), s(12, k), s(11, b), s(17, n)
                }, function t() {
                    s(12, k = to(this))
                }, X]
            }, function t(e) {
                let i, s, n = e[17] && y8(e);
                return {
                    c() {
                        n && n.c(), i = tt()
                    },
                    m(t, e) {
                        n && n.m(t, e), Y(t, i, e), s = !0
                    },
                    p(t, e) {
                        t[17] ? n ? (n.p(t, e), 131072 & e[0] && tR(n, 1)) : ((n = y8(t)).c(), tR(n, 1), n.m(i.parentNode, i)) : n && (tA(), tF(n, 1, 1, () => {
                            n = null
                        }), t8())
                    },
                    i(t) {
                        s || (tR(n), s = !0)
                    },
                    o(t) {
                        tF(n), s = !1
                    },
                    d(t) {
                        n && n.d(t), t && Q(i)
                    }
                }
            }, A, {}, [-1, -1])
        }
    }
    let yW = [{
            name: "Year",
            days: 365,
            price: 9e3
        }, {
            name: "Month",
            days: 30,
            price: 900
        }],
        yH = [{
            sub: !1,
            stash: 15,
            inventory: 15,
            auction: 10,
            auctionHours: 12
        }, {
            sub: !0,
            stash: 100,
            inventory: 25,
            auction: 100,
            auctionHours: 24
        }];

    function yj(t, e, i) {
        let s = t.slice();
        return s[29] = e[i], s
    }

    function yG(t) {
        let e, i, s, n, a;
        return (i = new fg({
            props: {
                title: "Stash",
                pad: "5",
                icon: "bag",
                $$slots: {
                    default: [yK]
                },
                $$scope: {
                    ctx: t
                }
            }
        })).$on("close", t[19]), {
            c() {
                e = J("div"), tW(i.$$.fragment), ti(e, "class", "l-upperLeftModal container svelte-1ilvxqc")
            },
            m(r, l) {
                Y(r, e, l), tH(i, e, null), t[20](e), s = !0, n || (a = te(e, "pointerup", t[11]), n = !0)
            },
            p(t, e) {
                let s = {};
                2047 & e[0] | 2 & e[1] && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }), i.$set(s)
            },
            i(t) {
                s || (tR(i.$$.fragment, t), s = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), s = !1
            },
            d(s) {
                s && Q(e), tj(i), t[20](null), n = !1, a()
            }
        }
    }

    function yY(t) {
        let e;
        return {
            c() {
                e = J("div")
            },
            m(t, i) {
                Y(t, e, i)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function yQ(t) {
        let e, i;
        return (e = new vw({
            props: {
                descPos: "left:100%;top:0;",
                descRoot: t[0],
                pickable: !1,
                text: t[12](t[29].temp ? t[29].temp.getStashTime() : 0),
                item: t[29],
                filter: !t[3] || !t[29].temp || t[29].temp.getStashTime() > t[1] || ""
            }
        })).$on("click", t[13]), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            p(t, i) {
                let s = {};
                1 & i[0] && (s.descRoot = t[0]), 4 & i[0] && (s.text = t[12](t[29].temp ? t[29].temp.getStashTime() : 0)), 4 & i[0] && (s.item = t[29]), 14 & i[0] && (s.filter = !t[3] || !t[29].temp || t[29].temp.getStashTime() > t[1] || ""), e.$set(s)
            },
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }

    function yX(t) {
        let e, i, s;
        return {
            c() {
                (e = J("span")).innerHTML = 'Upgrade <img class="svgicon texticon" src="/assets/ui/icons/gem.svg?v=5699699">', ti(e, "class", "btn textwhite")
            },
            m(n, a) {
                Y(n, e, a), i || (s = te(e, "click", t[15]), i = !0)
            },
            p: C,
            d(t) {
                t && Q(e), i = !1, s()
            }
        }
    }

    function yJ(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h, m, _ = (1 == t[4] ? rC.ui.stash.deposit : rC.ui.stash.withdraw) + "",
            f = (1 == t[4] ? rC.ui.stash.deposit : rC.ui.stash.withdraw) + "";
        return a = new gM({
            props: {
                amount: t[4] > 0 ? t[5] : 0
            }
        }), {
            c() {
                e = J("div"), i = J("span"), s = K(_), n = Z(), tW(a.$$.fragment), r = K(" ?"), l = J("div"), o = J("input"), c = J("div"), d = K(f), tr(o, "width", "150px"), ti(o, "class", "navbtn formatted"), ti(o, "type", "number"), ti(c, "class", u = "btn " + (!t[3] || t[5] <= 0 ? "disabled" : "") + " " + (1 == t[4] ? "blue" : "green") + " formatted"), ti(l, "class", "marg-top formelements svelte-1ilvxqc"), ti(e, "class", "panel-black marg-top"), tr(e, "text-align", "right")
            },
            m(u, _) {
                Y(u, e, _), G(e, i), G(i, s), G(i, n), tH(a, i, null), G(i, r), G(e, l), G(l, o), ta(o, t[5]), G(l, c), G(c, d), $ = !0, h || (m = [te(o, "input", t[18]), te(c, "click", t[14])], h = !0)
            },
            p(t, e) {
                (!$ || 16 & e[0]) && _ !== (_ = (1 == t[4] ? rC.ui.stash.deposit : rC.ui.stash.withdraw) + "") && tn(s, _);
                let i = {};
                48 & e[0] && (i.amount = t[4] > 0 ? t[5] : 0), a.$set(i), 32 & e[0] && ts(o.value) !== t[5] && ta(o, t[5]), (!$ || 16 & e[0]) && f !== (f = (1 == t[4] ? rC.ui.stash.deposit : rC.ui.stash.withdraw) + "") && tn(d, f), (!$ || 56 & e[0] && u !== (u = "btn " + (!t[3] || t[5] <= 0 ? "disabled" : "") + " " + (1 == t[4] ? "blue" : "green") + " formatted")) && ti(c, "class", u)
            },
            i(t) {
                $ || (tR(a.$$.fragment, t), $ = !0)
            },
            o(t) {
                tF(a.$$.fragment, t), $ = !1
            },
            d(t) {
                t && Q(e), tj(a), h = !1, D(m)
            }
        }
    }

    function yK(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v, y, b, x, w = t[2].length + "",
            k = (t[7].subscribed_until ? yH[1].stash : yH[0].stash) + "",
            C = t[2],
            S = [];
        for (let E = 0; E < C.length; E += 1) S[E] = yQ(yj(t, C, E));
        let P = t => tF(S[t], 1, 1, () => {
                S[t] = null
            }),
            M = null;
        C.length || (M = yY());
        let T = !t[7].subscribed_until && yX(t);
        d = new gM({
            props: {
                amount: t[6].gold
            }
        });
        let A = t[4] > 0 && yJ(t);
        return {
            c() {
                e = J("div");
                for (let y = 0; y < S.length; y += 1) S[y].c();
                M && M.c(), i = J("div"), s = J("div"), n = J("span"), a = K(w), r = K(" / "), l = K(k), T && T.c(), c = J("div"), tW(d.$$.fragment), u = J("div"), $ = J("img"), _ = J("div"), f = J("img"), A && A.c(), v = tt(), ti(e, "class", "panel-black slotcontainer scrollbar svelte-1ilvxqc"), tr(e, "width", t[2].length ? "fit-content" : "auto"), tr(e, "grid-template-columns", "repeat(" + Math.min(t[2].length, t[8]) + ", auto)"), tr(e, "max-height", t[9] + "px"), ti(n, "class", o = t[2].length < (t[7].subscribed_until ? yH[1].stash : yH[0].stash) ? "textgreen" : "textred"), ti(s, "class", "navbtn panel-black border black gold svelte-1ilvxqc"), tr(s, "margin-right", "auto"), ti(c, "class", "navbtn panel-black border black gold svelte-1ilvxqc"), ti($, "class", "svgicon"), $.src !== (h = "/assets/ui/icons/deposit.svg?v=5699699") && ti($, "src", h), ti(u, "class", m = "navbtn btn grey gold " + (1 == t[4] ? "active" : "") + " svelte-1ilvxqc"), ti(f, "class", "svgicon"), f.src !== (p = "/assets/ui/icons/withdraw.svg?v=5699699") && ti(f, "src", p), ti(_, "class", g = "navbtn btn grey gold " + (2 == t[4] ? "active" : "") + " svelte-1ilvxqc"), ti(i, "class", "formelements svelte-1ilvxqc")
            },
            m(o, h) {
                Y(o, e, h);
                for (let m = 0; m < S.length; m += 1) S[m].m(e, null);
                M && M.m(e, null), Y(o, i, h), G(i, s), G(s, n), G(n, a), G(n, r), G(n, l), T && T.m(n, null), G(i, c), tH(d, c, null), G(i, u), G(u, $), G(i, _), G(_, f), A && A.m(o, h), Y(o, v, h), y = !0, b || (x = [te(u, "click", t[16]), te(_, "click", t[17])], b = !0)
            },
            p(t, i) {
                if (12303 & i[0]) {
                    let s;
                    for (C = t[2], s = 0; s < C.length; s += 1) {
                        let r = yj(t, C, s);
                        S[s] ? (S[s].p(r, i), tR(S[s], 1)) : (S[s] = yQ(r), S[s].c(), tR(S[s], 1), S[s].m(e, null))
                    }
                    for (tA(), s = C.length; s < S.length; s += 1) P(s);
                    t8(), C.length ? M && (M.d(1), M = null) : M || ((M = yY()).c(), M.m(e, null))
                }(!y || 4 & i[0]) && tr(e, "width", t[2].length ? "fit-content" : "auto"), (!y || 260 & i[0]) && tr(e, "grid-template-columns", "repeat(" + Math.min(t[2].length, t[8]) + ", auto)"), (!y || 512 & i[0]) && tr(e, "max-height", t[9] + "px"), (!y || 4 & i[0]) && w !== (w = t[2].length + "") && tn(a, w), (!y || 128 & i[0]) && k !== (k = (t[7].subscribed_until ? yH[1].stash : yH[0].stash) + "") && tn(l, k), t[7].subscribed_until ? T && (T.d(1), T = null) : T ? T.p(t, i) : ((T = yX(t)).c(), T.m(n, null)), (!y || 132 & i[0] && o !== (o = t[2].length < (t[7].subscribed_until ? yH[1].stash : yH[0].stash) ? "textgreen" : "textred")) && ti(n, "class", o);
                let c = {};
                64 & i[0] && (c.amount = t[6].gold), d.$set(c), (!y || 16 & i[0] && m !== (m = "navbtn btn grey gold " + (1 == t[4] ? "active" : "") + " svelte-1ilvxqc")) && ti(u, "class", m), (!y || 16 & i[0] && g !== (g = "navbtn btn grey gold " + (2 == t[4] ? "active" : "") + " svelte-1ilvxqc")) && ti(_, "class", g), t[4] > 0 ? A ? (A.p(t, i), 16 & i[0] && tR(A, 1)) : ((A = yJ(t)).c(), tR(A, 1), A.m(v.parentNode, v)) : A && (tA(), tF(A, 1, 1, () => {
                    A = null
                }), t8())
            },
            i(t) {
                if (!y) {
                    for (let e = 0; e < C.length; e += 1) tR(S[e]);
                    tR(d.$$.fragment, t), tR(A), y = !0
                }
            },
            o(t) {
                S = S.filter(Boolean);
                for (let e = 0; e < S.length; e += 1) tF(S[e]);
                tF(d.$$.fragment, t), tF(A), y = !1
            },
            d(t) {
                t && Q(e), X(S, t), M && M.d(), t && Q(i), T && T.d(), tj(d), A && A.d(t), t && Q(v), b = !1, D(x)
            }
        }
    }
    class yZ extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a, r, l, o, c, d, u, $, h;
                N(e, eA, t => s(23, n = t)), N(e, eh, t => s(24, a = t)), N(e, eT, t => s(6, r = t)), N(e, e_, t => s(25, l = t)), N(e, eO, t => s(7, o = t)), N(e, id, t => s(8, c = t)), N(e, iu, t => s(9, d = t)), N(e, iv, t => s(10, u = t));
                let m = [],
                    _ = [],
                    f = !1,
                    p, g = async () => {
                        if (s(1, h = Date.now()), n.length) {
                            let t = await fetch("/api/item/get", {
                                    method: "POST",
                                    body: JSON.stringify({
                                        stash: 1,
                                        ids: n.map(t => t.dbid)
                                    })
                                }),
                                e = await t.json();
                            if (e.fail) console.error(e);
                            else {
                                s(2, _.length = 0, _);
                                let i = new Map(n.map(t => [t.dbid, t]));
                                e.forEach((t, e) => {
                                    t.store = m[e] || (m[e] = tX()), s(2, _[e] = m[e], _), i.has(t.id) && (i.get(t.id).hydrate(t), s(2, _[e].temp = i.get(t.id), _))
                                })
                            }
                        } else s(2, _.length = 0, _);
                        S()
                    }, v = t => {
                        a && ($1("itemstash", "" + a.meta.slot), L(eh, a = void 0))
                    }, y = t => t < h ? void 0 : Math.ceil((t - h) / 6e4) + "m", b = t => {
                        f && (t.detail.item.getStashTime() > Date.now() ? lY("system", rC.ui.stash.waitunstash) : ($1("itemunstash", t.detail.item.dbid + ""), C()))
                    }, x = t => {
                        f && ($1(1 == w ? "goldstash" : "goldunstash", k + ""), C())
                    }, w = 2, k = 0, C = () => {
                        s(3, f = !1), p = setTimeout(() => {
                            s(3, f = !0)
                        }, 500)
                    }, S = () => {
                        s(3, f = !0), p && (clearTimeout(p), p = void 0)
                    }, E = t => L(iv, u = !0), P = t => s(4, w = 1), M = t => s(4, w = 2), D = t => L(eT, r = !1);
                return e.$$.update = () => {
                    8388608 & e.$$.dirty[0] && g(), 33554544 & e.$$.dirty[0] && s(5, k = r ? Math.min(1 == w ? l : r.gold, k) : 0)
                }, [$, h, _, f, w, k, r, o, c, d, u, v, y, b, x, E, P, M, function t() {
                    s(5, k = ts(this.value)), s(6, r), s(4, w), s(25, l)
                }, D, function t(e) {
                    tw[e ? "unshift" : "push"](() => {
                        s(0, $ = e)
                    })
                }]
            }, function t(e) {
                let i, s, n = e[6] && e[7] && yG(e);
                return {
                    c() {
                        n && n.c(), i = tt()
                    },
                    m(t, e) {
                        n && n.m(t, e), Y(t, i, e), s = !0
                    },
                    p(t, e) {
                        t[6] && t[7] ? n ? (n.p(t, e), 192 & e[0] && tR(n, 1)) : ((n = yG(t)).c(), tR(n, 1), n.m(i.parentNode, i)) : n && (tA(), tF(n, 1, 1, () => {
                            n = null
                        }), t8())
                    },
                    i(t) {
                        s || (tR(n), s = !0)
                    },
                    o(t) {
                        tF(n), s = !1
                    },
                    d(t) {
                        n && n.d(t), t && Q(i)
                    }
                }
            }, A, {}, [-1, -1])
        }
    }

    function bt(t, e, i) {
        let s = t.slice();
        return s[7] = e[i], s[9] = i, s
    }

    function be(t, e, i) {
        let s = t.slice();
        return s[10] = e[i], s
    }

    function bi(t) {
        let e, i, s, n, a;
        return (i = new fg({
            props: {
                title: "Trader",
                icon: "bag",
                $$slots: {
                    default: [bc]
                },
                $$scope: {
                    ctx: t
                }
            }
        })).$on("close", t[5]), {
            c() {
                e = J("div"), tW(i.$$.fragment), ti(e, "class", "l-upperLeftModal container svelte-46w0ts")
            },
            m(r, l) {
                Y(r, e, l), tH(i, e, null), t[6](e), s = !0, n || (a = te(e, "pointerup", t[3]), n = !0)
            },
            p(t, e) {
                let s = {};
                8195 & e && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }), i.$set(s)
            },
            i(t) {
                s || (tR(i.$$.fragment, t), s = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), s = !1
            },
            d(s) {
                s && Q(e), tj(i), t[6](null), n = !1, a()
            }
        }
    }

    function bs(t) {
        let e, i;
        return (e = new vw({
            props: {
                id: "trader" + t[10][0].buyid,
                descPos: "left:100%;top:0;",
                descRoot: t[0],
                isTrader: !0,
                pickable: !1,
                item: t[10][1]
            }
        })).$on("click", t[4]), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            p(t, i) {
                let s = {};
                1 & i && (s.descRoot = t[0]), e.$set(s)
            },
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }

    function bn(t) {
        let e, i;
        return e = new vw({
            props: {
                isTrader: !0
            }
        }), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            p: C,
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }

    function ba(t) {
        let e;
        return {
            c() {
                (e = J("span")).textContent = "Select an item to sell", ti(e, "class", "textgrey")
            },
            m(t, i) {
                Y(t, e, i)
            },
            p: C,
            i: C,
            o: C,
            d(t) {
                t && Q(e)
            }
        }
    }

    function br(t) {
        let e, i, s, n, a, r = [bo, bl],
            l = [];

        function o(t, i) {
            return 2 & i && (e = !!t[1].data.canBeSold()), e ? 0 : 1
        }
        return s = l[i = o(t, -1)] = r[i](t), {
            c() {
                s.c(), n = tt()
            },
            m(t, e) {
                l[i].m(t, e), Y(t, n, e), a = !0
            },
            p(t, e) {
                let a = i;
                (i = o(t, e)) === a ? l[i].p(t, e) : (tA(), tF(l[a], 1, 1, () => {
                    l[a] = null
                }), t8(), (s = l[i]) || (s = l[i] = r[i](t)).c(), tR(s, 1), s.m(n.parentNode, n))
            },
            i(t) {
                a || (tR(s), a = !0)
            },
            o(t) {
                tF(s), a = !1
            },
            d(t) {
                l[i].d(t), t && Q(n)
            }
        }
    }

    function bl(t) {
        let e;
        return {
            c() {
                (e = J("span")).textContent = "The trader does not want this item", ti(e, "class", "textred")
            },
            m(t, i) {
                Y(t, e, i)
            },
            p: C,
            i: C,
            o: C,
            d(t) {
                t && Q(e)
            }
        }
    }

    function bo(t) {
        let e, i;
        return e = new gM({
            props: {
                amount: t[1].data.goldValue()
            }
        }), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            p(t, i) {
                let s = {};
                2 & i && (s.amount = t[1].data.goldValue()), e.$set(s)
            },
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }

    function bc(t) {
        let e, i, s, n, a, r, l, o, c, d, u = as.player.getTargetEntity().items,
            $ = [];
        for (let h = 0; h < u.length; h += 1) $[h] = bs(be(t, u, h));
        let m = t => tF($[t], 1, 1, () => {
                $[t] = null
            }),
            _ = Array(24 - as.player.getTargetEntity().items.length),
            f = [];
        for (let p = 0; p < _.length; p += 1) f[p] = bn(bt(t, _, p));
        let g = [br, ba],
            v = [];

        function y(t, e) {
            return t[1] && "item" === t[1].meta.type ? 0 : 1
        }
        return c = v[o = y(t)] = g[o](t), {
            c() {
                (e = J("p")).textContent = "" + rC.npcs.trader.buy, i = J("div");
                for (let t = 0; t < $.length; t += 1) $[t].c();
                s = tt();
                for (let o = 0; o < f.length; o += 1) f[o].c();
                n = J("div"), (a = J("p")).textContent = "" + rC.npcs.trader.info, (r = J("p")).textContent = "" + rC.npcs.trader.price, l = J("span"), c.c(), ti(e, "class", "textprimary textcenter"), ti(i, "class", "panel-black slotcontainer svelte-46w0ts"), ti(a, "class", "textprimary"), ti(l, "class", "panel-black formatted info svelte-46w0ts"), ti(n, "class", "textcenter")
            },
            m(t, c) {
                Y(t, e, c), Y(t, i, c);
                for (let u = 0; u < $.length; u += 1) $[u].m(i, null);
                G(i, s);
                for (let h = 0; h < f.length; h += 1) f[h].m(i, null);
                Y(t, n, c), G(n, a), G(n, r), G(n, l), v[o].m(l, null), d = !0
            },
            p(t, e) {
                if (17 & e) {
                    let n;
                    for (u = as.player.getTargetEntity().items, n = 0; n < u.length; n += 1) {
                        let a = be(t, u, n);
                        $[n] ? ($[n].p(a, e), tR($[n], 1)) : ($[n] = bs(a), $[n].c(), tR($[n], 1), $[n].m(i, s))
                    }
                    for (tA(), n = u.length; n < $.length; n += 1) m(n);
                    t8()
                }
                let r = o;
                (o = y(t)) === r ? v[o].p(t, e) : (tA(), tF(v[r], 1, 1, () => {
                    v[r] = null
                }), t8(), (c = v[o]) || (c = v[o] = g[o](t)).c(), tR(c, 1), c.m(l, null))
            },
            i(t) {
                if (!d) {
                    for (let e = 0; e < u.length; e += 1) tR($[e]);
                    for (let i = 0; i < _.length; i += 1) tR(f[i]);
                    tR(c), d = !0
                }
            },
            o(t) {
                $ = $.filter(Boolean);
                for (let e = 0; e < $.length; e += 1) tF($[e]);
                f = f.filter(Boolean);
                for (let i = 0; i < f.length; i += 1) tF(f[i]);
                tF(c), d = !1
            },
            d(t) {
                t && Q(e), t && Q(i), X($, t), X(f, t), t && Q(n), v[o].d()
            }
        }
    }
    class bd extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a;
                N(e, eh, t => s(1, n = t)), N(e, e8, t => s(2, a = t));
                let r = t => {
                        n && n.meta && "item" === n.meta.type && n.data.canBeSold() && fe(n.data.quality, n.data.upgrade, n.meta.slot, n.data.type, n.data.tier), L(eh, n = void 0)
                    },
                    l, o = t => L(e8, a = !1);
                return [l, n, a, r, t => {
                    $1("itemtraderbuy", "" + t.detail.item.buyid)
                }, o, function t(e) {
                    tw[e ? "unshift" : "push"](() => {
                        s(0, l = e)
                    })
                }]
            }, function t(e) {
                let i, s, n = e[2] && bi(e);
                return {
                    c() {
                        n && n.c(), i = tt()
                    },
                    m(t, e) {
                        n && n.m(t, e), Y(t, i, e), s = !0
                    },
                    p(t, [e]) {
                        t[2] ? n ? (n.p(t, e), 4 & e && tR(n, 1)) : ((n = bi(t)).c(), tR(n, 1), n.m(i.parentNode, i)) : n && (tA(), tF(n, 1, 1, () => {
                            n = null
                        }), t8())
                    },
                    i(t) {
                        s || (tR(n), s = !0)
                    },
                    o(t) {
                        tF(n), s = !1
                    },
                    d(t) {
                        n && n.d(t), t && Q(i)
                    }
                }
            }, A, {})
        }
    }
    let bu = t => void 0 === t.stacks && t.rolls.length > 0 && !dE[t.type].noupgrade,
        b$ = t => t < 101,
        bh = t => {
            if (!bu(t)) return 0;
            let e = dL[t.type + t.tier];
            return Math.ceil(((1 + e.level * (1 + t.upgrade)) / dE[t.type].drop) ** (1.2 + .2 * t.upgrade)) + 100
        },
        bm = t => {
            if (bu(t)) {
                let e = [];
                for (let i = 0; i < Math.max(1, Math.min(t.upgrade, 3)); ++i) e.push({
                    type: "rune",
                    tier: i + Math.max(0, t.upgrade - 3),
                    stacks: Math.min(t.upgrade + 1, 3 - i)
                });
                return e
            }
            return []
        },
        b_ = (t, e, i, s) => Math.ceil(t.goldValue || (.4 * (t.level ** 1.3 + .4 * e)) ** (1.1 + e / 100) / dE[t.type].drop) * (i || 1) * (s ? 8 : 1);
    class bf {
        constructor(t) {
            this.dbid = t, this.stats = new Map, this.dirty = !0
        }
        hydrate(t) {
            if (this.dirty = !1, this.bound = t.bound, this.type = t.type, this.tier = t.tier, this.logic = dL[this.type + this.tier], this.auction = t.auction ? new Date(t.auction) : void 0, this.auctionprice = t.auctionprice, this.owner = t.name, this.stash = t.stash ? new Date(t.stash) : void 0, void 0 === this.logic) throw "Unknown item " + t.type + t.tier;
            if (this.upgrade = t.upgrade, this.stats.clear(), t.rolls) {
                if (this.setRolls(t.rolls), this.quality = this.nextRoll(), this.logic.stats) {
                    this.logic.stats.forEach((t, e) => {
                        this.stats.set(e, {
                            type: "base",
                            qual: this.quality,
                            value: Math.floor(t.min + (t.max - t.min) * (this.quality / 100) ** 2 + d5[e] * this.upgrade)
                        })
                    });
                    let e = Math.min(4, Math.round((this.quality / 100) ** 1.5 * 3.6));
                    for (let i = 0; i < e; ++i) {
                        let s = this.nextRoll(),
                            n = -1;
                        for (; - 1 === n || this.stats.has(n);) n = parseInt(l7(dM, s / 101)), s = (s + 5) % 100;
                        let a = (this.nextRoll() + this.quality) / 2;
                        this.stats.set(n, {
                            type: "bonus",
                            qual: a,
                            value: Math.ceil(Math.max((dP[n].min + (dP[n].max - dP[n].min) * (a / 100) ** 2) * this.logic.level * dE[this.type].weight, d5[n]) + d5[n] * this.upgrade)
                        })
                    }
                }
                this.quality = this.logic.quality || this.quality, this.stacks = void 0
            } else this.stacks = t.stacks, this.quality = this.logic.quality || 0;
            this.gs = 0, this.logic.gs ? this.gs = this.logic.gs : this.stats.forEach((t, e) => {
                if (17 === e) return;
                let i = t.value / d5[e];
                "shield" == this.type && "base" == t.type && (i *= .5), "orb" == this.type && "base" == t.type && (i *= .7), this.gs += i
            }), this.gs = Math.round(this.gs)
        }
        setRolls(t) {
            this.rolls = t, this.currentRoll = 0
        }
        nextRoll() {
            if (this.currentRoll == this.rolls.length) throw "roll maximum reached";
            return this.rolls[this.currentRoll++]
        }
        use(t) {
            this.logic.use && this.logic.use(t)
        }
        goldValue(t) {
            if (!this.canBeSold()) throw "Item cant have value because it cant be sold";
            return b_(this.logic, this.quality, this.stacks, t)
        }
        storeValue() {
            return this.logic.storeValue || 0
        }
        medalValue() {
            return this.logic.medalValue || 0
        }
        canEquip(t) {
            return ya(t.level, t.skills.skillIdsActive, t.skills.skillIdsLearned, t.class, this.type, this.tier)
        }
        canEquipClass(t) {
            return yl(t.class, this.type, this.tier)
        }
        equipReasons(t) {
            let e = [];
            return this.logic.level && e.push(["Lv. " + this.logic.level, !0]), e
        }
        canBeDropped() {
            return !dE[this.type].undroppable && !this.bound
        }
        canBeTraded() {
            return !this.bound
        }
        canBeSold() {
            return !this.logic.unsellable
        }
        getStashTime() {
            return this.dirty ? 0 : void 0 !== this.stash ? this.stash.getTime() : 0
        }
        getEquipSlot() {
            return void 0 !== dE[this.type].slot ? dE[this.type].slot[0] : void 0
        }
    }
    let bp = (t, e, i) => {
            if (t && t.type) switch (e) {
                case 13:
                    t.rolls && t.quality >= 70 && lL(t.quality < 90 ? 98 : 99);
                case 1:
                    sO.chat[7] && lY("inv", rC.ui.inventory.pick.replace("$1", rS(t.type, t.tier)), !0), dY(10, 100), lL(d7[t.type].sound), dq[12].element = "bag" + i, "book" == t.type && dY(23, 100) && (dq[24].element = "bag" + i);
                    break;
                case 10:
                    t.rolls && eF.update(e => (eN.set(t.upgrade - e.upgrade), t))
            }
        },
        bg = (t, e) => {
            if (t && t.type) switch (e) {
                case 7:
                    sO.chat[8] && lY("inv", rC.ui.stash.stashed.replace("$1", rS(t.type, t.tier))), lL(d7[t.type].sound);
                    break;
                case 6:
                    eP.set(), e5.update(t => !t), sO.chat[8] && lY("inv", rC.ui.merchant.auctionpost.replace("$1", rS(t.type, t.tier)));
                    break;
                case 9:
                    sO.chat[8] && lY("inv", rC.ui.inventory.sold.replace("$1", rS(t.type, t.tier))), lL(d7[t.type].sound);
                    break;
                case 2:
                    sO.chat[7] && lY("inv", rC.ui.inventory.throw.replace("$1", rS(t.type, t.tier))), lL(d7[t.type].sound)
            }
        },
        bv = (t, e, i, s) => {
            switch (0 != i && lL(d7.gold.sound), e = s + e, i) {
                case 1:
                    sO.chat[9] && lY("inv", rC.ui.inventory.pick.replace("$1", e), !0);
                    break;
                case 4:
                    e5.update(t => !t), sO.chat[10] && lY("inv", rC.ui.merchant.auctionbuy.replace("$1", e), !0);
                    break;
                case 12:
                case 3:
                    sO.chat[10] && lY("inv", rC.ui.inventory.spend.replace("$1", e), !0);
                    break;
                case 11:
                    sO.chat[10] && lY("inv", rC.ui.inventory.death.replace("$1", e), !0);
                    break;
                case 9:
                    sO.chat[10] && lY("inv", rC.ui.inventory.receive.replace("$1", e), !0)
            }
        };
    class by extends bf {
        constructor(t) {
            super(t)
        }
        hydrate(t) {
            super.hydrate(t), t.store ? t.store.set(this) : console.error("no store for item", t), bp(this, this.reason, t.slot)
        }
        equipReasons(t) {
            let e = [];
            if (void 0 !== this.logic.class && e.push(["Class: " + rC.classes[this.logic.class].name, yl(t.class, this.type, this.tier)]), this.logic.level && e.push(["Requires Lv. " + this.logic.level, yr(t.level, this.type, this.tier)]), this.logic.requiredSkill && e.push(["Must know: " + rC.items.book[this.logic.requiredSkill].name, y$(t.skills.skillIdsActive, this.type, this.tier)]), yl(t.class, this.type, this.tier) && "book" == this.type) {
                let i = yd(t.skills.skillIdsLearned, this.type, this.tier),
                    s = yu(t.skills.skillIdsLearned, this.logic.skillid);
                e.push([i ? "Use book to learn skill" : s >= this.logic.skilllevel ? "You already know this skill" : `Must learn book Lv. ${this.logic.skilllevel} first`, i])
            }
            return e
        }
        buyReasons(t) {
            let e = [];
            return void 0 !== this.logic.buyElo && e.push(["Min. Rating: " + lr(this.logic.buyElo), yh(t.elo, this.type, this.tier)]), e
        }
        getBestEquipslot(t) {
            let e = dE[this.type].slot;
            if (void 0 !== e) return e.find(e => void 0 === t.slots.get(e)) || e[0]
        }
    }

    function b0(t, e, i) {
        let s = t.slice();
        return s[18] = e[i], s
    }

    function bb(t) {
        let e, i, s;
        return (i = new fg({
            props: {
                title: "Blacksmith",
                pad: "5",
                icon: "bag",
                $$slots: {
                    default: [b1]
                },
                $$scope: {
                    ctx: t
                }
            }
        })).$on("close", t[12]), {
            c() {
                e = J("div"), tW(i.$$.fragment), ti(e, "class", "absCentered container textcenter svelte-1u9u6qj")
            },
            m(t, n) {
                Y(t, e, n), tH(i, e, null), s = !0
            },
            p(t, e) {
                let s = {};
                2097407 & e && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }), i.$set(s)
            },
            i(t) {
                s || (tR(i.$$.fragment, t), s = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), s = !1
            },
            d(t) {
                t && Q(e), tj(i)
            }
        }
    }

    function bx(t) {
        let e;
        return {
            c() {
                e = J("div")
            },
            m(t, i) {
                Y(t, e, i)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function bw(t) {
        let e, i;
        return e = new vw({
            props: {
                pickable: !1,
                item: t[18],
                filter: t[18].filter
            }
        }), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            p(t, i) {
                let s = {};
                2 & i && (s.item = t[18]), 2 & i && (s.filter = t[18].filter), e.$set(s)
            },
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }

    function b1(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v = (t[5] || "Place an item into the upgrade slot") + "";
        (r = new vw({
            props: {
                clearOnMove: !0,
                invslot: t[7] ? t[0] : void 0,
                pickable: !0,
                item: eF,
                filter: !!t[3] || ""
            }
        })).$on("discard", t[10]), r.$on("move", t[9]);
        let y = t[1],
            b = [];
        for (let x = 0; x < y.length; x += 1) b[x] = bw(b0(t, y, x));
        let w = t => tF(b[t], 1, 1, () => {
                b[t] = null
            }),
            k = null;
        return y.length || (k = bx()), $ = new gM({
            props: {
                isPrice: !0,
                amount: t[7] ? bh(t[7]) : 0
            }
        }), {
            c() {
                (e = J("h3")).textContent = "Upgrade Item", i = J("span"), s = K(v), a = J("div"), tW(r.$$.fragment), o = J("div"), (c = J("span")).textContent = "Cost:", d = J("div");
                for (let f = 0; f < b.length; f += 1) b[f].c();
                k && k.c(), u = J("div"), tW($.$$.fragment), h = J("div"), m = K("Upgrade"), ti(e, "class", "textwhite"), ti(i, "class", n = "panel-black upgradetext " + t[6] + " svelte-1u9u6qj"), ti(a, "class", l = "upgradeslot " + t[4] + " svelte-1u9u6qj"), ti(d, "class", "panel-black costgrid svelte-1u9u6qj"), tr(d, "grid-template-columns", "repeat(" + (t[1].length || 3) + ", 30px)"), ti(h, "class", _ = "btn primary formatted textcenter upgradebutton " + (t[2] ? "" : "disabled") + " svelte-1u9u6qj"), ti(o, "class", "upgrade svelte-1u9u6qj")
            },
            m(n, l) {
                Y(n, e, l), Y(n, i, l), G(i, s), Y(n, a, l), tH(r, a, null), Y(n, o, l), G(o, c), G(o, d);
                for (let _ = 0; _ < b.length; _ += 1) b[_].m(d, null);
                k && k.m(d, null), G(o, u), tH($, u, null), G(o, h), G(h, m), f = !0, p || (g = te(h, "click", t[11]), p = !0)
            },
            p(t, e) {
                (!f || 32 & e) && v !== (v = (t[5] || "Place an item into the upgrade slot") + "") && tn(s, v), (!f || 64 & e && n !== (n = "panel-black upgradetext " + t[6] + " svelte-1u9u6qj")) && ti(i, "class", n);
                let o = {};
                if (129 & e && (o.invslot = t[7] ? t[0] : void 0), 8 & e && (o.filter = !!t[3] || ""), r.$set(o), (!f || 16 & e && l !== (l = "upgradeslot " + t[4] + " svelte-1u9u6qj")) && ti(a, "class", l), 2 & e) {
                    let c;
                    for (y = t[1], c = 0; c < y.length; c += 1) {
                        let u = b0(t, y, c);
                        b[c] ? (b[c].p(u, e), tR(b[c], 1)) : (b[c] = bw(u), b[c].c(), tR(b[c], 1), b[c].m(d, null))
                    }
                    for (tA(), c = y.length; c < b.length; c += 1) w(c);
                    t8(), y.length ? k && (k.d(1), k = null) : k || ((k = bx()).c(), k.m(d, null))
                }(!f || 2 & e) && tr(d, "grid-template-columns", "repeat(" + (t[1].length || 3) + ", 30px)");
                let m = {};
                128 & e && (m.amount = t[7] ? bh(t[7]) : 0), $.$set(m), (!f || 4 & e && _ !== (_ = "btn primary formatted textcenter upgradebutton " + (t[2] ? "" : "disabled") + " svelte-1u9u6qj")) && ti(h, "class", _)
            },
            i(t) {
                if (!f) {
                    tR(r.$$.fragment, t);
                    for (let e = 0; e < y.length; e += 1) tR(b[e]);
                    tR($.$$.fragment, t), f = !0
                }
            },
            o(t) {
                tF(r.$$.fragment, t), b = b.filter(Boolean);
                for (let e = 0; e < b.length; e += 1) tF(b[e]);
                tF($.$$.fragment, t), f = !1
            },
            d(t) {
                t && Q(e), t && Q(i), t && Q(a), tj(r), t && Q(o), X(b, t), k && k.d(), tj($), p = !1, g()
            }
        }
    }
    class b9 extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a, r, l, o;
                N(e, eF, t => s(7, n = t)), N(e, eR, t => s(8, a = t)), N(e, eN, t => s(13, r = t)), N(e, e_, t => s(14, l = t)), N(e, ev, t => s(15, o = t));
                let c = t => {
                        let {
                            from: e,
                            to: i
                        } = t.detail;
                        e !== i && "item" == e.type && (eF.set(e.item), s(0, u = e.slot))
                    },
                    d = t => {
                        eF.set(), s(0, u = void 0)
                    },
                    u, $ = [],
                    h = !1,
                    m = !1,
                    _ = () => {
                        let t = bu(n),
                            e = l >= bh(n),
                            i = b$(u);
                        s(2, h = t && e && i);
                        let a = bm(n);
                        a.forEach((t, e) => {
                            let i = $[e] || s(1, $[e] = tX(), $),
                                n = new by;
                            n.hydrate({
                                ...t,
                                store: i
                            }), i.filter = !(o[n.type + n.tier] >= n.stacks) || "", i.filter && s(2, h = !1)
                        }), s(1, $ = $.slice(0, a.length)), h || s(5, g = "You lack the required materials"), t || s(5, g = "This item type cannot be upgraded"), e || s(5, g = "You do not have enough gold"), i || s(5, g = "You must un-equip the item first"), h ? (s(6, v = "textgreen"), s(5, g = "Ready to upgrade")) : s(6, v = "textred")
                    },
                    f = () => {
                        n && h && !m && (s(3, m = !0), L(eN, r = void 0), s(5, g = "Upgrading..."), s(6, v = "textprimary"), lL(100), setTimeout(() => $1("itemblacksmithupgrade", "" + n.dbid), 1e3))
                    },
                    p, g, v, y = () => {
                        lL(r > 0 ? 101 : 102), s(4, p = r > 0 ? "flash_success" : "flash_fail"), s(5, g = (r > 0 ? "Success! " : "Fail! ") + (r < 0 ? "-" : "+") + r), s(6, v = r > 0 ? "textgreen" : "textred")
                    },
                    b = t => L(eR, a = !1);
                return e.$$.update = () => {
                    256 & e.$$.dirty && (a || (L(eF, n = void 0), L(eN, r = void 0))), 128 & e.$$.dirty && (s(2, h = !0), n ? _() : (s(1, $.length = 0, $), s(2, h = !1), s(6, v = void 0), s(5, g = void 0)), s(3, m = !1)), 8192 & e.$$.dirty && (void 0 !== r ? y() : (s(4, p = ""), s(6, v = "")))
                }, [u, $, h, m, p, g, v, n, a, c, d, f, b]
            }, function t(e) {
                let i, s, n = e[8] && bb(e);
                return {
                    c() {
                        n && n.c(), i = tt()
                    },
                    m(t, e) {
                        n && n.m(t, e), Y(t, i, e), s = !0
                    },
                    p(t, [e]) {
                        t[8] ? n ? (n.p(t, e), 256 & e && tR(n, 1)) : ((n = bb(t)).c(), tR(n, 1), n.m(i.parentNode, i)) : n && (tA(), tF(n, 1, 1, () => {
                            n = null
                        }), t8())
                    },
                    i(t) {
                        s || (tR(n), s = !0)
                    },
                    o(t) {
                        tF(n), s = !1
                    },
                    d(t) {
                        n && n.d(t), t && Q(i)
                    }
                }
            }, A, {})
        }
    }
    class b3 extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, {
                    amount: a
                } = i;
                return e.$$set = t => {
                    "amount" in t && s(1, a = t.amount)
                }, e.$$.update = () => {
                    2 & e.$$.dirty && s(0, n = lr(a))
                }, [n, a]
            }, function t(e) {
                let i;
                return {
                    c() {
                        i = J("span")
                    },
                    m(t, s) {
                        Y(t, i, s), i.innerHTML = e[0]
                    },
                    p(t, [e]) {
                        1 & e && (i.innerHTML = t[0])
                    },
                    i: C,
                    o: C,
                    d(t) {
                        t && Q(i)
                    }
                }
            }, R, {
                amount: 1
            })
        }
    }
    let bk = rY({
            0: {
                6: 2,
                8: .3
            },
            1: {
                6: 4,
                12: 1
            },
            2: {
                14: .5
            },
            3: {
                14: .4,
                7: .8
            },
            4: {
                16: .3,
                7: .8
            },
            5: {
                14: .2,
                18: .5
            }
        }),
        b2 = t => 1 + t / 1e3;
    class b4 extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n;
                N(e, eI, t => s(4, n = t));
                let a, {
                        relmap: r
                    } = i,
                    {
                        id: l
                    } = i,
                    {
                        relation: o
                    } = i;
                return e.$$set = t => {
                    "relmap" in t && s(0, r = t.relmap), "id" in t && s(1, l = t.id), "relation" in t && s(2, o = t.relation)
                }, e.$$.update = () => {
                    7 & e.$$.dirty && s(3, a = void 0 !== o && void 0 !== r.get(o).get(l))
                }, [r, l, o, a, n]
            }, function t(e) {
                let i, s, n, a, r, l = rC.ui.stats.array[e[1]] + "",
                    o = (e[3] ? "+" + lt(e[1], e[0].get(e[2]).get(e[1])) : lt(e[1], e[4][e[1]] || 0)) + "";
                return {
                    c() {
                        i = J("span"), s = K(l), n = J("span"), a = K(o), ti(n, "class", r = "statnumber " + (e[3] ? "textgreen" : e[0] ? "textprimary" : "textgreen"))
                    },
                    m(t, e) {
                        Y(t, i, e), G(i, s), Y(t, n, e), G(n, a)
                    },
                    p(t, [e]) {
                        2 & e && l !== (l = rC.ui.stats.array[t[1]] + "") && tn(s, l), 31 & e && o !== (o = (t[3] ? "+" + lt(t[1], t[0].get(t[2]).get(t[1])) : lt(t[1], t[4][t[1]] || 0)) + "") && tn(a, o), 9 & e && r !== (r = "statnumber " + (t[3] ? "textgreen" : t[0] ? "textprimary" : "textgreen")) && ti(n, "class", r)
                    },
                    i: C,
                    o: C,
                    d(t) {
                        t && Q(i), t && Q(n)
                    }
                }
            }, A, {
                relmap: 0,
                id: 1,
                relation: 2
            })
        }
    }
    let bC = [4e3, 8e3, 12e3, 16e3, 2e4, 24e3, 28e3, 32e3, 36e3, 4e4, 44e3, 48e3],
        bS = bC.length,
        b7 = t => {
            for (let e = 0; e < bS; ++e)
                if (bC[e] > t) return e;
            return Math.max(0, bS)
        },
        bE = t => 0 === t ? 0 : bC[t - 1],
        b6 = t => {
            for (let e = 0; e < bS; ++e)
                if (bC[e] > t) return bC[e];
            return bC[bS - 1]
        },
        bP = [1, .8, .63, .479, .342, .23, .146, .085, .045, .024, .01, .003, 0],
        bM = t => 0 === t ? "No Bracket" : t === bP.length ? bP.length + " (Faction Leader)" : `${t} (Top ${(100*bP[t-1]).toFixed(1)}%)`;

    function b5(t, e, i) {
        let s = t.slice();
        return s[15] = e[i], s
    }

    function bD(t, e, i) {
        let s = t.slice();
        return s[12] = e[i], s[14] = i, s
    }

    function bT(t, e, i) {
        let s = t.slice();
        return s[18] = e[i], s[20] = i, s
    }

    function bA(t, e, i) {
        let s = t.slice();
        return s[15] = e[i], s
    }

    function b8(t) {
        let e, i, s;
        return (i = new fg({
            props: {
                title: rC.ui.headers.character,
                icon: "char",
                $$slots: {
                    default: [bU]
                },
                $$scope: {
                    ctx: t
                }
            }
        })).$on("close", t[11]), {
            c() {
                e = J("div"), tW(i.$$.fragment), ti(e, "class", "l-upperLeftModal container uiscaled svelte-ggsnc")
            },
            m(t, n) {
                Y(t, e, n), tH(i, e, null), s = !0
            },
            p(t, e) {
                let s = {};
                8388727 & e && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }), i.$set(s)
            },
            i(t) {
                s || (tR(i.$$.fragment, t), s = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), s = !1
            },
            d(t) {
                t && Q(e), tj(i)
            }
        }
    }

    function bR(t) {
        let e, i, s, n, a, r, l;

        function o(...e) {
            return t[8](t[15], ...e)
        }

        function c(...e) {
            return t[10](t[15], ...e)
        }
        return e = new b4({
            props: {
                id: t[15]
            }
        }), {
            c() {
                tW(e.$$.fragment), (i = J("img")).src !== (s = "/assets/ui/icons/arrow.svg?v=5699699") && ti(i, "src", s), ti(i, "class", n = "btn " + (t[1][22] > 0 ? "green" : "disabled") + " svgicon statbtn svelte-ggsnc")
            },
            m(s, n) {
                tH(e, s, n), Y(s, i, n), a = !0, r || (l = [te(i, "pointerenter", o), te(i, "pointerleave", t[9]), te(i, "click", c)], r = !0)
            },
            p(e, s) {
                t = e, (!a || 2 & s && n !== (n = "btn " + (t[1][22] > 0 ? "green" : "disabled") + " svgicon statbtn svelte-ggsnc")) && ti(i, "class", n)
            },
            i(t) {
                a || (tR(e.$$.fragment, t), a = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), a = !1
            },
            d(t) {
                tj(e, t), t && Q(i), r = !1, D(l)
            }
        }
    }

    function bF(t) {
        let e, i;
        return (e = new vw({
            props: {
                descPos: "left:100%;top:0;",
                item: t[18],
                invslot: 101 + t[20]
            }
        })).$on("use", bq), e.$on("context", bq), e.$on("move", bB), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            p(t, i) {
                let s = {};
                64 & i && (s.item = t[18]), e.$set(s)
            },
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }

    function bN(t) {
        let e, i;
        return e = new b4({
            props: {
                id: t[15],
                relmap: bO,
                relation: t[0]
            }
        }), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            p(t, i) {
                let s = {};
                1 & i && (s.relation = t[0]), e.$set(s)
            },
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }

    function bI(t) {
        let e, i, s = t[12],
            n = [];
        for (let a = 0; a < s.length; a += 1) n[a] = bN(b5(t, s, a));
        let r = t => tF(n[t], 1, 1, () => {
            n[t] = null
        });
        return {
            c() {
                e = J("div");
                for (let t = 0; t < n.length; t += 1) n[t].c();
                ti(e, "class", "statcol panel-black svelte-ggsnc")
            },
            m(t, s) {
                Y(t, e, s);
                for (let a = 0; a < n.length; a += 1) n[a].m(e, null);
                i = !0
            },
            p(t, i) {
                if (1 & i) {
                    let a;
                    for (s = t[12], a = 0; a < s.length; a += 1) {
                        let l = b5(t, s, a);
                        n[a] ? (n[a].p(l, i), tR(n[a], 1)) : (n[a] = bN(l), n[a].c(), tR(n[a], 1), n[a].m(e, null))
                    }
                    for (tA(), a = s.length; a < n.length; a += 1) r(a);
                    t8()
                }
            },
            i(t) {
                if (!i) {
                    for (let e = 0; e < s.length; e += 1) tR(n[e]);
                    i = !0
                }
            },
            o(t) {
                n = n.filter(Boolean);
                for (let e = 0; e < n.length; e += 1) tF(n[e]);
                i = !1
            },
            d(t) {
                t && Q(e), X(n, t)
            }
        }
    }

    function bU(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v, y, b, x, w, k, C, S, E, P, M, D, T, A, R, F, N, I, U, z, O, L, B, q, V, W, H, j, te, ts, ta, tl, to, tc, td, tu = t[4].name + "",
            t$ = t[4].level + "",
            th = rC.classes[t[4].class].name + "",
            tm = rC.factions[t[4].faction].name + "",
            t_ = rX(t[1][20] || 0) + "",
            tf = t[2] < bS ? "/ " + rQ(bC[t[2]]) : "",
            tp = rC.ui.charpanel.rank + "",
            tg = rC.ui.charpanel.perday + "";
        L = new b3({
            props: {
                amount: t[1][21] || 0
            }
        }), q = new g5({
            props: {
                amount: 2 * r8(t[1][21] || 0),
                isPrice: !1
            }
        }), te = new g5({
            props: {
                amount: t[5],
                isPrice: !1
            }
        });
        let tv = [0, 1, 2, 3, 4, 5],
            ty = [];
        for (let t0 = 0; t0 < 6; t0 += 1) ty[t0] = bR(bA(t, tv, t0));
        let tb = t => tF(ty[t], 1, 1, () => {
            ty[t] = null
        });
        tl = new b4({
            props: {
                id: 22
            }
        });
        let tx = t[6].filter(bV),
            tw = [];
        for (let t1 = 0; t1 < tx.length; t1 += 1) tw[t1] = bF(bT(t, tx, t1));
        let t9 = t => tF(tw[t], 1, 1, () => {
                tw[t] = null
            }),
            t3 = bL,
            tk = [];
        for (let t2 = 0; t2 < t3.length; t2 += 1) tk[t2] = bI(bD(t, t3, t2));
        let t4 = t => tF(tk[t], 1, 1, () => {
            tk[t] = null
        });
        return {
            c() {
                e = J("div"), i = J("div"), (s = J("span")).textContent = "" + rC.ui.charpanel.name, n = J("span"), a = K(tu), (r = J("span")).textContent = "" + rC.ui.charpanel.level, l = J("span"), o = K(t$), (c = J("span")).textContent = "Class", d = J("span"), u = J("img"), h = Z(), m = K(th), (f = J("span")).textContent = "" + rC.ui.charpanel.faction, p = J("span"), g = J("img"), y = Z(), b = K(tm), (w = J("span")).textContent = "" + rC.ui.charpanel.prestige, k = J("span"), C = J("img"), E = Z(), P = K(t_), M = Z(), D = K(tf), T = K(" ("), A = K(tp), R = Z(), F = K(t[2]), N = K("/"), I = K(bS), U = K(")"), (z = J("span")).textContent = "" + rC.ui.charpanel.rating, O = J("span"), tW(L.$$.fragment), B = K(" ("), tW(q.$$.fragment), V = Z(), W = K(tg), H = K(")"), (j = J("span")).textContent = "" + rC.ui.charpanel.medals, tW(te.$$.fragment), ts = J("div");
                for (let G = 0; G < 6; G += 1) ty[G].c();
                ta = tt(), tW(tl.$$.fragment), to = J("div");
                for (let Y = 0; Y < tw.length; Y += 1) tw[Y].c();
                tc = J("div");
                for (let Q = 0; Q < tk.length; Q += 1) tk[Q].c();
                ti(n, "class", "bold textwhite"), ti(l, "class", "bold textwhite"), ti(u, "class", "texticon"), u.src !== ($ = rB(t[4].class)) && ti(u, "src", $), ti(d, "class", _ = "bold textc" + t[4].class + " svelte-ggsnc"), ti(g, "class", "texticon"), g.src !== (v = rq(t[4].faction)) && ti(g, "src", v), ti(p, "class", x = "bold textf" + t[4].faction + " svelte-ggsnc"), ti(C, "class", "texticon"), C.src !== (S = rW) && ti(C, "src", S), ti(k, "class", "bold textprestige"), ti(i, "class", "statcol panel-black svelte-ggsnc"), tr(i, "grid-template-columns", "1fr 2fr"), ti(ts, "id", "statpoints"), ti(ts, "class", "statcol panel-black svelte-ggsnc"), tr(ts, "grid-template-columns", "1fr auto auto"), ti(e, "class", "grid"), tr(e, "grid-template-columns", "3fr 2fr"), ti(to, "id", "equipslots"), ti(to, "class", "items svelte-ggsnc"), ti(tc, "class", "grid three stats2 svelte-ggsnc")
            },
            m(t, $) {
                Y(t, e, $), G(e, i), G(i, s), G(i, n), G(n, a), G(i, r), G(i, l), G(l, o), G(i, c), G(i, d), G(d, u), G(d, h), G(d, m), G(i, f), G(i, p), G(p, g), G(p, y), G(p, b), G(i, w), G(i, k), G(k, C), G(k, E), G(k, P), G(k, M), G(k, D), G(k, T), G(k, A), G(k, R), G(k, F), G(k, N), G(k, I), G(k, U), G(i, z), G(i, O), tH(L, O, null), G(O, B), tH(q, O, null), G(O, V), G(O, W), G(O, H), G(i, j), tH(te, i, null), G(e, ts);
                for (let _ = 0; _ < 6; _ += 1) ty[_].m(ts, null);
                G(ts, ta), tH(tl, ts, null), Y(t, to, $);
                for (let v = 0; v < tw.length; v += 1) tw[v].m(to, null);
                Y(t, tc, $);
                for (let x = 0; x < tk.length; x += 1) tk[x].m(tc, null);
                td = !0
            },
            p(t, e) {
                (!td || 16 & e) && tu !== (tu = t[4].name + "") && tn(a, tu), (!td || 16 & e) && t$ !== (t$ = t[4].level + "") && tn(o, t$), (!td || 16 & e && u.src !== ($ = rB(t[4].class))) && ti(u, "src", $), (!td || 16 & e) && th !== (th = rC.classes[t[4].class].name + "") && tn(m, th), (!td || 16 & e && _ !== (_ = "bold textc" + t[4].class + " svelte-ggsnc")) && ti(d, "class", _), (!td || 16 & e && g.src !== (v = rq(t[4].faction))) && ti(g, "src", v), (!td || 16 & e) && tm !== (tm = rC.factions[t[4].faction].name + "") && tn(b, tm), (!td || 16 & e && x !== (x = "bold textf" + t[4].faction + " svelte-ggsnc")) && ti(p, "class", x), (!td || 2 & e) && t_ !== (t_ = rX(t[1][20] || 0) + "") && tn(P, t_), (!td || 4 & e) && tf !== (tf = t[2] < bS ? "/ " + rQ(bC[t[2]]) : "") && tn(D, tf), (!td || 4 & e) && tn(F, t[2]);
                let i = {};
                2 & e && (i.amount = t[1][21] || 0), L.$set(i);
                let s = {};
                2 & e && (s.amount = 2 * r8(t[1][21] || 0)), q.$set(s);
                let n = {};
                if (32 & e && (n.amount = t[5]), te.$set(n), 131 & e) {
                    let r;
                    for (tv = [0, 1, 2, 3, 4, 5], r = 0; r < 6; r += 1) {
                        let l = bA(t, tv, r);
                        ty[r] ? (ty[r].p(l, e), tR(ty[r], 1)) : (ty[r] = bR(l), ty[r].c(), tR(ty[r], 1), ty[r].m(ts, ta))
                    }
                    for (tA(), r = 6; r < 6; r += 1) tb(r);
                    t8()
                }
                if (64 & e) {
                    let c;
                    for (tx = t[6].filter(bV), c = 0; c < tx.length; c += 1) {
                        let h = bT(t, tx, c);
                        tw[c] ? (tw[c].p(h, e), tR(tw[c], 1)) : (tw[c] = bF(h), tw[c].c(), tR(tw[c], 1), tw[c].m(to, null))
                    }
                    for (tA(), c = tx.length; c < tw.length; c += 1) t9(c);
                    t8()
                }
                if (1 & e) {
                    let f;
                    for (t3 = bL, f = 0; f < t3.length; f += 1) {
                        let y = bD(t, t3, f);
                        tk[f] ? (tk[f].p(y, e), tR(tk[f], 1)) : (tk[f] = bI(y), tk[f].c(), tR(tk[f], 1), tk[f].m(tc, null))
                    }
                    for (tA(), f = t3.length; f < tk.length; f += 1) t4(f);
                    t8()
                }
            },
            i(t) {
                if (!td) {
                    tR(L.$$.fragment, t), tR(q.$$.fragment, t), tR(te.$$.fragment, t);
                    for (let e = 0; e < 6; e += 1) tR(ty[e]);
                    tR(tl.$$.fragment, t);
                    for (let i = 0; i < tx.length; i += 1) tR(tw[i]);
                    for (let s = 0; s < t3.length; s += 1) tR(tk[s]);
                    td = !0
                }
            },
            o(t) {
                tF(L.$$.fragment, t), tF(q.$$.fragment, t), tF(te.$$.fragment, t), ty = ty.filter(Boolean);
                for (let e = 0; e < 6; e += 1) tF(ty[e]);
                tF(tl.$$.fragment, t), tw = tw.filter(Boolean);
                for (let i = 0; i < tw.length; i += 1) tF(tw[i]);
                tk = tk.filter(Boolean);
                for (let s = 0; s < tk.length; s += 1) tF(tk[s]);
                td = !1
            },
            d(t) {
                t && Q(e), tj(L), tj(q), tj(te), X(ty, t), tj(tl), t && Q(to), X(tw, t), t && Q(tc), X(tk, t)
            }
        }
    }
    let bz = !1,
        bO = new Map;
    bk.forEach((t, e) => {
        let i = new Map;
        t.forEach((t, e) => {
            i.set(e, t)
        }), bO.set(e, i)
    });
    let bL = [
            [6, 8, 7, 9, 12, 13],
            [10, 11, 17, 14, 16],
            [15, 19, 18, 25, 26]
        ],
        bB = t => {
            let {
                from: e,
                to: i
            } = t.detail;
            e !== i && "item" == e.type && $1("itemmove", `${e.slot} ${i.slot}`)
        },
        bq = t => {
            let {
                item: e
            } = t.detail;
            if (void 0 !== e) {
                let i = as.player.inventory.findFirstEmpty();
                void 0 !== i && $1("itemmove", `${t.detail.slot} ${i}`)
            }
        },
        bV = (t, e) => e >= 101;
    class bW extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a, r, l, o;
                N(e, eI, t => s(1, n = t)), N(e, i1, t => s(3, a = t)), N(e, ec, t => s(4, r = t)), N(e, ef, t => s(5, l = t)), N(e, eg, t => s(6, o = t)), as && as.player && !bz && (bz = !0, pG.forEach((t, e) => {
                    e - 60 == as.player.class && t.statsConvert && t.statsConvert.forEach(t => {
                        let e = bk.get(t[0]) || new Map;
                        e.set(t[2], (e.get(t[2]) || 0) + t[1]), bO.set(t[0], e)
                    })
                }));
                let c, d = t => {
                        n[22] && ($1("statincrease", t + " " + (ob.shift.down ? 10 : 1)), s(0, c = void 0), dY(18, 50))
                    },
                    u = (t, e) => s(0, c = t),
                    $ = t => s(0, c = void 0),
                    h = (t, e) => d(t),
                    m = () => {
                        L(i1, a = !1)
                    },
                    _;
                return e.$$.update = () => {
                    2 & e.$$.dirty && s(2, _ = b7(n[20] || 0))
                }, [c, n, _, a, r, l, o, d, u, $, h, m]
            }, function t(e) {
                let i, s, n = e[3] && b8(e);
                return {
                    c() {
                        n && n.c(), i = tt()
                    },
                    m(t, e) {
                        n && n.m(t, e), Y(t, i, e), s = !0
                    },
                    p(t, [e]) {
                        t[3] ? n ? (n.p(t, e), 8 & e && tR(n, 1)) : ((n = b8(t)).c(), tR(n, 1), n.m(i.parentNode, i)) : n && (tA(), tF(n, 1, 1, () => {
                            n = null
                        }), t8())
                    },
                    i(t) {
                        s || (tR(n), s = !0)
                    },
                    o(t) {
                        tF(n), s = !1
                    },
                    d(t) {
                        n && n.d(t), t && Q(i)
                    }
                }
            }, A, {})
        }
    }

    function bH(t, e, i) {
        let s = t.slice();
        return s[8] = e[i], s
    }

    function bj(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g = t[1] ? "Searching..." : "Find " + (t[0].membercount < 2 ? "party" : "members"),
            v = t[0].exprate + "",
            y = 0 === t[0].membercount ? "" : "/" + t[0].nearby,
            b = t[0].itemfind + "",
            x = [],
            w = new Map;

        function k(t, e) {
            return 0 === t[0].membercount ? bY : bG
        }
        let C = k(t),
            S = C(t),
            E = t[3],
            P = t => t[8].name;
        for (let M = 0; M < E.length; M += 1) {
            let T = bH(t, E, M),
                A = P(T);
            w.set(A, x[M] = bQ(A, T))
        }
        return {
            c() {
                e = J("div"), (i = J("div")).textContent = "Party", (s = J("div")).textContent = "" + rC.ui.party.startQueue, n = J("div"), a = K(g), S.c(), l = J("div"), o = K(v), c = K("% EXP"), d = K(y), u = J("div"), $ = K(b), h = K("% FIND"), m = J("div");
                for (let _ = 0; _ < x.length; _ += 1) x[_].c();
                ti(i, "class", "btn party"), ti(s, "class", "btn purp"), ti(n, "id", "partybtn"), ti(n, "class", r = "btn border green " + (t[1] ? "active" : "") + " textwhite"), ti(l, "class", "btn border grey disabled textexp"), ti(u, "class", "btn border grey disabled textcyan"), ti(e, "class", "btnbar"), ti(m, "class", "partyframes svelte-1xmlhk"), tr(m, "width", t[2] + "px")
            },
            m(r, g) {
                Y(r, e, g), G(e, i), G(e, s), G(e, n), G(n, a), S.m(e, null), G(e, l), G(l, o), G(l, c), G(l, d), G(e, u), G(u, $), G(u, h), Y(r, m, g);
                for (let v = 0; v < x.length; v += 1) x[v].m(m, null);
                _ = !0, f || (p = [te(i, "click", t[4]), te(s, "click", t[5]), te(n, "click", t[6])], f = !0)
            },
            p(t, i) {
                if ((!_ || 3 & i) && g !== (g = t[1] ? "Searching..." : "Find " + (t[0].membercount < 2 ? "party" : "members")) && tn(a, g), (!_ || 2 & i && r !== (r = "btn border green " + (t[1] ? "active" : "") + " textwhite")) && ti(n, "class", r), C === (C = k(t)) && S ? S.p(t, i) : (S.d(1), (S = C(t)) && (S.c(), S.m(e, l))), (!_ || 1 & i) && v !== (v = t[0].exprate + "") && tn(o, v), (!_ || 1 & i) && y !== (y = 0 === t[0].membercount ? "" : "/" + t[0].nearby) && tn(d, y), (!_ || 1 & i) && b !== (b = t[0].itemfind + "") && tn($, b), 8 & i) {
                    let s = t[3];
                    tA(), x = tL(x, i, P, 1, t, s, w, m, tO, bQ, null, bH), t8()
                }(!_ || 4 & i) && tr(m, "width", t[2] + "px")
            },
            i(t) {
                if (!_) {
                    for (let e = 0; e < E.length; e += 1) tR(x[e]);
                    _ = !0
                }
            },
            o(t) {
                for (let e = 0; e < x.length; e += 1) tF(x[e]);
                _ = !1
            },
            d(t) {
                t && Q(e), S.d(), t && Q(m);
                for (let i = 0; i < x.length; i += 1) x[i].d();
                f = !1, D(p)
            }
        }
    }

    function bG(t) {
        let e, i, s, n, a = t[0].nearby + "",
            r = t[0].membercount + "";
        return {
            c() {
                e = J("div"), i = K(a), s = K("/"), n = K(r), ti(e, "class", "btn border grey disabled textwhite")
            },
            m(t, a) {
                Y(t, e, a), G(e, i), G(e, s), G(e, n)
            },
            p(t, e) {
                1 & e && a !== (a = t[0].nearby + "") && tn(i, a), 1 & e && r !== (r = t[0].membercount + "") && tn(n, r)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function bY(t) {
        let e;
        return {
            c() {
                (e = J("div")).textContent = "" + rC.ui.party.noParty, ti(e, "class", "btn border grey disabled textgrey")
            },
            m(t, i) {
                Y(t, e, i)
            },
            p: C,
            d(t) {
                t && Q(e)
            }
        }
    }

    function bQ(t, e) {
        let i, s, n;
        return s = new fD({
            props: {
                mode: "party",
                unit: e[8].unitStore,
                buffs: e[8].buffStore
            }
        }), {
            key: t,
            first: null,
            c() {
                i = tt(), tW(s.$$.fragment), this.first = i
            },
            m(t, e) {
                Y(t, i, e), tH(s, t, e), n = !0
            },
            p(t, e) {
                let i = {};
                8 & e && (i.unit = t[8].unitStore), 8 & e && (i.buffs = t[8].buffStore), s.$set(i)
            },
            i(t) {
                n || (tR(s.$$.fragment, t), n = !0)
            },
            o(t) {
                tF(s.$$.fragment, t), n = !1
            },
            d(t) {
                t && Q(i), tj(s, t)
            }
        }
    }
    class bX extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a, r;
                N(e, tK, t => s(0, n = t)), N(e, iQ, t => s(2, a = t)), N(e, tZ, t => s(3, r = t));
                let l = t => {
                        let e = [n.membercount ? _K.partyleave() : _K.partycreate()];
                        et.set({
                            x: t.pageX,
                            y: t.pageY,
                            opts: e
                        })
                    },
                    o = t => {
                        let e = [];
                        if (0 == n.membercount) return l(t);
                        for (let i in _J) {
                            let s = _J[i];
                            if (s.queue) {
                                let a = void 0 === s.minlevel || as.player.level >= s.minlevel;
                                e.push(0 > n.queues.indexOf(i) ? _K.startqueue(i, a) : _K.stopqueue(i, a))
                            }
                        }
                        et.set({
                            x: t.pageX,
                            y: t.pageY,
                            opts: e
                        })
                    },
                    c = () => {
                        dY(33, 100), u || 0 !== n.membercount ? d() : ($1("partycreate", ""), setTimeout(d, 1e3))
                    },
                    d = () => $1(u ? "stopqueue" : "startqueue", n.queues[0] || (_J[as.id + "find"] ? as.id + "find" : "guardstonefind")),
                    u;
                return e.$$.update = () => {
                    1 & e.$$.dirty && s(1, u = n.queues && n.queues.length)
                }, [n, u, a, r, l, o, c]
            }, function t(e) {
                let i, s, n = e[0] && bj(e);
                return {
                    c() {
                        i = J("div"), n && n.c(), ti(i, "class", "l-corner-ul uiscaled")
                    },
                    m(t, e) {
                        Y(t, i, e), n && n.m(i, null), s = !0
                    },
                    p(t, [e]) {
                        t[0] ? n ? (n.p(t, e), 1 & e && tR(n, 1)) : ((n = bj(t)).c(), tR(n, 1), n.m(i, null)) : n && (tA(), tF(n, 1, 1, () => {
                            n = null
                        }), t8())
                    },
                    i(t) {
                        s || (tR(n), s = !0)
                    },
                    o(t) {
                        tF(n), s = !1
                    },
                    d(t) {
                        t && Q(i), n && n.d()
                    }
                }
            }, A, {})
        }
    }

    function bJ(t) {
        let e;
        return {
            c() {
                ti(e = J("div"), "class", "pattern svelte-16344pz")
            },
            m(t, i) {
                Y(t, e, i)
            },
            d(t) {
                t && Q(e)
            }
        }
    }
    class bK extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a, r;
                return N(e, e0, t => s(2, n = t)), e.$$.update = () => {
                    4 & e.$$.dirty && (s(0, a = (100 * n.current / n.max).toFixed(2)), s(1, r = `${rX(n.current)} / ${rX(n.max)} EXP`))
                }, [a, r]
            }, function t(e) {
                let i, s, n;
                return s = new fw({
                    props: {
                        size: "0.8em",
                        fract: e[0],
                        barcol: "bgexp",
                        left: e[1],
                        right: e[0] + "%",
                        $$slots: {
                            default: [bJ]
                        },
                        $$scope: {
                            ctx: e
                        }
                    }
                }), {
                    c() {
                        i = J("div"), tW(s.$$.fragment), ti(i, "id", "expbar"), ti(i, "class", "container svelte-16344pz")
                    },
                    m(t, e) {
                        Y(t, i, e), tH(s, i, null), n = !0
                    },
                    p(t, [e]) {
                        let i = {};
                        1 & e && (i.fract = t[0]), 2 & e && (i.left = t[1]), 1 & e && (i.right = t[0] + "%"), 8 & e && (i.$$scope = {
                            dirty: e,
                            ctx: t
                        }), s.$set(i)
                    },
                    i(t) {
                        n || (tR(s.$$.fragment, t), n = !0)
                    },
                    o(t) {
                        tF(s.$$.fragment, t), n = !1
                    },
                    d(t) {
                        t && Q(i), tj(s)
                    }
                }
            }, A, {})
        }
    }

    function bZ(t) {
        let e, i, s, n, a, r, l, o, c, d, u = t[5].msg + "",
            $ = t[5].fixed || t[5].step || t[5].fixed ? "Skip" : "Next",
            h = (t[5].fixed || t[5].step || t[5].fixed) && xt(t);
        return {
            c() {
                e = J("div"), i = J("div"), h && h.c(), s = J("div"), (n = J("div")).textContent = "Disable tutorial", a = J("div"), r = K($), ti(i, "class", "textprimary msgtext svelte-wv9du9"), ti(n, "class", "btn grey"), ti(a, "class", "btn green"), ti(s, "class", "marg-top"), tr(s, "display", "flex"), tr(s, "justify-content", "space-between"), ti(e, "class", l = "msg " + (t[5].complete ? "complete" : "") + " svelte-wv9du9"), tr(e, "cursor", "pointer")
            },
            m(l, $) {
                Y(l, e, $), G(e, i), i.innerHTML = u, h && h.m(e, null), G(e, s), G(s, n), G(s, a), G(a, r), o = !0, c || (d = [te(n, "click", t[6]), te(e, "click", t[7])], c = !0)
            },
            p(t, n) {
                (!o || 32 & n) && u !== (u = t[5].msg + "") && (i.innerHTML = u), t[5].fixed || t[5].step || t[5].fixed ? h ? (h.p(t, n), 32 & n && tR(h, 1)) : ((h = xt(t)).c(), tR(h, 1), h.m(e, s)) : h && (tA(), tF(h, 1, 1, () => {
                    h = null
                }), t8()), (!o || 32 & n) && $ !== ($ = t[5].fixed || t[5].step || t[5].fixed ? "Skip" : "Next") && tn(r, $), (!o || 32 & n && l !== (l = "msg " + (t[5].complete ? "complete" : "") + " svelte-wv9du9")) && ti(e, "class", l)
            },
            i(t) {
                o || (tR(h), o = !0)
            },
            o(t) {
                tF(h), o = !1
            },
            d(t) {
                t && Q(e), h && h.d(), c = !1, D(d)
            }
        }
    }

    function xt(t) {
        let e, i;
        return e = new fw({
            props: {
                size: "0.8em",
                fract: t[5].progress,
                barcol: "bgtut",
                left: "",
                right: Math.ceil(t[5].progress) + "%"
            }
        }), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            p(t, i) {
                let s = {};
                32 & i && (s.fract = t[5].progress), 32 & i && (s.right = Math.ceil(t[5].progress) + "%"), e.$set(s)
            },
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }

    function xe(t) {
        let e, i;
        return {
            c() {
                ti(e = J("div"), "class", i = "border skill tut " + (t[5].complete ? "complete" : "") + " svelte-wv9du9"), tr(e, "top", t[2] + "px"), tr(e, "left", t[1] + "px"), tr(e, "width", t[3] + "px"), tr(e, "height", t[4] + "px")
            },
            m(t, i) {
                Y(t, e, i)
            },
            p(t, s) {
                32 & s && i !== (i = "border skill tut " + (t[5].complete ? "complete" : "") + " svelte-wv9du9") && ti(e, "class", i), 4 & s && tr(e, "top", t[2] + "px"), 2 & s && tr(e, "left", t[1] + "px"), 8 & s && tr(e, "width", t[3] + "px"), 16 & s && tr(e, "height", t[4] + "px")
            },
            d(t) {
                t && Q(e)
            }
        }
    }
    class xi extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n;
                N(e, e7, t => s(5, n = t));
                let a, r, l, o, c = !1;
                return e7.subscribe(t => {
                    if (t) {
                        let e = document.getElementById(t.element);
                        if (e) {
                            s(0, c = !0);
                            let i = e.getBoundingClientRect();
                            s(3, l = i.width + 10), s(4, o = i.height + 10), s(1, a = i.x - 5), s(2, r = i.y - 5)
                        } else s(0, c = !1)
                    } else s(0, c = !1)
                }), [c, a, r, l, o, n, t => iR.set(1e3), t => {
                    dY(-1, 100)
                }]
            }, function t(e) {
                let i, s, n, a = e[5] && e[5].msg && bZ(e),
                    r = e[0] && xe(e);
                return {
                    c() {
                        a && a.c(), i = tt(), r && r.c(), s = tt()
                    },
                    m(t, e) {
                        a && a.m(t, e), Y(t, i, e), r && r.m(t, e), Y(t, s, e), n = !0
                    },
                    p(t, [e]) {
                        t[5] && t[5].msg ? a ? (a.p(t, e), 32 & e && tR(a, 1)) : ((a = bZ(t)).c(), tR(a, 1), a.m(i.parentNode, i)) : a && (tA(), tF(a, 1, 1, () => {
                            a = null
                        }), t8()), t[0] ? r ? r.p(t, e) : ((r = xe(t)).c(), r.m(s.parentNode, s)) : r && (r.d(1), r = null)
                    },
                    i(t) {
                        n || (tR(a), n = !0)
                    },
                    o(t) {
                        tF(a), n = !1
                    },
                    d(t) {
                        a && a.d(t), t && Q(i), r && r.d(t), t && Q(s)
                    }
                }
            }, A, {})
        }
    }
    let xs = async (t, e, i) => {
        let s = await fetch(t, {
            method: void 0 !== e ? "POST" : "GET",
            body: e ? JSON.stringify(e) : void 0
        });
        return 500 === s.status ? i(await s.text()) : await s.json()
    };

    function xn(t, e, i) {
        let s = t.slice();
        return s[7] = e[i], s[9] = i, s
    }

    function xa(t) {
        let e, i, s;
        return (i = new fg({
            props: {
                title: "Report a player",
                $$slots: {
                    default: [xd]
                },
                $$scope: {
                    ctx: t
                }
            }
        })).$on("close", t[4]), {
            c() {
                e = J("div"), tW(i.$$.fragment), ti(e, "class", "absCentered"), tr(e, "z-index", "8")
            },
            m(t, n) {
                Y(t, e, n), tH(i, e, null), s = !0
            },
            p(t, e) {
                let s = {};
                1031 & e && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }), i.$set(s)
            },
            i(t) {
                s || (tR(i.$$.fragment, t), s = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), s = !1
            },
            d(t) {
                t && Q(e), tj(i)
            }
        }
    }

    function xr(t) {
        let e, i, s, n = t[7] + "";
        return {
            c() {
                e = J("option"), i = K(n), e.__value = s = t[9], e.value = e.__value
            },
            m(t, s) {
                Y(t, e, s), G(e, i)
            },
            p: C,
            d(t) {
                t && Q(e)
            }
        }
    }

    function xl(t) {
        let e, i, s = t[2].info + "";
        return {
            c() {
                e = J("p"), i = K(s), ti(e, "class", "textprimary")
            },
            m(t, s) {
                Y(t, e, s), G(e, i)
            },
            p(t, e) {
                4 & e && s !== (s = t[2].info + "") && tn(i, s)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function xo(t) {
        let e, i, s, n, a, r, l, o = ("ok" === t[0].result ? "Report submitted." : t[0].result) + "";
        return {
            c() {
                e = J("p"), i = K(o), n = J("div"), (a = J("div")).textContent = "Close", ti(e, "class", s = "ok" === t[0].result ? "textgreen" : "textred"), ti(a, "class", "btn grey navbtn"), ti(n, "class", "subnav")
            },
            m(s, o) {
                Y(s, e, o), G(e, i), Y(s, n, o), G(n, a), r || (l = te(a, "click", t[4]), r = !0)
            },
            p(t, n) {
                1 & n && o !== (o = ("ok" === t[0].result ? "Report submitted." : t[0].result) + "") && tn(i, o), 1 & n && s !== (s = "ok" === t[0].result ? "textgreen" : "textred") && ti(e, "class", s)
            },
            d(t) {
                t && Q(e), t && Q(n), r = !1, l()
            }
        }
    }

    function xc(t) {
        let e, i, s, n, a, r, l, o, c;
        return {
            c() {
                e = J("div"), i = J("div"), s = K("Report"), a = J("div"), r = K("Cancel"), ti(i, "class", n = "btn grey navbtn " + (t[1] ? "disabled" : "")), ti(a, "class", l = "btn grey navbtn " + (t[1] ? "disabled" : "")), ti(e, "class", "subnav")
            },
            m(n, l) {
                Y(n, e, l), G(e, i), G(i, s), G(e, a), G(a, r), o || (c = [te(i, "click", t[3]), te(a, "click", t[4])], o = !0)
            },
            p(t, e) {
                2 & e && n !== (n = "btn grey navbtn " + (t[1] ? "disabled" : "")) && ti(i, "class", n), 2 & e && l !== (l = "btn grey navbtn " + (t[1] ? "disabled" : "")) && ti(a, "class", l)
            },
            d(t) {
                t && Q(e), o = !1, D(c)
            }
        }
    }

    function xd(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v = t[2].name + "",
            y = rC.ui.report.info[t[2].reason] + "",
            b = rC.ui.report.reasons,
            x = [];
        for (let w = 0; w < b.length; w += 1) x[w] = xr(xn(t, b, w));
        let k = t[2].info && xl(t);

        function C(t, e) {
            return t[0] ? xo : xc
        }
        let S = C(t),
            E = S(t);
        return {
            c() {
                e = J("div"), i = J("p"), s = K("Describe what happened with "), n = J("span"), a = K(v), r = K(" as accurately as you can:"), l = J("div"), o = J("select");
                for (let p = 0; p < x.length; p += 1) x[p].c();
                d = J("p"), u = J("small"), $ = K(y), k && k.c(), h = J("div"), m = J("textarea"), (f = J("p")).innerHTML = '<small>Please do not file false reports. If you are unsure about a players behavior, refer to our <a href="/terms" target="_blank">Conduct Policy</a>.</small>', E.c(), ti(n, "class", "textprimary"), ti(o, "class", c = t[1] ? "disabled" : ""), void 0 === t[2].reason && t4(() => t[5].call(o)), ti(l, "class", "subnav"), ti(d, "class", "textgrey"), ti(m, "maxlength", "300"), ti(m, "class", _ = "scrollbar reportdescription " + (t[1] ? "disabled" : "") + " svelte-jnzoj3"), ti(m, "rows", "4"), ti(m, "placeholder", "Provide additional context, a little description of the situation helps our moderators."), ti(h, "class", "subnav"), ti(f, "class", "textgrey"), ti(e, "class", "card container svelte-jnzoj3")
            },
            m(c, _) {
                Y(c, e, _), G(e, i), G(i, s), G(i, n), G(n, a), G(i, r), G(e, l), G(l, o);
                for (let v = 0; v < x.length; v += 1) x[v].m(o, null);
                tl(o, t[2].reason), G(e, d), G(d, u), G(u, $), k && k.m(e, null), G(e, h), G(h, m), ta(m, t[2].description), G(e, f), E.m(e, null), p || (g = [te(o, "change", t[5]), te(m, "input", t[6])], p = !0)
            },
            p(t, i) {
                4 & i && v !== (v = t[2].name + "") && tn(a, v), 2 & i && c !== (c = t[1] ? "disabled" : "") && ti(o, "class", c), 4 & i && tl(o, t[2].reason), 4 & i && y !== (y = rC.ui.report.info[t[2].reason] + "") && tn($, y), t[2].info ? k ? k.p(t, i) : ((k = xl(t)).c(), k.m(e, h)) : k && (k.d(1), k = null), 2 & i && _ !== (_ = "scrollbar reportdescription " + (t[1] ? "disabled" : "") + " svelte-jnzoj3") && ti(m, "class", _), 4 & i && ta(m, t[2].description), S === (S = C(t)) && E ? E.p(t, i) : (E.d(1), (E = S(t)) && (E.c(), E.m(e, null)))
            },
            d(t) {
                t && Q(e), X(x, t), k && k.d(), E.d(), p = !1, D(g)
            }
        }
    }
    class xu extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n;
                N(e, e3, t => s(2, n = t));
                let a, r = !1,
                    l = async () => {
                        s(1, r = !0), s(0, a = await xs("/api/report/submit", {
                            name: n.name,
                            reason: n.reason,
                            messageId: n.messageId,
                            description: n.description || ""
                        }))
                    }, o = () => {
                        L(e3, n = void 0), s(0, a = void 0), s(1, r = void 0)
                    };
                return [a, r, n, l, o, function t() {
                    n.reason = to(this), e3.set(n)
                }, function t() {
                    n.description = this.value, e3.set(n)
                }]
            }, function t(e) {
                let i, s, n = void 0 !== e[2] && xa(e);
                return {
                    c() {
                        n && n.c(), i = tt()
                    },
                    m(t, e) {
                        n && n.m(t, e), Y(t, i, e), s = !0
                    },
                    p(t, [e]) {
                        void 0 !== t[2] ? n ? (n.p(t, e), 4 & e && tR(n, 1)) : ((n = xa(t)).c(), tR(n, 1), n.m(i.parentNode, i)) : n && (tA(), tF(n, 1, 1, () => {
                            n = null
                        }), t8())
                    },
                    i(t) {
                        s || (tR(n), s = !0)
                    },
                    o(t) {
                        tF(n), s = !1
                    },
                    d(t) {
                        n && n.d(t), t && Q(i)
                    }
                }
            }, A, {})
        }
    }
    let x$ = t => 50 * Math.round((10 + 5 * t) ** 1.85 / 50),
        xh = t => Math.min(100, 8 + 2 * t),
        xm = (t, e = 200) => {
            let i;
            return (s, n) => {
                i && clearTimeout(i), i = setTimeout(e => t(s), null == n ? e : n)
            }
        };

    function x_(t, e, i) {
        let s = t.slice();
        return s[18] = e[i], s[20] = i, s
    }

    function xf(t) {
        let e, i, s, n = t[2],
            a = [];
        for (let r = 0; r < n.length; r += 1) a[r] = xg(x_(t, n, r));
        let l = t => tF(a[t], 1, 1, () => {
                a[t] = null
            }),
            o = null;
        return n.length || (o = xp()), {
            c() {
                e = J("div");
                for (let t = 0; t < a.length; t += 1) a[t].c();
                i = tt(), o && o.c(), ti(e, "class", "divider")
            },
            m(t, n) {
                Y(t, e, n);
                for (let r = 0; r < a.length; r += 1) a[r].m(t, n);
                Y(t, i, n), o && o.m(t, n), s = !0
            },
            p(t, e) {
                if (148 & e) {
                    let s;
                    for (n = t[2], s = 0; s < n.length; s += 1) {
                        let r = x_(t, n, s);
                        a[s] ? (a[s].p(r, e), tR(a[s], 1)) : (a[s] = xg(r), a[s].c(), tR(a[s], 1), a[s].m(i.parentNode, i))
                    }
                    for (tA(), s = n.length; s < a.length; s += 1) l(s);
                    t8(), n.length ? o && (o.d(1), o = null) : o || ((o = xp()).c(), o.m(i.parentNode, i))
                }
            },
            i(t) {
                if (!s) {
                    for (let e = 0; e < n.length; e += 1) tR(a[e]);
                    s = !0
                }
            },
            o(t) {
                a = a.filter(Boolean);
                for (let e = 0; e < a.length; e += 1) tF(a[e]);
                s = !1
            },
            d(t) {
                t && Q(e), X(a, t), t && Q(i), o && o.d(t)
            }
        }
    }

    function xp(t) {
        let e;
        return {
            c() {
                (e = J("div")).textContent = "No results", ti(e, "class", "textgrey result")
            },
            m(t, i) {
                Y(t, e, i)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function xg(t) {
        let e, i, s, n, a, r, l = [t[18]],
            o = {};
        for (let c = 0; c < l.length; c += 1) o = E(o, l[c]);

        function d(...e) {
            return t[15](t[20], ...e)
        }
        return i = new fn({
            props: o
        }), {
            c() {
                e = J("div"), tW(i.$$.fragment), ti(e, "class", s = "result " + (t[20] === t[4] ? "sel" : ""))
            },
            m(t, s) {
                Y(t, e, s), tH(i, e, null), n = !0, a || (r = te(e, "mousedown", d), a = !0)
            },
            p(a, r) {
                t = a;
                let o = 4 & r ? tB(l, [tq(t[18])]) : {};
                i.$set(o), (!n || 16 & r && s !== (s = "result " + (t[20] === t[4] ? "sel" : ""))) && ti(e, "class", s)
            },
            i(t) {
                n || (tR(i.$$.fragment, t), n = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), n = !1
            },
            d(t) {
                t && Q(e), tj(i), a = !1, r()
            }
        }
    }
    class xv extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n = xm(async () => {
                        s(2, $ = await xs("api/playerinfo/search", {
                            [c]: o,
                            order: "name",
                            limit: d
                        })), _($.findIndex(t => t.name.toLowerCase() == o.toLowerCase()))
                    }),
                    a, r, {
                        id: l
                    } = i,
                    {
                        name: o = ""
                    } = i,
                    {
                        type: c = "name"
                    } = i,
                    {
                        limit: d = 5
                    } = i,
                    {
                        placeholder: u = rC.ui.playername
                    } = i,
                    $ = [],
                    h = !1,
                    m = -1,
                    _ = t => {
                        s(4, m = t), m >= 0 && (s(0, o = (a = $[m]).name), s(8, l = a.id))
                    },
                    f = t => {
                        t.target == r && ((38 === t.keyCode || 40 === t.keyCode) && $.length ? (_(aB(m + (38 === t.keyCode ? -1 : 1), $.length)), t.preventDefault()) : 13 != t.keyCode && 27 != t.keyCode || r.blur())
                    };
                tg(() => {
                    document.addEventListener("keydown", f)
                }), ty(() => {
                    document.removeEventListener("keydown", f), s(5, r = void 0)
                });
                let p = t => s(3, h = !0),
                    g = t => s(3, h = !1),
                    v = (t, e) => _(t);
                return e.$$set = t => {
                    "id" in t && s(8, l = t.id), "name" in t && s(0, o = t.name), "type" in t && s(9, c = t.type), "limit" in t && s(10, d = t.limit), "placeholder" in t && s(1, u = t.placeholder)
                }, [o, u, $, h, m, r, n, _, l, c, d, function t(e) {
                    tw[e ? "unshift" : "push"](() => {
                        s(5, r = e)
                    })
                }, function t() {
                    s(0, o = this.value)
                }, p, g, v]
            }, function t(e) {
                let i, s, n, a, r, l, o, c = e[3] && xf(e);
                return {
                    c() {
                        i = J("div"), s = J("div"), n = J("input"), c && c.c(), ti(n, "placeholder", e[1]), ti(n, "type", "text"), ti(s, "class", a = "container input " + (e[3] ? "focus" : "")), ti(i, "class", "navbtn finder")
                    },
                    m(t, a) {
                        Y(t, i, a), G(i, s), G(s, n), e[11](n), ta(n, e[0]), c && c.m(s, null), r = !0, l || (o = [te(n, "input", e[12]), te(n, "input", e[6]), te(n, "focus", e[13]), te(n, "blur", e[14])], l = !0)
                    },
                    p(t, [e]) {
                        (!r || 2 & e) && ti(n, "placeholder", t[1]), 1 & e && n.value !== t[0] && ta(n, t[0]), t[3] ? c ? (c.p(t, e), 8 & e && tR(c, 1)) : ((c = xf(t)).c(), tR(c, 1), c.m(s, null)) : c && (tA(), tF(c, 1, 1, () => {
                            c = null
                        }), t8()), (!r || 8 & e && a !== (a = "container input " + (t[3] ? "focus" : ""))) && ti(s, "class", a)
                    },
                    i(t) {
                        r || (tR(c), r = !0)
                    },
                    o(t) {
                        tF(c), r = !1
                    },
                    d(t) {
                        t && Q(i), e[11](null), c && c.d(), l = !1, D(o)
                    }
                }
            }, A, {
                id: 8,
                name: 0,
                type: 9,
                limit: 10,
                placeholder: 1
            })
        }
    }

    function xy(t, e, i) {
        let s = t.slice();
        return s[24] = e[i], s[23] = i, s
    }

    function x0(t, e, i) {
        let s = t.slice();
        return s[21] = e[i], s[23] = i, s
    }

    function xb(t, e, i) {
        let s = t.slice();
        return s[26] = e[i], s[23] = i, s
    }

    function xx(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v, y, b, x, w, k, C, S, E, P, M, D, T, A, R, F, N, I, U, z, O, L, B, q, V, W, H, j, X, ts, ta, tr, tl, to, tc, td, tu, t$, th, tm, t_, tf, tp = t[0].tag + "",
            tg = t[0].name + "",
            tv = rC.factions[t[0].faction].name + "",
            ty = t[0].level + "",
            t0 = xh(t[0].level) + "",
            tb = xh(t[0].level + 1) - xh(t[0].level) + "",
            tx = t[0].tax + "",
            tw = t[0].members.length + "",
            t1 = `${t[0].online} (+${60*t[0].online} EXP/h)`,
            t9 = rX(t[0].prestige) + "";
        _ = new fw({
            props: {
                size: "1em",
                fract: Math.ceil(t[0].exp / x$(t[0].level) * 100),
                barcol: "bgpurp",
                left: `${rX(t[0].exp)} / ${rX(x$(t[0].level))} EXP`,
                right: Math.ceil(t[0].exp / x$(t[0].level) * 100) + "% "
            }
        }), ta = new gM({
            props: {
                amount: t[0].gold
            }
        });
        let t3 = t[0].role > -1 && xw(t),
            tk = t[0].role > 0 && x1(t),
            t2 = t[0].eligibleApply.length > 0 && x9(t),
            t4 = t[1] && xk(t),
            tC = t[0].role > 0 && x2(t),
            tS = [xC, x4],
            t7 = [];

        function tE(t, e) {
            return "members" == t[6] ? 0 : "applications" == t[6] ? 1 : -1
        }
        return ~(tu = tE(t)) && (t$ = t7[tu] = tS[tu](t)), {
            c() {
                e = J("div"), i = J("img"), n = J("div"), a = J("div"), r = J("h1"), l = K(tp), o = J("h3"), c = K(tg), u = J("p"), $ = K(tv), h = K(" Clan"), m = J("div"), tW(_.$$.fragment), f = J("div"), p = J("div"), g = J("div"), (v = J("span")).textContent = "Clan Level", y = J("span"), b = K(ty), (x = J("span")).textContent = "Capacity", w = J("span"), k = K(t0), (C = J("span")).textContent = "Next Level", S = J("span"), E = K("+"), P = K(tb), M = K(" Capacity"), (D = J("span")).textContent = "Tax rate", T = J("span"), A = K(tx), R = K("%"), F = J("div"), N = J("div"), (I = J("span")).textContent = "Members", U = J("span"), z = K(tw), (O = J("span")).textContent = "Online", L = J("span"), B = K(t1), (q = J("span")).textContent = "Prestige", V = J("span"), W = J("img"), j = Z(), X = K(t9), (ts = J("span")).textContent = "Treasury", tW(ta.$$.fragment), t3 && t3.c(), tr = tt(), tk && tk.c(), tl = tt(), t2 && t2.c(), to = tt(), t4 && t4.c(), tc = J("div"), (td = J("div")).textContent = "Members", tC && tC.c(), t$ && t$.c(), th = tt(), ti(i, "class", "helmet absCentered svelte-6t8hqd"), i.src !== (s = "/assets/ui/factions/" + t[0].faction + ".svg?v=5699699") && ti(i, "src", s), ti(a, "class", d = "textf" + t[0].faction + " svelte-6t8hqd"), ti(n, "class", "textcenter"), ti(e, "class", "hero svelte-6t8hqd"), ti(m, "class", "panel-black svelte-6t8hqd"), ti(v, "class", "textprimary"), ti(x, "class", "textprimary"), ti(C, "class", "textprimary"), ti(D, "class", "textprimary"), ti(g, "class", "panel-black grid two svelte-6t8hqd"), ti(I, "class", "textprimary"), ti(O, "class", "textprimary"), ti(q, "class", "textprimary"), ti(W, "class", "svgicon"), W.src !== (H = rW) && ti(W, "src", H), ti(V, "class", "textprestige"), ti(ts, "class", "textprimary"), ti(N, "class", "panel-black grid two svelte-6t8hqd"), ti(f, "class", "marg-top grid two"), ti(td, "class", "btn navbtn grey"), ti(tc, "class", "subnav")
            },
            m(s, d) {
                Y(s, e, d), G(e, i), G(e, n), G(n, a), G(a, r), G(r, l), G(a, o), G(o, c), G(n, u), G(u, $), G(u, h), Y(s, m, d), tH(_, m, null), Y(s, f, d), G(f, p), G(p, g), G(g, v), G(g, y), G(y, b), G(g, x), G(g, w), G(w, k), G(g, C), G(g, S), G(S, E), G(S, P), G(S, M), G(g, D), G(g, T), G(T, A), G(T, R), G(f, F), G(F, N), G(N, I), G(N, U), G(U, z), G(N, O), G(N, L), G(L, B), G(N, q), G(N, V), G(V, W), G(V, j), G(V, X), G(N, ts), tH(ta, N, null), t3 && t3.m(s, d), Y(s, tr, d), tk && tk.m(s, d), Y(s, tl, d), t2 && t2.m(s, d), Y(s, to, d), t4 && t4.m(s, d), Y(s, tc, d), G(tc, td), tC && tC.m(tc, null), ~tu && t7[tu].m(s, d), Y(s, th, d), tm = !0, t_ || (tf = te(td, "click", t[14]), t_ = !0)
            },
            p(t, e) {
                (!tm || 1 & e && i.src !== (s = "/assets/ui/factions/" + t[0].faction + ".svg?v=5699699")) && ti(i, "src", s), (!tm || 1 & e) && tp !== (tp = t[0].tag + "") && tn(l, tp), (!tm || 1 & e) && tg !== (tg = t[0].name + "") && tn(c, tg), (!tm || 1 & e && d !== (d = "textf" + t[0].faction + " svelte-6t8hqd")) && ti(a, "class", d), (!tm || 1 & e) && tv !== (tv = rC.factions[t[0].faction].name + "") && tn($, tv);
                let n = {};
                1 & e && (n.fract = Math.ceil(t[0].exp / x$(t[0].level) * 100)), 1 & e && (n.left = `${rX(t[0].exp)} / ${rX(x$(t[0].level))} EXP`), 1 & e && (n.right = Math.ceil(t[0].exp / x$(t[0].level) * 100) + "% "), _.$set(n), (!tm || 1 & e) && ty !== (ty = t[0].level + "") && tn(b, ty), (!tm || 1 & e) && t0 !== (t0 = xh(t[0].level) + "") && tn(k, t0), (!tm || 1 & e) && tb !== (tb = xh(t[0].level + 1) - xh(t[0].level) + "") && tn(P, tb), (!tm || 1 & e) && tx !== (tx = t[0].tax + "") && tn(A, tx), (!tm || 1 & e) && tw !== (tw = t[0].members.length + "") && tn(z, tw), (!tm || 1 & e) && t1 !== (t1 = `${t[0].online} (+${60*t[0].online} EXP/h)`) && tn(B, t1), (!tm || 1 & e) && t9 !== (t9 = rX(t[0].prestige) + "") && tn(X, t9);
                let r = {};
                1 & e && (r.amount = t[0].gold), ta.$set(r), t[0].role > -1 ? t3 ? t3.p(t, e) : ((t3 = xw(t)).c(), t3.m(tr.parentNode, tr)) : t3 && (t3.d(1), t3 = null), t[0].role > 0 ? tk ? (tk.p(t, e), 1 & e && tR(tk, 1)) : ((tk = x1(t)).c(), tR(tk, 1), tk.m(tl.parentNode, tl)) : tk && (tA(), tF(tk, 1, 1, () => {
                    tk = null
                }), t8()), t[0].eligibleApply.length > 0 ? t2 ? t2.p(t, e) : ((t2 = x9(t)).c(), t2.m(to.parentNode, to)) : t2 && (t2.d(1), t2 = null), t[1] ? t4 ? t4.p(t, e) : ((t4 = xk(t)).c(), t4.m(tc.parentNode, tc)) : t4 && (t4.d(1), t4 = null), t[0].role > 0 ? tC ? tC.p(t, e) : ((tC = x2(t)).c(), tC.m(tc, null)) : tC && (tC.d(1), tC = null);
                let o = tu;
                (tu = tE(t)) === o ? ~tu && t7[tu].p(t, e) : (t$ && (tA(), tF(t7[o], 1, 1, () => {
                    t7[o] = null
                }), t8()), ~tu ? ((t$ = t7[tu]) || (t$ = t7[tu] = tS[tu](t)).c(), tR(t$, 1), t$.m(th.parentNode, th)) : t$ = null)
            },
            i(t) {
                tm || (tR(_.$$.fragment, t), tR(ta.$$.fragment, t), tR(tk), tR(t$), tm = !0)
            },
            o(t) {
                tF(_.$$.fragment, t), tF(ta.$$.fragment, t), tF(tk), tF(t$), tm = !1
            },
            d(t) {
                t && Q(e), t && Q(m), tj(_), t && Q(f), tj(ta), t3 && t3.d(t), t && Q(tr), tk && tk.d(t), t && Q(tl), t2 && t2.d(t), t && Q(to), t4 && t4.d(t), t && Q(tc), tC && tC.d(), ~tu && t7[tu].d(t), t && Q(th), t_ = !1, tf()
            }
        }
    }

    function xw(t) {
        let e, i, s, n, a = rC.ui.clan.roles[t[0].role] + "";
        return {
            c() {
                e = J("div"), (i = J("span")).textContent = "Your highest rank: ", s = J("span"), n = K(a), ti(i, "class", "textprimary"), ti(s, "class", "textgreen"), ti(e, "class", "marg-top panel-black svelte-6t8hqd")
            },
            m(t, a) {
                Y(t, e, a), G(e, i), G(e, s), G(s, n)
            },
            p(t, e) {
                1 & e && a !== (a = rC.ui.clan.roles[t[0].role] + "") && tn(n, a)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function x1(t) {
        let e, i, s, n, a, r, l, o, c, d, u;

        function $(e) {
            t[12].call(null, e)
        }
        let h = {};
        return void 0 !== t[4] && (h.name = t[4]), n = new xv({
            props: h
        }), tw.push(() => tV(n, "name", $)), {
            c() {
                e = J("div"), (i = J("span")).textContent = "Invite players", s = J("div"), tW(n.$$.fragment), r = J("div"), l = K("Invite player"), ti(i, "class", "textgrey"), ti(r, "class", o = "btn formatted navbtn grey " + (t[3] || !t[4].length ? "disabled" : "")), ti(s, "class", "subnav"), ti(e, "class", "marg-top panel-black svelte-6t8hqd")
            },
            m(a, o) {
                Y(a, e, o), G(e, i), G(e, s), tH(n, s, null), G(s, r), G(r, l), c = !0, d || (u = te(r, "click", t[8]), d = !0)
            },
            p(t, e) {
                let i = {};
                !a && 16 & e && (a = !0, i.name = t[4], tC(() => a = !1)), n.$set(i), (!c || 24 & e && o !== (o = "btn formatted navbtn grey " + (t[3] || !t[4].length ? "disabled" : ""))) && ti(r, "class", o)
            },
            i(t) {
                c || (tR(n.$$.fragment, t), c = !0)
            },
            o(t) {
                tF(n.$$.fragment, t), c = !1
            },
            d(t) {
                t && Q(e), tj(n), d = !1, u()
            }
        }
    }

    function x9(t) {
        let e, i, s, n, a, r, l, o, c, d = t[0].eligibleApply,
            u = [];
        for (let $ = 0; $ < d.length; $ += 1) u[$] = x3(xb(t, d, $));
        return {
            c() {
                e = J("div"), (i = J("span")).textContent = "Apply to clan (request invitation)", s = J("div"), n = J("select");
                for (let o = 0; o < u.length; o += 1) u[o].c();
                a = J("div"), r = K("Apply"), ti(i, "class", "textgrey"), ti(n, "class", "navbtn"), void 0 === t[5] && t4(() => t[13].call(n)), ti(a, "class", l = "btn formatted navbtn grey " + (t[3] || !t[5].length ? "disabled" : "")), ti(s, "class", "subnav"), ti(e, "class", "marg-top panel-black svelte-6t8hqd")
            },
            m(l, d) {
                Y(l, e, d), G(e, i), G(e, s), G(s, n);
                for (let $ = 0; $ < u.length; $ += 1) u[$].m(n, null);
                tl(n, t[5]), G(s, a), G(a, r), o || (c = [te(n, "change", t[13]), te(a, "click", t[9])], o = !0)
            },
            p(t, e) {
                if (33 & e) {
                    let i;
                    for (d = t[0].eligibleApply, i = 0; i < d.length; i += 1) {
                        let s = xb(t, d, i);
                        u[i] ? u[i].p(s, e) : (u[i] = x3(s), u[i].c(), u[i].m(n, null))
                    }
                    for (; i < u.length; i += 1) u[i].d(1);
                    u.length = d.length
                }
                33 & e && tl(n, t[5]), 41 & e && l !== (l = "btn formatted navbtn grey " + (t[3] || !t[5].length ? "disabled" : "")) && ti(a, "class", l)
            },
            d(t) {
                t && Q(e), X(u, t), o = !1, D(c)
            }
        }
    }

    function x3(t) {
        let e, i, s, n, a = t[26] + "";
        return {
            c() {
                e = J("option"), i = K(a), e.selected = s = t[5] == t[26], e.__value = n = t[26], e.value = e.__value
            },
            m(t, s) {
                Y(t, e, s), G(e, i)
            },
            p(t, r) {
                1 & r && a !== (a = t[26] + "") && tn(i, a), 33 & r && s !== (s = t[5] == t[26]) && (e.selected = s), 1 & r && n !== (n = t[26]) && (e.__value = n, e.value = e.__value)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function xk(t) {
        let e, i, s, n, a;
        return {
            c() {
                e = J("div"), i = J("span"), s = K(t[1]), ti(i, "class", n = "text" + t[2] + " svelte-6t8hqd"), ti(e, "class", a = "marg-top panel-black border " + t[2] + " svelte-6t8hqd")
            },
            m(t, n) {
                Y(t, e, n), G(e, i), G(i, s)
            },
            p(t, r) {
                2 & r && tn(s, t[1]), 4 & r && n !== (n = "text" + t[2] + " svelte-6t8hqd") && ti(i, "class", n), 4 & r && a !== (a = "marg-top panel-black border " + t[2] + " svelte-6t8hqd") && ti(e, "class", a)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function x2(t) {
        let e, i, s, n, a, r, l, o = t[0].applications.length + "";
        return {
            c() {
                e = J("div"), i = K("Applications ("), s = K(o), n = K(")"), a = Z(), ti(e, "class", "btn navbtn grey")
            },
            m(o, c) {
                Y(o, e, c), G(e, i), G(e, s), G(e, n), Y(o, a, c), r || (l = te(e, "click", t[15]), r = !0)
            },
            p(t, e) {
                1 & e && o !== (o = t[0].applications.length + "") && tn(s, o)
            },
            d(t) {
                t && Q(e), t && Q(a), r = !1, l()
            }
        }
    }

    function x4(t) {
        let e, i, s, n, a, r = [],
            l = new Map,
            o = t[0].applications,
            c = t => t[24].name;
        for (let d = 0; d < o.length; d += 1) {
            let u = xy(t, o, d),
                $ = c(u);
            l.set($, r[d] = xS($, u))
        }
        return {
            c() {
                (e = J("div")).textContent = "This is a list of active applications to your clan. Right click to accept an application and invite the player to your clan", i = J("table"), (s = J("thead")).innerHTML = '<tr class="textprimary"><th width="70%">Player</th></tr>', n = J("tbody");
                for (let t = 0; t < r.length; t += 1) r[t].c();
                ti(e, "class", "marg-top textgrey"), ti(i, "class", "marg-top panel-black svelte-6t8hqd")
            },
            m(t, l) {
                Y(t, e, l), Y(t, i, l), G(i, s), G(i, n);
                for (let o = 0; o < r.length; o += 1) r[o].m(n, null);
                a = !0
            },
            p(t, e) {
                if (1025 & e) {
                    let i = t[0].applications;
                    tA(), r = tL(r, e, c, 1, t, i, l, n, tO, xS, null, xy), t8()
                }
            },
            i(t) {
                if (!a) {
                    for (let e = 0; e < o.length; e += 1) tR(r[e]);
                    a = !0
                }
            },
            o(t) {
                for (let e = 0; e < r.length; e += 1) tF(r[e]);
                a = !1
            },
            d(t) {
                t && Q(e), t && Q(i);
                for (let s = 0; s < r.length; s += 1) r[s].d()
            }
        }
    }

    function xC(t) {
        let e, i, s, n, a, r = [],
            l = new Map,
            o = t[0].members,
            c = t => t[21].name;
        for (let d = 0; d < o.length; d += 1) {
            let u = x0(t, o, d),
                $ = c(u);
            l.set($, r[d] = x7($, u))
        }
        return {
            c() {
                (e = J("div")).textContent = "This is a list of active members of this clan. Right click the members for additional options.", i = J("table"), (s = J("thead")).innerHTML = '<tr class="textprimary"><th width="70%">Member</th><th>Rank</th></tr>', n = J("tbody");
                for (let t = 0; t < r.length; t += 1) r[t].c();
                ti(e, "class", "marg-top textgrey"), ti(i, "class", "marg-top panel-black svelte-6t8hqd")
            },
            m(t, l) {
                Y(t, e, l), Y(t, i, l), G(i, s), G(i, n);
                for (let o = 0; o < r.length; o += 1) r[o].m(n, null);
                a = !0
            },
            p(t, e) {
                if (129 & e) {
                    let i = t[0].members;
                    tA(), r = tL(r, e, c, 1, t, i, l, n, tO, x7, null, x0), t8()
                }
            },
            i(t) {
                if (!a) {
                    for (let e = 0; e < o.length; e += 1) tR(r[e]);
                    a = !0
                }
            },
            o(t) {
                for (let e = 0; e < r.length; e += 1) tF(r[e]);
                a = !1
            },
            d(t) {
                t && Q(e), t && Q(i);
                for (let s = 0; s < r.length; s += 1) r[s].d()
            }
        }
    }

    function xS(t, e) {
        let i, s, n, a, r, l;

        function o(...t) {
            return e[17](e[24], ...t)
        }
        return n = new fn({
            props: {
                name: e[24].name,
                pclass: e[24].class,
                level: e[24].level,
                faction: e[0].faction
            }
        }), {
            key: t,
            first: null,
            c() {
                i = J("tr"), s = J("td"), tW(n.$$.fragment), ti(i, "class", "striped"), this.first = i
            },
            m(t, e) {
                Y(t, i, e), G(i, s), tH(n, s, null), a = !0, r || (l = te(i, "mousedown", o), r = !0)
            },
            p(t, i) {
                e = t;
                let s = {};
                1 & i && (s.name = e[24].name), 1 & i && (s.pclass = e[24].class), 1 & i && (s.level = e[24].level), 1 & i && (s.faction = e[0].faction), n.$set(s)
            },
            i(t) {
                a || (tR(n.$$.fragment, t), a = !0)
            },
            o(t) {
                tF(n.$$.fragment, t), a = !1
            },
            d(t) {
                t && Q(i), tj(n), r = !1, l()
            }
        }
    }

    function x7(t, e) {
        let i, s, n, a, r, l, o, c, d, u, $, h, m = e[21].online ? "" : "",
            _ = e[21].owned ? "" : "",
            f = rC.ui.clan.roles[e[21].clanrole] + "";

        function p(...t) {
            return e[16](e[21], ...t)
        }
        return n = new fn({
            props: {
                name: e[21].name,
                pclass: e[21].class,
                level: e[21].level,
                faction: e[0].faction
            }
        }), {
            key: t,
            first: null,
            c() {
                i = J("tr"), s = J("td"), tW(n.$$.fragment), a = J("span"), r = K(m), l = K(_), o = J("td"), c = K(f), ti(a, "class", "textgreen"), ti(i, "class", d = "striped " + (e[21].online ? "" : "offline") + " svelte-6t8hqd"), this.first = i
            },
            m(t, e) {
                Y(t, i, e), G(i, s), tH(n, s, null), G(s, a), G(a, r), G(a, l), G(i, o), G(o, c), u = !0, $ || (h = te(i, "mousedown", p), $ = !0)
            },
            p(t, s) {
                e = t;
                let a = {};
                1 & s && (a.name = e[21].name), 1 & s && (a.pclass = e[21].class), 1 & s && (a.level = e[21].level), 1 & s && (a.faction = e[0].faction), n.$set(a), (!u || 1 & s) && m !== (m = e[21].online ? "" : "") && tn(r, m), (!u || 1 & s) && _ !== (_ = e[21].owned ? "" : "") && tn(l, _), (!u || 1 & s) && f !== (f = rC.ui.clan.roles[e[21].clanrole] + "") && tn(c, f), (!u || 1 & s && d !== (d = "striped " + (e[21].online ? "" : "offline") + " svelte-6t8hqd")) && ti(i, "class", d)
            },
            i(t) {
                u || (tR(n.$$.fragment, t), u = !0)
            },
            o(t) {
                tF(n.$$.fragment, t), u = !1
            },
            d(t) {
                t && Q(i), tj(n), $ = !1, h()
            }
        }
    }
    class xE extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a, {
                        tag: r
                    } = i,
                    l = async () => {
                        let t = await xs("/api/claninfo/info", {
                            tag: r
                        });
                        t.name && (s(0, n = t), n.eligibleApply.length && s(5, _ = n.eligibleApply[0]), s(0, n.online = n.members.filter(t => t.online).length, n)), a && (clearTimeout(a), a = setTimeout(l, 5e3))
                    };
                a = !0, l(), ty(() => {
                    clearTimeout(a), a = void 0
                });
                let o = (t, e) => {
                        let i = [];
                        e.owned ? i.push({
                            name: "Leave clan",
                            async fun() {
                                $(await xs("/api/clan/leave", {
                                    name: e.name
                                }), "Left the clan")
                            }
                        }) : e.clanrole < n.role && i.push({
                            name: "Kick member",
                            async fun() {
                                $(await xs("/api/clan/kick", {
                                    name: e.name
                                }), "Member kicked")
                            }
                        });
                        for (let s = 0; s < (3 == n.role ? 4 : n.role); s++) i.push({
                            name: "Set rank: " + rC.ui.clan.roles[s],
                            async fun() {
                                $(await xs("/api/clan/setrole", {
                                    name: e.name,
                                    role: s
                                }), "Set rank: " + rC.ui.clan.roles[s])
                            }
                        });
                        et.set({
                            x: t.pageX,
                            y: t.pageY,
                            opts: i
                        })
                    },
                    c, d, u = !1,
                    $ = async (t, e) => {
                        "ok" !== t.result ? (s(1, c = t.result), s(2, d = "red")) : (s(1, c = e), s(2, d = "green")), await l(), s(3, u = !1)
                    }, h = "", m = async () => {
                        s(3, u = !0), $(await xs("/api/clan/invite", {
                            name: h,
                            tag: r
                        }), h + " invited"), s(4, h = "")
                    }, _ = "", f = async () => {
                        s(3, u = !0), $(await xs("/api/clan/apply", {
                            name: _,
                            tag: r
                        }), "Applied to clan"), s(5, _ = "")
                    }, p = (t, e) => {
                        let i = [];
                        n.role > 0 && i.push({
                            name: "Accept application",
                            async fun() {
                                $(await xs("/api/clan/acceptapplication", {
                                    id: e.id
                                }), "Accepted application")
                            }
                        }), n.role > 1 && i.push({
                            name: "Deny application",
                            async fun() {
                                $(await xs("/api/clan/denyapplication", {
                                    id: e.id
                                }), "Denied application")
                            }
                        }), et.set({
                            x: t.pageX,
                            y: t.pageY,
                            opts: i
                        })
                    }, g = "members", v = t => s(6, g = "members"), y = t => s(6, g = "applications"), b = (t, e) => o(e, t), x = (t, e) => p(e, t);
                return e.$$set = t => {
                    "tag" in t && s(11, r = t.tag)
                }, [n, c, d, u, h, _, g, o, m, f, p, r, function t(e) {
                    s(4, h = e)
                }, function t() {
                    s(5, _ = to(this)), s(0, n)
                }, v, y, b, x]
            }, function t(e) {
                let i, s, n = e[0] && xx(e);
                return {
                    c() {
                        n && n.c(), i = tt()
                    },
                    m(t, e) {
                        n && n.m(t, e), Y(t, i, e), s = !0
                    },
                    p(t, [e]) {
                        t[0] ? n ? (n.p(t, e), 1 & e && tR(n, 1)) : ((n = xx(t)).c(), tR(n, 1), n.m(i.parentNode, i)) : n && (tA(), tF(n, 1, 1, () => {
                            n = null
                        }), t8())
                    },
                    i(t) {
                        s || (tR(n), s = !0)
                    },
                    o(t) {
                        tF(n), s = !1
                    },
                    d(t) {
                        n && n.d(t), t && Q(i)
                    }
                }
            }, A, {
                tag: 11
            })
        }
    }
    class x6 extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n;
                N(e, e_, t => s(4, n = t));
                let a = "",
                    r = "",
                    l = !1,
                    o = "",
                    c = async () => {
                        if (l) return;
                        s(8, l = !0);
                        let t = await xs("/api/clan/create", {
                            name: a,
                            tag: r
                        });
                        "ok" !== t.result && (s(2, o = t.result), s(8, l = !1))
                    }, d;
                return e.$$.update = () => {
                    275 & e.$$.dirty && s(3, d = !l && n >= 1e4 && a.length <= 20 && a.length >= 3 && r.length <= 4 && r.length >= 2)
                }, [a, r, o, d, n, c, function t() {
                    s(0, a = this.value)
                }, function t() {
                    s(1, r = this.value)
                }]
            }, function t(e) {
                let i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g;
                return c = new gM({
                    props: {
                        amount: 1e4
                    }
                }), {
                    c() {
                        (i = J("h3")).textContent = "Create clan", (s = J("label")).textContent = "Clan name", n = J("input"), (a = J("label")).textContent = "Clan tag", r = J("input"), l = J("p"), o = K("Cost: "), tW(c.$$.fragment), u = J("div"), $ = K(e[2]), h = J("div"), m = K("Create"), ti(i, "class", "textprimary"), ti(s, "class", "svelte-7uvqsx"), ti(n, "type", "text"), ti(n, "placeholder", "Guardians of Guardstone (a-Z)"), ti(n, "maxlength", "20"), ti(a, "class", "svelte-7uvqsx"), ti(r, "type", "text"), ti(r, "placeholder", "GoG (a-Z !~=#*+-)"), ti(r, "maxlength", "4"), ti(l, "class", d = "text" + (e[4] > 1e4 ? "primary" : "red")), ti(u, "class", "textred"), tr(h, "display", "inline-block"), ti(h, "class", _ = "btn marg-top formatted " + (e[3] ? "blue" : "blue disabled"))
                    },
                    m(t, d) {
                        Y(t, i, d), Y(t, s, d), Y(t, n, d), ta(n, e[0]), Y(t, a, d), Y(t, r, d), ta(r, e[1]), Y(t, l, d), G(l, o), tH(c, l, null), Y(t, u, d), G(u, $), Y(t, h, d), G(h, m), f = !0, p || (g = [te(n, "input", e[6]), te(r, "input", e[7]), te(h, "click", e[5])], p = !0)
                    },
                    p(t, [e]) {
                        1 & e && n.value !== t[0] && ta(n, t[0]), 2 & e && r.value !== t[1] && ta(r, t[1]), (!f || 16 & e && d !== (d = "text" + (t[4] > 1e4 ? "primary" : "red"))) && ti(l, "class", d), (!f || 4 & e) && tn($, t[2]), (!f || 8 & e && _ !== (_ = "btn marg-top formatted " + (t[3] ? "blue" : "blue disabled"))) && ti(h, "class", _)
                    },
                    i(t) {
                        f || (tR(c.$$.fragment, t), f = !0)
                    },
                    o(t) {
                        tF(c.$$.fragment, t), f = !1
                    },
                    d(t) {
                        t && Q(i), t && Q(s), t && Q(n), t && Q(a), t && Q(r), t && Q(l), tj(c), t && Q(u), t && Q(h), p = !1, D(g)
                    }
                }
            }, A, {})
        }
    }

    function xP(t, e, i) {
        let s = t.slice();
        return s[4] = e[i], s[6] = i, s
    }

    function xM(t) {
        let e, i = [],
            s = new Map,
            n = t[0],
            a = t => t[4].clan;
        for (let r = 0; r < n.length; r += 1) {
            let l = xP(t, n, r),
                o = a(l);
            s.set(o, i[r] = xT(o, l))
        }
        return {
            c() {
                for (let t = 0; t < i.length; t += 1) i[t].c();
                e = tt()
            },
            m(t, s) {
                for (let n = 0; n < i.length; n += 1) i[n].m(t, s);
                Y(t, e, s)
            },
            p(t, n) {
                if (3 & n) {
                    let r = t[0];
                    i = tL(i, n, a, 1, t, r, s, e.parentNode, tz, xT, e, xP)
                }
            },
            d(t) {
                for (let s = 0; s < i.length; s += 1) i[s].d(t);
                t && Q(e)
            }
        }
    }

    function x5(t) {
        let e, i, s;

        function n(...e) {
            return t[2](t[4], ...e)
        }
        return {
            c() {
                (e = J("div")).textContent = "Accept", ti(e, "class", "btn blue")
            },
            m(t, a) {
                Y(t, e, a), i || (s = te(e, "click", n), i = !0)
            },
            p(e, i) {
                t = e
            },
            d(t) {
                t && Q(e), i = !1, s()
            }
        }
    }

    function xD(t) {
        let e;
        return {
            c() {
                (e = J("div")).textContent = "Application"
            },
            m(t, i) {
                Y(t, e, i)
            },
            p: C,
            d(t) {
                t && Q(e)
            }
        }
    }

    function xT(t, e) {
        let i, s, n, a, r, l, o = e[4].tag + "",
            c = e[4].name + "";

        function d(t, e) {
            return t[4].request ? xD : x5
        }
        let u = d(e),
            $ = u(e);
        return {
            key: t,
            first: null,
            c() {
                i = J("tr"), s = J("td"), n = K(o), a = J("td"), r = K(c), l = J("td"), $.c(), ti(i, "class", "striped"), this.first = i
            },
            m(t, e) {
                Y(t, i, e), G(i, s), G(s, n), G(i, a), G(a, r), G(i, l), $.m(l, null)
            },
            p(t, e) {
                1 & e && o !== (o = t[4].tag + "") && tn(n, o), 1 & e && c !== (c = t[4].name + "") && tn(r, c), u === (u = d(t)) && $ ? $.p(t, e) : ($.d(1), ($ = u(t)) && ($.c(), $.m(l, null)))
            },
            d(t) {
                t && Q(i), $.d()
            }
        }
    }
    class xA extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n;
                (async () => {
                    s(0, n = await xs("/api/clan/invites", {
                        name: as.player.name
                    }))
                })();
                let a = async t => {
                    await xs("/api/clan/acceptinvite", {
                        id: t
                    })
                }, r = (t, e) => a(t.id);
                return [n, a, r]
            }, function t(e) {
                let i, s, n, a = e[0] && xM(e);
                return {
                    c() {
                        i = J("table"), (s = J("thead")).innerHTML = '<tr class="textprimary"><th width="20%">Tag</th><th width="60%">Clan Name</th><th>Action</th></tr>', n = J("tbody"), a && a.c(), ti(i, "class", "marg-top panel-black")
                    },
                    m(t, e) {
                        Y(t, i, e), G(i, s), G(i, n), a && a.m(n, null)
                    },
                    p(t, [e]) {
                        t[0] ? a ? a.p(t, e) : ((a = xM(t)).c(), a.m(n, null)) : a && (a.d(1), a = null)
                    },
                    i: C,
                    o: C,
                    d(t) {
                        t && Q(i), a && a.d()
                    }
                }
            }, A, {})
        }
    }

    function x8(t) {
        let e, i, s;
        return (i = new fg({
            props: {
                title: "Clan",
                icon: "clan",
                scroll: "true",
                $$slots: {
                    default: [xz]
                },
                $$scope: {
                    ctx: t
                }
            }
        })).$on("close", t[6]), {
            c() {
                e = J("div"), tW(i.$$.fragment), ti(e, "class", "absCentered container svelte-1rc4ub7")
            },
            m(t, n) {
                Y(t, e, n), tH(i, e, null), s = !0
            },
            p(t, e) {
                let s = {};
                133 & e && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }), i.$set(s)
            },
            i(t) {
                s || (tR(i.$$.fragment, t), s = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), s = !1
            },
            d(t) {
                t && Q(e), tj(i)
            }
        }
    }

    function xR(t) {
        let e, i, s, n, a, r, l;
        return {
            c() {
                e = J("div"), i = J("div"), (s = J("h3")).textContent = "You have no clan", (n = J("div")).textContent = "View invitations", (a = J("div")).textContent = "Create clan", ti(n, "class", "btn grey"), ti(a, "class", "btn grey marg-top"), ti(i, "class", "panel-black"), ti(e, "class", "clanInfoBox textcenter svelte-1rc4ub7")
            },
            m(o, c) {
                Y(o, e, c), G(e, i), G(i, s), G(i, n), G(i, a), r || (l = [te(n, "click", t[4]), te(a, "click", t[5])], r = !0)
            },
            p: C,
            i: C,
            o: C,
            d(t) {
                t && Q(e), r = !1, D(l)
            }
        }
    }

    function xF(t) {
        let e, i, s, n, a, r, l, o = [xU, xI],
            c = [];

        function d(t, e) {
            return "create" == t[0] ? 0 : "invites" == t[0] ? 1 : -1
        }
        return ~(s = d(t)) && (n = c[s] = o[s](t)), {
            c() {
                e = J("div"), (i = J("div")).textContent = "Back", n && n.c(), tr(i, "display", "inline-block"), ti(i, "class", "btn formatted grey"), ti(e, "class", "modemenu svelte-1rc4ub7")
            },
            m(n, o) {
                Y(n, e, o), G(e, i), ~s && c[s].m(e, null), a = !0, r || (l = te(i, "click", t[3]), r = !0)
            },
            p(t, i) {
                let a = s;
                (s = d(t)) !== a && (n && (tA(), tF(c[a], 1, 1, () => {
                    c[a] = null
                }), t8()), ~s ? ((n = c[s]) || (n = c[s] = o[s](t)).c(), tR(n, 1), n.m(e, null)) : n = null)
            },
            i(t) {
                a || (tR(n), a = !0)
            },
            o(t) {
                tF(n), a = !1
            },
            d(t) {
                t && Q(e), ~s && c[s].d(), r = !1, l()
            }
        }
    }

    function xN(t) {
        let e, i, s;
        return i = new xE({
            props: {
                tag: t[2]
            }
        }), {
            c() {
                e = J("div"), tW(i.$$.fragment), ti(e, "class", "clanView svelte-1rc4ub7")
            },
            m(t, n) {
                Y(t, e, n), tH(i, e, null), s = !0
            },
            p(t, e) {
                let s = {};
                4 & e && (s.tag = t[2]), i.$set(s)
            },
            i(t) {
                s || (tR(i.$$.fragment, t), s = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), s = !1
            },
            d(t) {
                t && Q(e), tj(i)
            }
        }
    }

    function xI(t) {
        let e, i;
        return e = new xA({}), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }

    function xU(t) {
        let e, i;
        return e = new x6({}), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }

    function xz(t) {
        let e, i, s, n, a = [xN, xF, xR],
            r = [];

        function l(t, e) {
            return t[2] ? 0 : t[0] ? 1 : 2
        }
        return i = r[e = l(t)] = a[e](t), {
            c() {
                i.c(), s = tt()
            },
            m(t, i) {
                r[e].m(t, i), Y(t, s, i), n = !0
            },
            p(t, n) {
                let o = e;
                (e = l(t)) === o ? r[e].p(t, n) : (tA(), tF(r[o], 1, 1, () => {
                    r[o] = null
                }), t8(), (i = r[e]) || (i = r[e] = a[e](t)).c(), tR(i, 1), i.m(s.parentNode, s))
            },
            i(t) {
                n || (tR(i), n = !0)
            },
            o(t) {
                tF(i), n = !1
            },
            d(t) {
                r[e].d(t), t && Q(s)
            }
        }
    }
    class xO extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a;
                N(e, iy, t => s(1, n = t)), N(e, ez, t => s(2, a = t));
                let r = !1,
                    l = t => s(0, r = !1),
                    o = t => s(0, r = "invites"),
                    c = t => s(0, r = "create"),
                    d = () => {
                        L(iy, n = !1)
                    };
                return [r, n, a, l, o, c, d]
            }, function t(e) {
                let i, s, n = e[1] && x8(e);
                return {
                    c() {
                        n && n.c(), i = tt()
                    },
                    m(t, e) {
                        n && n.m(t, e), Y(t, i, e), s = !0
                    },
                    p(t, [e]) {
                        t[1] ? n ? (n.p(t, e), 2 & e && tR(n, 1)) : ((n = x8(t)).c(), tR(n, 1), n.m(i.parentNode, i)) : n && (tA(), tF(n, 1, 1, () => {
                            n = null
                        }), t8())
                    },
                    i(t) {
                        s || (tR(n), s = !0)
                    },
                    o(t) {
                        tF(n), s = !1
                    },
                    d(t) {
                        n && n.d(t), t && Q(i)
                    }
                }
            }, A, {})
        }
    }
    let xL = t => {
            let e = ~~(t / 86400),
                i = ~~(t / 3600 % 24),
                s = ~~(t / 60 % 60),
                n = ~~(t % 60);
            return `${e?e+"d ":""}${i?i+"h ":""}${s?s+"m ":""}${n?n+"s":""}`
        },
        xB = t => ~~(1e4 + t ** 1.5 * 8e3);

    function xq(t, e, i) {
        let s = t.slice();
        return s[9] = e[i], s[11] = i, s
    }

    function xV(t) {
        let e, i, s;
        return (i = new fg({
            props: {
                title: "War Statistics",
                icon: "pvp",
                $$slots: {
                    default: [xj]
                },
                $$scope: {
                    ctx: t
                }
            }
        })).$on("close", t[8]), {
            c() {
                e = J("div"), tW(i.$$.fragment), ti(e, "class", "absCentered container svelte-g2pdl9")
            },
            m(t, n) {
                Y(t, e, n), tH(i, e, null), s = !0
            },
            p(t, e) {
                let s = {};
                4101 & e && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }), i.$set(s)
            },
            i(t) {
                s || (tR(i.$$.fragment, t), s = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), s = !1
            },
            d(t) {
                t && Q(e), tj(i)
            }
        }
    }

    function xW(t) {
        let e, i, s, n, a, r, l, o = rX(t[2].contrib) + "",
            c = rX(xB(t[2].level)) + "",
            d = t[2].level + "";
        return {
            c() {
                e = J("span"), i = K(o), s = K(" / "), n = K(c), a = K(" (Lv. "), r = K(d), l = K(" War)"), tr(e, "font-size", "14px"), ti(e, "class", "absCentered textprimary")
            },
            m(t, o) {
                Y(t, e, o), G(e, i), G(e, s), G(e, n), G(e, a), G(e, r), G(e, l)
            },
            p(t, e) {
                4 & e && o !== (o = rX(t[2].contrib) + "") && tn(i, o), 4 & e && c !== (c = rX(xB(t[2].level)) + "") && tn(n, c), 4 & e && d !== (d = t[2].level + "") && tn(r, d)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function xH(t, e) {
        let i, s, n, a, r, l, o, c, d, u, $, h, m, _ = rX(e[9].stats[1]) + "",
            f = rX(e[9].stats[2]) + "",
            p = e[9].stats[0] + "",
            g = rX(e[9].stats[3]) + "";
        return n = new fn({
            props: {
                name: e[9].name,
                pclass: e[9].class,
                level: e[9].level,
                faction: e[9].faction
            }
        }), {
            key: t,
            first: null,
            c() {
                i = J("tr"), s = J("td"), tW(n.$$.fragment), a = J("td"), r = K(_), l = J("td"), o = K(f), c = J("td"), d = K(p), u = J("td"), $ = K(g), ti(s, "class", "svelte-g2pdl9"), ti(a, "class", "textcenter svelte-g2pdl9"), ti(l, "class", "textcenter svelte-g2pdl9"), ti(c, "class", "textcenter svelte-g2pdl9"), ti(u, "class", "textcenter textfame svelte-g2pdl9"), ti(i, "class", h = "striped " + (as && as.player && as.player.name === e[9].name ? "selected" : "") + " svelte-g2pdl9"), this.first = i
            },
            m(t, e) {
                Y(t, i, e), G(i, s), tH(n, s, null), G(i, a), G(a, r), G(i, l), G(l, o), G(i, c), G(c, d), G(i, u), G(u, $), m = !0
            },
            p(t, e) {
                let s = {};
                5 & e && (s.name = t[9].name), 5 & e && (s.pclass = t[9].class), 5 & e && (s.level = t[9].level), 5 & e && (s.faction = t[9].faction), n.$set(s), (!m || 5 & e) && _ !== (_ = rX(t[9].stats[1]) + "") && tn(r, _), (!m || 5 & e) && f !== (f = rX(t[9].stats[2]) + "") && tn(o, f), (!m || 5 & e) && p !== (p = t[9].stats[0] + "") && tn(d, p), (!m || 5 & e) && g !== (g = rX(t[9].stats[3]) + "") && tn($, g), (!m || 5 & e && h !== (h = "striped " + (as && as.player && as.player.name === t[9].name ? "selected" : "") + " svelte-g2pdl9")) && ti(i, "class", h)
            },
            i(t) {
                m || (tR(n.$$.fragment, t), m = !0)
            },
            o(t) {
                tF(n.$$.fragment, t), m = !1
            },
            d(t) {
                t && Q(i), tj(n)
            }
        }
    }

    function xj(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v, y, b, x, w, k, C, S, E, P, M, T, A, R, F, N, I, U, z, O, L, B, q, V, W, H, j, X, tt, ts, ta, tl, to, tc, td, tu, t$, th, tm, t_ = t[2].kills[0] + "",
            tf = rX(t[2].reward) + "",
            tp = ["Ended", "Ending Soon", "Active"][t[2].status] + "",
            tg = xL(t[2].duration) + "",
            tv = t[2].kills[1] + "",
            ty = [],
            t0 = new Map;
        N = new fw({
            props: {
                size: "1.3em",
                fract: ~~(t[2].contrib / xB(t[2].level) * 100),
                left: "",
                right: "",
                barcol: "bgpurp",
                $$slots: {
                    default: [xW]
                },
                $$scope: {
                    ctx: t
                }
            }
        });
        let tb = t[2].contributors.sort(t[7]),
            tx = t => t[9].name;
        for (let tw = 0; tw < tb.length; tw += 1) {
            let t1 = xq(t, tb, tw),
                t9 = tx(t1);
            t0.set(t9, ty[tw] = xH(t9, t1))
        }
        return {
            c() {
                e = J("div"), i = J("div"), s = J("div"), n = J("div"), (a = J("span")).textContent = "Vanguard", r = J("span"), l = J("img"), c = Z(), d = K(t_), u = J("div"), $ = J("span"), h = J("img"), _ = Z(), f = K(tf), p = J("span"), g = K("War Status: "), v = J("span"), y = K(tp), x = J("span"), w = K("Duration: "), k = J("span"), C = K(tg), S = Z(), E = J("div"), (P = J("span")).textContent = "Bloodlust", M = J("span"), T = J("img"), R = Z(), F = K(tv), tW(N.$$.fragment), I = J("div"), U = J("table"), z = J("thead"), O = J("tr"), (L = J("th")).textContent = "Player", B = J("th"), q = K("Damage"), W = J("th"), H = K("Healing"), X = J("th"), tt = K("Kills"), ta = J("th"), tl = J("img"), tc = K(" Fame"), tu = J("tbody");
                for (let D = 0; D < ty.length; D += 1) ty[D].c();
                ti(a, "class", "infosmall textf0 svelte-g2pdl9"), tr(a, "margin-top", "30px"), ti(l, "class", "svgicon"), l.src !== (o = "/assets/ui/icons/pvp.svg?v=5699699") && ti(l, "src", o), ti(r, "class", "infobig textprimary svelte-g2pdl9"), tr(r, "margin-top", "10px"), ti(h, "class", "svgicon"), h.src !== (m = rH) && ti(h, "src", m), ti($, "class", "infobig textfame svelte-g2pdl9"), tr($, "margin-top", "20px"), ti(v, "class", b = "text" + ["red", "orange", "green"][t[2].status] + " svelte-g2pdl9"), ti(p, "class", "infosmall svelte-g2pdl9"), tr(p, "margin-top", "10px"), ti(k, "class", "textprimary"), ti(x, "class", "infosmall svelte-g2pdl9"), tr(x, "margin-bottom", "20px"), ti(P, "class", "infosmall textf1 svelte-g2pdl9"), tr(P, "margin-top", "30px"), ti(T, "class", "svgicon"), T.src !== (A = "/assets/ui/icons/pvp.svg?v=5699699") && ti(T, "src", A), ti(M, "class", "infobig textprimary svelte-g2pdl9"), tr(M, "margin-top", "10px"), ti(s, "class", "grid three"), ti(i, "class", " panel-black border grey"), ti(L, "width", "30%"), ti(B, "class", V = "textcenter " + (1 == t[0] ? "textwhite" : "")), ti(W, "class", j = "textcenter " + (2 == t[0] ? "textwhite" : "")), ti(X, "class", ts = "textcenter " + (0 == t[0] ? "textwhite" : "")), ti(tl, "class", "svgicon"), tl.src !== (to = rH) && ti(tl, "src", to), ti(ta, "class", td = "textcenter " + (3 == t[0] ? "textwhite" : "")), ti(O, "class", "textprimary"), ti(tu, "class", "svelte-g2pdl9"), ti(U, "class", "statboard panel-black svelte-g2pdl9"), ti(I, "class", "scrollbar"), ti(e, "class", "layout svelte-g2pdl9")
            },
            m(o, m) {
                Y(o, e, m), G(e, i), G(i, s), G(s, n), G(n, a), G(n, r), G(r, l), G(r, c), G(r, d), G(s, u), G(u, $), G($, h), G($, _), G($, f), G(u, p), G(p, g), G(p, v), G(v, y), G(u, x), G(x, w), G(x, k), G(k, C), G(u, S), G(s, E), G(E, P), G(E, M), G(M, T), G(M, R), G(M, F), tH(N, i, null), G(e, I), G(I, U), G(U, z), G(z, O), G(O, L), G(O, B), G(B, q), G(O, W), G(W, H), G(O, X), G(X, tt), G(O, ta), G(ta, tl), G(ta, tc), G(U, tu);
                for (let b = 0; b < ty.length; b += 1) ty[b].m(tu, null);
                t$ = !0, th || (tm = [te(B, "click", t[3]), te(W, "click", t[4]), te(X, "click", t[5]), te(ta, "click", t[6])], th = !0)
            },
            p(t, e) {
                (!t$ || 4 & e) && t_ !== (t_ = t[2].kills[0] + "") && tn(d, t_), (!t$ || 4 & e) && tf !== (tf = rX(t[2].reward) + "") && tn(f, tf), (!t$ || 4 & e) && tp !== (tp = ["Ended", "Ending Soon", "Active"][t[2].status] + "") && tn(y, tp), (!t$ || 4 & e && b !== (b = "text" + ["red", "orange", "green"][t[2].status] + " svelte-g2pdl9")) && ti(v, "class", b), (!t$ || 4 & e) && tg !== (tg = xL(t[2].duration) + "") && tn(C, tg), (!t$ || 4 & e) && tv !== (tv = t[2].kills[1] + "") && tn(F, tv);
                let i = {};
                if (4 & e && (i.fract = ~~(t[2].contrib / xB(t[2].level) * 100)), 4100 & e && (i.$$scope = {
                        dirty: e,
                        ctx: t
                    }), N.$set(i), (!t$ || 1 & e && V !== (V = "textcenter " + (1 == t[0] ? "textwhite" : ""))) && ti(B, "class", V), (!t$ || 1 & e && j !== (j = "textcenter " + (2 == t[0] ? "textwhite" : ""))) && ti(W, "class", j), (!t$ || 1 & e && ts !== (ts = "textcenter " + (0 == t[0] ? "textwhite" : ""))) && ti(X, "class", ts), (!t$ || 1 & e && td !== (td = "textcenter " + (3 == t[0] ? "textwhite" : ""))) && ti(ta, "class", td), 5 & e) {
                    let s = t[2].contributors.sort(t[7]);
                    tA(), ty = tL(ty, e, tx, 1, t, s, t0, tu, tO, xH, null, xq), t8()
                }
            },
            i(t) {
                if (!t$) {
                    tR(N.$$.fragment, t);
                    for (let e = 0; e < tb.length; e += 1) tR(ty[e]);
                    t$ = !0
                }
            },
            o(t) {
                tF(N.$$.fragment, t);
                for (let e = 0; e < ty.length; e += 1) tF(ty[e]);
                t$ = !1
            },
            d(t) {
                t && Q(e), tj(N);
                for (let i = 0; i < ty.length; i += 1) ty[i].d();
                th = !1, D(tm)
            }
        }
    }
    class xG extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a;
                N(e, e2, t => s(1, n = t)), N(e, ek, t => s(2, a = t));
                let r = 1,
                    l = () => s(0, r = 1),
                    o = () => s(0, r = 2),
                    c = () => s(0, r = 0),
                    d = () => s(0, r = 3),
                    u = () => {
                        L(e2, n = !1)
                    };
                return [r, n, a, l, o, c, d, (t, e) => e.stats[r] - t.stats[r], u]
            }, function t(e) {
                let i, s, n = e[1] && xV(e);
                return {
                    c() {
                        n && n.c(), i = tt()
                    },
                    m(t, e) {
                        n && n.m(t, e), Y(t, i, e), s = !0
                    },
                    p(t, [e]) {
                        t[1] ? n ? (n.p(t, e), 2 & e && tR(n, 1)) : ((n = xV(t)).c(), tR(n, 1), n.m(i.parentNode, i)) : n && (tA(), tF(n, 1, 1, () => {
                            n = null
                        }), t8())
                    },
                    i(t) {
                        s || (tR(n), s = !0)
                    },
                    o(t) {
                        tF(n), s = !1
                    },
                    d(t) {
                        n && n.d(t), t && Q(i)
                    }
                }
            }, A, {})
        }
    }

    function xY(t) {
        let e, i, s;
        return (i = new fg({
            props: {
                title: rC.ui.headers.pvp,
                icon: "pvp",
                $$slots: {
                    default: [xX]
                },
                $$scope: {
                    ctx: t
                }
            }
        })).$on("close", t[5]), {
            c() {
                e = J("div"), tW(i.$$.fragment), ti(e, "class", "l-upperLeftModal container uiscaled svelte-voya4q")
            },
            m(t, n) {
                Y(t, e, n), tH(i, e, null), s = !0
            },
            p(t, e) {
                let s = {};
                271 & e && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }), i.$set(s)
            },
            i(t) {
                s || (tR(i.$$.fragment, t), s = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), s = !1
            },
            d(t) {
                t && Q(e), tj(i)
            }
        }
    }

    function xQ(t) {
        let e, i = (t[0] > 0 ? ll(t[0], rC.ui.title.name[as.player.faction][t[0] - 1]) : "Unranked") + "";
        return {
            c() {
                ti(e = J("span"), "class", "absCentered ranktitle svelte-voya4q")
            },
            m(t, s) {
                Y(t, e, s), e.innerHTML = i
            },
            p(t, s) {
                1 & s && i !== (i = (t[0] > 0 ? ll(t[0], rC.ui.title.name[as.player.faction][t[0] - 1]) : "Unranked") + "") && (e.innerHTML = i)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function xX(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v, y, b, x, w, k, C, S, E, P, M, D, T, A, R, F, N, I, U, z, O, L, B, q, V, W, H, j, X, tt, te, ts, ta, tr, tl, to, tc, tu, t$, th, tm, t_, tf, tp, tg, tv, ty, t0, tb, tx, tw, t1, t9, t3, tk, t2, t4, tC, tS, t7, tE = rX(t[3].prestige) + "",
            t6 = ll(t[1], rC.ui.title.name[as.player.faction][t[1] - 1]) + "",
            tP = rX(b6(t[3].prestige)) + "",
            tM = rX(t[3].kills_today) + "",
            t5 = rX(t[3].fame_today) + "",
            tD = rX(t[3].kills_this_week) + "",
            tT = rX(t[3].fame) + "",
            tA = t[3].fame_position + "",
            t8 = bM(t[3].fame_bracket) + "",
            tN = rX(t[3].kills_last_week) + "",
            tI = rX(t[3].fame_last_week) + "",
            tU = t[3].fame_position_last_week + "",
            tz = bM(t[3].fame_bracket_last_week) + "",
            tO = rX(t[3].kills_lifetime) + "",
            tL = rX(t[3].fame_lifetime) + "",
            tB = (t[3].rank_lifetime > 0 ? ll(t[3].rank_lifetime, rC.ui.title.name[as.player.faction][t[3].rank_lifetime - 1]) : "Unranked") + "";
        return i = new fw({
            props: {
                size: "1.5em",
                fract: t[2],
                barcol: "bgpurp",
                $$slots: {
                    default: [xQ]
                },
                $$scope: {
                    ctx: t
                }
            }
        }), {
            c() {
                e = J("div"), tW(i.$$.fragment), s = J("div"), (n = J("span")).textContent = "Current Prestige", a = J("span"), r = J("img"), o = Z(), c = K(tE), (d = J("span")).textContent = "Next Rank", u = J("span"), h = K(" ("), m = K(tP), _ = K(")"), f = J("div"), (p = J("small")).textContent = "Today", g = J("span"), (v = J("span")).textContent = "Kills", y = J("span"), b = K(tM), (x = J("span")).textContent = "Fame", w = J("span"), k = J("img"), S = Z(), E = K(t5), P = J("div"), (M = J("small")).textContent = "This week", (D = J("a")).textContent = "View weekly brackets", (T = J("span")).textContent = "Kills", A = J("span"), R = K(tD), (F = J("span")).textContent = "Fame", N = J("span"), I = J("img"), z = Z(), O = K(tT), (L = J("span")).textContent = "Fame Position", B = J("span"), q = K(tA), (V = J("span")).textContent = "Fame Bracket", W = J("span"), H = K(t8), j = J("div"), (X = J("small")).textContent = "Last Week", tt = J("span"), (te = J("span")).textContent = "Kills", ts = J("span"), ta = K(tN), (tr = J("span")).textContent = "Fame", tl = J("span"), to = J("img"), tu = Z(), t$ = K(tI), (th = J("span")).textContent = "Fame Position", tm = J("span"), t_ = K(tU), (tf = J("span")).textContent = "Fame Bracket", tp = J("span"), tg = K(tz), tv = J("div"), (ty = J("small")).textContent = "Lifetime", t0 = J("span"), (tb = J("span")).textContent = "Kills", tx = J("span"), tw = K(tO), (t1 = J("span")).textContent = "Fame", t9 = J("span"), t3 = J("img"), t2 = Z(), t4 = K(tL), (tC = J("span")).textContent = "Highest Rank", tS = J("span"), ti(n, "class", "textwhite"), ti(r, "class", "svgicon"), r.src !== (l = rW) && ti(r, "src", l), ti(a, "class", "textprestige statnumber"), ti(d, "class", "textwhite"), $ = new td(h), ti(u, "class", "textprestige statnumber"), ti(s, "class", "stats marg-top svelte-voya4q"), ti(e, "class", "panel-black"), ti(p, "class", "bold textgreen"), ti(v, "class", "textwhite"), ti(y, "class", "textprimary statnumber"), ti(x, "class", "textwhite"), ti(k, "class", "svgicon"), k.src !== (C = rH) && ti(k, "src", C), ti(w, "class", "textfame statnumber"), ti(f, "class", "stats panel-black marg-top svelte-voya4q"), ti(M, "class", "bold textgreen"), ti(D, "class", "statnumber"), ti(D, "href", "/pvp"), ti(D, "target", "_blank"), ti(D, "rel", "noopener noreferrer"), ti(T, "class", "textwhite"), ti(A, "class", "textprimary statnumber"), ti(F, "class", "textwhite"), ti(I, "class", "svgicon"), I.src !== (U = rH) && ti(I, "src", U), ti(N, "class", "textfame statnumber"), ti(L, "class", "textwhite"), ti(B, "class", "textgreen statnumber"), ti(V, "class", "textwhite"), ti(W, "class", "textprimary statnumber"), ti(P, "class", "stats panel-black marg-top svelte-voya4q"), ti(X, "class", "bold textgreen"), ti(te, "class", "textwhite"), ti(ts, "class", "textprimary statnumber"), ti(tr, "class", "textwhite"), ti(to, "class", "svgicon"), to.src !== (tc = rH) && ti(to, "src", tc), ti(tl, "class", "textfame statnumber"), ti(th, "class", "textwhite"), ti(tm, "class", "textgreen statnumber"), ti(tf, "class", "textwhite"), ti(tp, "class", "textprimary statnumber"), ti(j, "class", "stats panel-black marg-top svelte-voya4q"), ti(ty, "class", "bold textgreen"), ti(tb, "class", "textwhite"), ti(tx, "class", "textprimary statnumber"), ti(t1, "class", "textwhite"), ti(t3, "class", "svgicon"), t3.src !== (tk = rH) && ti(t3, "src", tk), ti(t9, "class", "textfame statnumber"), ti(tC, "class", "textwhite"), ti(tS, "class", "textprestige statnumber"), ti(tv, "class", "stats panel-black marg-top svelte-voya4q")
            },
            m(t, l) {
                Y(t, e, l), tH(i, e, null), G(e, s), G(s, n), G(s, a), G(a, r), G(a, o), G(a, c), G(s, d), G(s, u), $.m(t6, u), G(u, h), G(u, m), G(u, _), Y(t, f, l), G(f, p), G(f, g), G(f, v), G(f, y), G(y, b), G(f, x), G(f, w), G(w, k), G(w, S), G(w, E), Y(t, P, l), G(P, M), G(P, D), G(P, T), G(P, A), G(A, R), G(P, F), G(P, N), G(N, I), G(N, z), G(N, O), G(P, L), G(P, B), G(B, q), G(P, V), G(P, W), G(W, H), Y(t, j, l), G(j, X), G(j, tt), G(j, te), G(j, ts), G(ts, ta), G(j, tr), G(j, tl), G(tl, to), G(tl, tu), G(tl, t$), G(j, th), G(j, tm), G(tm, t_), G(j, tf), G(j, tp), G(tp, tg), Y(t, tv, l), G(tv, ty), G(tv, t0), G(tv, tb), G(tv, tx), G(tx, tw), G(tv, t1), G(tv, t9), G(t9, t3), G(t9, t2), G(t9, t4), G(tv, tC), G(tv, tS), tS.innerHTML = tB, t7 = !0
            },
            p(t, e) {
                let s = {};
                4 & e && (s.fract = t[2]), 257 & e && (s.$$scope = {
                    dirty: e,
                    ctx: t
                }), i.$set(s), (!t7 || 8 & e) && tE !== (tE = rX(t[3].prestige) + "") && tn(c, tE), (!t7 || 2 & e) && t6 !== (t6 = ll(t[1], rC.ui.title.name[as.player.faction][t[1] - 1]) + "") && $.p(t6), (!t7 || 8 & e) && tP !== (tP = rX(b6(t[3].prestige)) + "") && tn(m, tP), (!t7 || 8 & e) && tM !== (tM = rX(t[3].kills_today) + "") && tn(b, tM), (!t7 || 8 & e) && t5 !== (t5 = rX(t[3].fame_today) + "") && tn(E, t5), (!t7 || 8 & e) && tD !== (tD = rX(t[3].kills_this_week) + "") && tn(R, tD), (!t7 || 8 & e) && tT !== (tT = rX(t[3].fame) + "") && tn(O, tT), (!t7 || 8 & e) && tA !== (tA = t[3].fame_position + "") && tn(q, tA), (!t7 || 8 & e) && t8 !== (t8 = bM(t[3].fame_bracket) + "") && tn(H, t8), (!t7 || 8 & e) && tN !== (tN = rX(t[3].kills_last_week) + "") && tn(ta, tN), (!t7 || 8 & e) && tI !== (tI = rX(t[3].fame_last_week) + "") && tn(t$, tI), (!t7 || 8 & e) && tU !== (tU = t[3].fame_position_last_week + "") && tn(t_, tU), (!t7 || 8 & e) && tz !== (tz = bM(t[3].fame_bracket_last_week) + "") && tn(tg, tz), (!t7 || 8 & e) && tO !== (tO = rX(t[3].kills_lifetime) + "") && tn(tw, tO), (!t7 || 8 & e) && tL !== (tL = rX(t[3].fame_lifetime) + "") && tn(t4, tL), (!t7 || 8 & e) && tB !== (tB = (t[3].rank_lifetime > 0 ? ll(t[3].rank_lifetime, rC.ui.title.name[as.player.faction][t[3].rank_lifetime - 1]) : "Unranked") + "") && (tS.innerHTML = tB)
            },
            i(t) {
                t7 || (tR(i.$$.fragment, t), t7 = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), t7 = !1
            },
            d(t) {
                t && Q(e), tj(i), t && Q(f), t && Q(P), t && Q(j), t && Q(tv)
            }
        }
    }
    class xJ extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n;
                N(e, i0, t => s(4, n = t));
                let a = 0,
                    r = 1,
                    l = 0,
                    o = {},
                    c = async () => {
                        s(3, o = await xs("/api/pvp/getplayerpvpinfo", {
                            name: as.player.name
                        })), s(0, a = b7(o.prestige)), s(1, r = Math.min(a + 1, 12));
                        let t = bE(r) - bE(a),
                            e = o.prestige - bE(a);
                        s(2, l = ~~(e / t * 100))
                    }, d = 0, u = () => {
                        L(i0, n = !1)
                    };
                return e.$$.update = () => {
                    80 & e.$$.dirty && (n && Date.now() - d > 3e4 || 0 === d) && (c(), s(6, d = Date.now()))
                }, [a, r, l, o, n, u]
            }, function t(e) {
                let i, s, n = e[4] && xY(e);
                return {
                    c() {
                        n && n.c(), i = tt()
                    },
                    m(t, e) {
                        n && n.m(t, e), Y(t, i, e), s = !0
                    },
                    p(t, [e]) {
                        t[4] ? n ? (n.p(t, e), 16 & e && tR(n, 1)) : ((n = xY(t)).c(), tR(n, 1), n.m(i.parentNode, i)) : n && (tA(), tF(n, 1, 1, () => {
                            n = null
                        }), t8())
                    },
                    i(t) {
                        s || (tR(n), s = !0)
                    },
                    o(t) {
                        tF(n), s = !1
                    },
                    d(t) {
                        n && n.d(t), t && Q(i)
                    }
                }
            }, A, {})
        }
    }

    function xK(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h = t[0].name + "",
            m = void 0 !== t[0].level ? `Lv. ${t[0].level} ` : "",
            _ = (void 0 !== t[0].class ? rC.classes[t[0].class].name : "Item") + "",
            f = (void 0 !== t[0].faction ? rC.factions[t[0].faction].name : "") + "";
        return {
            c() {
                e = J("div"), i = J("div"), s = K(h), n = J("div"), a = J("span"), r = K(m), l = J("span"), o = K(_), d = J("span"), u = K(f), ti(i, "class", "textwhite title svelte-1wip79f"), ti(l, "class", c = O(void 0 !== t[0].class ? "textc" + t[0].class : "textyellow") + " svelte-1wip79f"), ti(d, "class", $ = O(void 0 !== t[0].faction ? "textf" + t[0].faction : "") + " svelte-1wip79f"), ti(e, "class", "panel-black container svelte-1wip79f"), tr(e, "display", t[1] ? "block" : "none")
            },
            m(t, c) {
                Y(t, e, c), G(e, i), G(i, s), G(e, n), G(n, a), G(a, r), G(n, l), G(l, o), G(e, d), G(d, u)
            },
            p(t, i) {
                1 & i && h !== (h = t[0].name + "") && tn(s, h), 1 & i && m !== (m = void 0 !== t[0].level ? `Lv. ${t[0].level} ` : "") && tn(r, m), 1 & i && _ !== (_ = (void 0 !== t[0].class ? rC.classes[t[0].class].name : "Item") + "") && tn(o, _), 1 & i && c !== (c = O(void 0 !== t[0].class ? "textc" + t[0].class : "textyellow") + " svelte-1wip79f") && ti(l, "class", c), 1 & i && f !== (f = (void 0 !== t[0].faction ? rC.factions[t[0].faction].name : "") + "") && tn(u, f), 1 & i && $ !== ($ = O(void 0 !== t[0].faction ? "textf" + t[0].faction : "") + " svelte-1wip79f") && ti(d, "class", $), 2 & i && tr(e, "display", t[1] ? "block" : "none")
            },
            d(t) {
                t && Q(e)
            }
        }
    }
    class xZ extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a;
                return N(e, e1, t => s(1, n = t)), e.$$.update = () => {
                    2 & e.$$.dirty && n > 0 && as.isEntityIdTaken(n) && s(0, a = as.entity(n))
                }, [a, n]
            }, function t(e) {
                let i, s = e[0] && xK(e);
                return {
                    c() {
                        s && s.c(), i = tt()
                    },
                    m(t, e) {
                        s && s.m(t, e), Y(t, i, e)
                    },
                    p(t, [e]) {
                        t[0] ? s ? s.p(t, e) : ((s = xK(t)).c(), s.m(i.parentNode, i)) : s && (s.d(1), s = null)
                    },
                    i: C,
                    o: C,
                    d(t) {
                        s && s.d(t), t && Q(i)
                    }
                }
            }, A, {})
        }
    }
    let wt = eO,
        we = async t => {
            let e = await xs("/api/account/info");
            wt.set(e), ep.set(e.storepoints), t && t(e)
        };
    class wi extends tY {
        constructor(t) {
            super(), tG(this, t, null, function t(e) {
                let i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v, y, b, x, w, k, S, E, P, M, D, T, A, R, F, N, I, U, z, O, L, B, q, V, W, H, j, X, tt, te, ts, tn, ta, tr, tl = rC.ui.elixir.chatsupport + "",
                    to = rC.ui.elixir.noads + "",
                    tc = rC.ui.elixir.bagslots + "",
                    td = rC.ui.elixir.stashstorage + "",
                    tu = rC.ui.elixir.merchantlimit + "",
                    t$ = rC.ui.elixir.merchantduration + "";
                return {
                    c() {
                        i = J("div"), (s = J("div")).innerHTML = '<img class="artwork svelte-cbx1m" src="/assets/ui/elixir.svg?v=5699699"><div class="sparkle svelte-cbx1m" style="font-size:35px; left:30%; top:30%; animation-delay: -1s;">+</div><div class="sparkle svelte-cbx1m" style="font-size:50px; left:40%; top:60%; animation-delay: -2s;">+</div><div class="sparkle svelte-cbx1m" style="font-size:80px; left:60%; top:20%; animation-delay: -3s;">+</div>', n = J("div"), (a = J("h1")).innerHTML = 'Hordes <span class="textsub">Elixir</span>', r = J("div"), l = J("img"), c = Z(), d = K(tl), u = J("div"), $ = J("img"), m = Z(), _ = K(to), f = J("div"), p = J("img"), v = Z(), (y = J("span")).textContent = "" + yH[0].inventory, b = Z(), (x = J("span")).textContent = "" + yH[1].inventory, w = Z(), k = K(tc), S = J("div"), E = J("img"), M = Z(), (D = J("span")).textContent = "" + yH[0].stash, T = Z(), (A = J("span")).textContent = "" + yH[1].stash, R = Z(), F = K(td), N = J("div"), I = J("img"), z = Z(), (O = J("span")).textContent = "" + yH[0].auction, L = Z(), (B = J("span")).textContent = "" + yH[1].auction, q = Z(), V = K(tu), W = J("div"), H = J("img"), X = Z(), (tt = J("span")).textContent = yH[0].auctionHours + "h", te = Z(), (ts = J("span")).textContent = yH[1].auctionHours + "h", tn = Z(), ta = K(t$), (tr = J("div")).textContent = "" + rC.ui.elixir.tba, ti(s, "class", "artcontainer svelte-cbx1m"), ti(a, "class", "textprimary"), ti(l, "class", "svgicon"), l.src !== (o = "/assets/ui/icons/gem.svg?v=5699699") && ti(l, "src", o), ti(r, "class", "textwhite"), ti($, "class", "svgicon"), $.src !== (h = "/assets/ui/icons/check.svg?v=5699699") && ti($, "src", h), ti(u, "class", "textwhite"), ti(p, "class", "svgicon"), p.src !== (g = "/assets/ui/icons/check.svg?v=5699699") && ti(p, "src", g), ti(y, "class", "old svelte-cbx1m"), ti(x, "class", "textsub"), ti(f, "class", "textwhite"), ti(E, "class", "svgicon"), E.src !== (P = "/assets/ui/icons/check.svg?v=5699699") && ti(E, "src", P), ti(D, "class", "old svelte-cbx1m"), ti(A, "class", "textsub"), ti(S, "class", "textwhite"), ti(I, "class", "svgicon"), I.src !== (U = "/assets/ui/icons/check.svg?v=5699699") && ti(I, "src", U), ti(O, "class", "old svelte-cbx1m"), ti(B, "class", "textsub"), ti(N, "class", "textwhite"), ti(H, "class", "svgicon"), H.src !== (j = "/assets/ui/icons/check.svg?v=5699699") && ti(H, "src", j), ti(tt, "class", "old svelte-cbx1m"), ti(ts, "class", "textsub"), ti(W, "class", "textwhite"), ti(tr, "class", "textgrey"), ti(i, "class", "split svelte-cbx1m")
                    },
                    m(t, e) {
                        Y(t, i, e), G(i, s), G(i, n), G(n, a), G(n, r), G(r, l), G(r, c), G(r, d), G(n, u), G(u, $), G(u, m), G(u, _), G(n, f), G(f, p), G(f, v), G(f, y), G(f, b), G(f, x), G(f, w), G(f, k), G(n, S), G(S, E), G(S, M), G(S, D), G(S, T), G(S, A), G(S, R), G(S, F), G(n, N), G(N, I), G(N, z), G(N, O), G(N, L), G(N, B), G(N, q), G(N, V), G(n, W), G(W, H), G(W, X), G(W, tt), G(W, te), G(W, ts), G(W, tn), G(W, ta), G(n, tr)
                    },
                    p: C,
                    i: C,
                    o: C,
                    d(t) {
                        t && Q(i)
                    }
                }
            }, A, {})
        }
    }
    let ws = {
            SECONDS_A_MINUTE: 60,
            SECONDS_A_HOUR: 3600,
            SECONDS_A_DAY: 86400,
            SECONDS_A_WEEK: 604800,
            MILLISECONDS_A_SECOND: 1e3,
            MILLISECONDS_A_MINUTE: 6e4,
            MILLISECONDS_A_HOUR: 36e5,
            MILLISECONDS_A_DAY: 864e5,
            MILLISECONDS_A_WEEK: 6048e5,
            MS: "millisecond",
            S: "second",
            MIN: "minute",
            H: "hour",
            D: "day",
            W: "week",
            M: "month",
            Q: "quarter",
            Y: "year",
            DATE: "date",
            FORMAT_DEFAULT: "YYYY-MM-DDTHH:mm:ssZ",
            INVALID_DATE_STRING: "Invalid Date",
            REGEX_PARSE: /^(\d{4})-?(\d{1,2})-?(\d{0,2})[^0-9]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?.?(\d{1,3})?$/,
            REGEX_FORMAT: /\[([^\]]+)]|Y{2,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g
        },
        wn = (t, e, i) => {
            let s = String(t);
            return !s || s.length >= e ? t : `${Array(e+1-s.length).join(i)}${t}`
        },
        wa = t => {
            let e = -t.utcOffset(),
                i = Math.abs(e);
            return `${e<=0?"+":"-"}${wn(Math.floor(i/60),2,"0")}:${wn(i%60,2,"0")}`
        },
        wr = {
            name: "en",
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_")
        },
        wl = "en",
        wo = {};
    wo[wl] = wr;
    let wc = t => t instanceof w_,
        wd = (t, e, i) => {
            let s;
            if (!t) return wl;
            if ("string" == typeof t) wo[t] && (s = t), e && (wo[t] = e, s = t);
            else {
                let {
                    name: n
                } = t;
                wo[n] = t, s = n
            }
            return i || (wl = s), s
        },
        wu = (t, e, i) => {
            if (wc(t)) return t.clone();
            let s = e ? "string" == typeof e ? {
                format: e,
                pl: i
            } : e : {};
            return s.date = t, new w_(s)
        },
        w$ = (t, e) => wu(t, {
            locale: e.$L,
            utc: e.$u,
            $offset: e.$offset
        }),
        wh = {
            s: wn,
            z: wa,
            m(t, e) {
                let i = 12 * (e.year() - t.year()) + (e.month() - t.month()),
                    s = t.clone().add(i, ws.M),
                    n = e - s < 0,
                    a = t.clone().add(i + (n ? -1 : 1), ws.M);
                return Number(-(i + (e - s) / (n ? s - a : a - s)) || 0)
            },
            a: t => t < 0 ? Math.ceil(t) || 0 : Math.floor(t),
            p: t => ({
                M: ws.M,
                y: ws.Y,
                w: ws.W,
                d: ws.D,
                h: ws.H,
                m: ws.MIN,
                s: ws.S,
                ms: ws.MS,
                Q: ws.Q
            })[t] || String(t || "").toLowerCase().replace(/s$/, ""),
            u: t => void 0 === t
        };
    wh.l = wd, wh.i = wc, wh.w = w$;
    let wm = t => {
        let {
            date: e,
            utc: i
        } = t;
        if (null === e) return new Date(NaN);
        if (wh.u(e)) return new Date;
        if (e instanceof Date) return new Date(e);
        if ("string" == typeof e && !/Z$/i.test(e)) {
            let s = e.match(ws.REGEX_PARSE);
            if (s) return i ? new Date(Date.UTC(s[1], s[2] - 1, s[3] || 1, s[4] || 0, s[5] || 0, s[6] || 0, s[7] || 0)) : new Date(s[1], s[2] - 1, s[3] || 1, s[4] || 0, s[5] || 0, s[6] || 0, s[7] || 0)
        }
        return new Date(e)
    };
    class w_ {
        constructor(t) {
            this.$L = this.$L || wd(t.locale, null, !0), this.parse(t)
        }
        parse(t) {
            this.$d = wm(t), this.init()
        }
        init() {
            let {
                $d: t
            } = this;
            this.$y = t.getFullYear(), this.$M = t.getMonth(), this.$D = t.getDate(), this.$W = t.getDay(), this.$H = t.getHours(), this.$m = t.getMinutes(), this.$s = t.getSeconds(), this.$ms = t.getMilliseconds()
        }
        $utils() {
            return wh
        }
        isValid() {
            return this.$d.toString() !== ws.INVALID_DATE_STRING
        }
        isSame(t, e) {
            let i = wu(t);
            return this.startOf(e) <= i && i <= this.endOf(e)
        }
        isAfter(t, e) {
            return wu(t) < this.startOf(e)
        }
        isBefore(t, e) {
            return this.endOf(e) < wu(t)
        }
        $g(t, e, i) {
            return wh.u(t) ? this[e] : this.set(i, t)
        }
        year(t) {
            return this.$g(t, "$y", ws.Y)
        }
        month(t) {
            return this.$g(t, "$M", ws.M)
        }
        day(t) {
            return this.$g(t, "$W", ws.D)
        }
        date(t) {
            return this.$g(t, "$D", ws.DATE)
        }
        hour(t) {
            return this.$g(t, "$H", ws.H)
        }
        minute(t) {
            return this.$g(t, "$m", ws.MIN)
        }
        second(t) {
            return this.$g(t, "$s", ws.S)
        }
        millisecond(t) {
            return this.$g(t, "$ms", ws.MS)
        }
        unix() {
            return Math.floor(this.valueOf() / 1e3)
        }
        valueOf() {
            return this.$d.getTime()
        }
        startOf(t, e) {
            let i = !!wh.u(e) || e,
                s = wh.p(t),
                n = (t, e) => {
                    let s = wh.w(this.$u ? Date.UTC(this.$y, e, t) : new Date(this.$y, e, t), this);
                    return i ? s : s.endOf(ws.D)
                },
                a = (t, e) => wh.w(this.toDate()[t].apply(this.toDate(), (i ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e)), this),
                {
                    $W: r,
                    $M: l,
                    $D: o
                } = this,
                c = "set" + (this.$u ? "UTC" : "");
            switch (s) {
                case ws.Y:
                    return i ? n(1, 0) : n(31, 11);
                case ws.M:
                    return i ? n(1, l) : n(0, l + 1);
                case ws.W: {
                    let d = this.$locale().weekStart || 0,
                        u = (r < d ? r + 7 : r) - d;
                    return n(i ? o - u : o + (6 - u), l)
                }
                case ws.D:
                case ws.DATE:
                    return a(c + "Hours", 0);
                case ws.H:
                    return a(c + "Minutes", 1);
                case ws.MIN:
                    return a(c + "Seconds", 2);
                case ws.S:
                    return a(c + "Milliseconds", 3);
                default:
                    return this.clone()
            }
        }
        endOf(t) {
            return this.startOf(t, !1)
        }
        $set(t, e) {
            let i = wh.p(t),
                s = "set" + (this.$u ? "UTC" : ""),
                n = {
                    [ws.D]: s + "Date",
                    [ws.DATE]: s + "Date",
                    [ws.M]: s + "Month",
                    [ws.Y]: s + "FullYear",
                    [ws.H]: s + "Hours",
                    [ws.MIN]: s + "Minutes",
                    [ws.S]: s + "Seconds",
                    [ws.MS]: s + "Milliseconds"
                } [i],
                a = i === ws.D ? this.$D + (e - this.$W) : e;
            if (i === ws.M || i === ws.Y) {
                let r = this.clone().set(ws.DATE, 1);
                r.$d[n](a), r.init(), this.$d = r.set(ws.DATE, Math.min(this.$D, r.daysInMonth())).toDate()
            } else n && this.$d[n](a);
            return this.init(), this
        }
        set(t, e) {
            return this.clone().$set(t, e)
        }
        get(t) {
            return this[wh.p(t)]()
        }
        add(t, e) {
            t = Number(t);
            let i = wh.p(e),
                s = e => {
                    let i = wu(this);
                    return wh.w(i.date(i.date() + Math.round(e * t)), this)
                };
            if (i === ws.M) return this.set(ws.M, this.$M + t);
            if (i === ws.Y) return this.set(ws.Y, this.$y + t);
            if (i === ws.D) return s(1);
            if (i === ws.W) return s(7);
            let n = {
                    [ws.MIN]: ws.MILLISECONDS_A_MINUTE,
                    [ws.H]: ws.MILLISECONDS_A_HOUR,
                    [ws.S]: ws.MILLISECONDS_A_SECOND
                } [i] || 1,
                a = this.$d.getTime() + t * n;
            return wh.w(a, this)
        }
        subtract(t, e) {
            return this.add(-1 * t, e)
        }
        format(t) {
            if (!this.isValid()) return ws.INVALID_DATE_STRING;
            let e = t || ws.FORMAT_DEFAULT,
                i = wh.z(this),
                s = this.$locale(),
                {
                    $H: n,
                    $m: a,
                    $M: r
                } = this,
                {
                    weekdays: l,
                    months: o,
                    meridiem: c
                } = s,
                d = (t, i, s, n) => t && (t[i] || t(this, e)) || s[i].substr(0, n),
                u = t => wh.s(n % 12 || 12, t, "0"),
                $ = c || ((t, e, i) => {
                    let s = t < 12 ? "AM" : "PM";
                    return i ? s.toLowerCase() : s
                }),
                h = {
                    YY: String(this.$y).slice(-2),
                    YYYY: this.$y,
                    M: r + 1,
                    MM: wh.s(r + 1, 2, "0"),
                    MMM: d(s.monthsShort, r, o, 3),
                    MMMM: o[r] || o(this, e),
                    D: this.$D,
                    DD: wh.s(this.$D, 2, "0"),
                    d: String(this.$W),
                    dd: d(s.weekdaysMin, this.$W, l, 2),
                    ddd: d(s.weekdaysShort, this.$W, l, 3),
                    dddd: l[this.$W],
                    H: String(n),
                    HH: wh.s(n, 2, "0"),
                    h: u(1),
                    hh: u(2),
                    a: $(n, a, !0),
                    A: $(n, a, !1),
                    m: String(a),
                    mm: wh.s(a, 2, "0"),
                    s: String(this.$s),
                    ss: wh.s(this.$s, 2, "0"),
                    SSS: wh.s(this.$ms, 3, "0"),
                    Z: i
                };
            return e.replace(ws.REGEX_FORMAT, (t, e) => e || h[t] || i.replace(":", ""))
        }
        utcOffset() {
            return -(15 * Math.round(this.$d.getTimezoneOffset() / 15))
        }
        diff(t, e, i) {
            let s = wh.p(e),
                n = wu(t),
                a = (n.utcOffset() - this.utcOffset()) * ws.MILLISECONDS_A_MINUTE,
                r = this - n,
                l = wh.m(this, n);
            return l = ({
                [ws.Y]: l / 12,
                [ws.M]: l,
                [ws.Q]: l / 3,
                [ws.W]: (r - a) / ws.MILLISECONDS_A_WEEK,
                [ws.D]: (r - a) / ws.MILLISECONDS_A_DAY,
                [ws.H]: r / ws.MILLISECONDS_A_HOUR,
                [ws.MIN]: r / ws.MILLISECONDS_A_MINUTE,
                [ws.S]: r / ws.MILLISECONDS_A_SECOND
            })[s] || r, i ? l : wh.a(l)
        }
        daysInMonth() {
            return this.endOf(ws.M).$D
        }
        $locale() {
            return wo[this.$L]
        }
        locale(t, e) {
            if (!t) return this.$L;
            let i = this.clone();
            return i.$L = wd(t, e, !0), i
        }
        clone() {
            return wh.w(this.$d, this)
        }
        toDate() {
            return new Date(this.valueOf())
        }
        toJSON() {
            return this.isValid() ? this.toISOString() : null
        }
        toISOString() {
            return this.$d.toISOString()
        }
        toString() {
            return this.$d.toUTCString()
        }
    }

    function wf(t, e, i) {
        let s = t.slice();
        return s[13] = e[i], s[15] = i, s
    }

    function wp(t) {
        let e, i = rC.ui.elixir.notactive + "";
        return {
            c() {
                e = K(i)
            },
            m(t, i) {
                Y(t, e, i)
            },
            p: C,
            d(t) {
                t && Q(e)
            }
        }
    }

    function wg(t) {
        let e, i, s, n, a = wu(t[1].subscribed_until).format("MMM DD, YYYY HH:mm") + "";
        return {
            c() {
                e = J("img"), s = Z(), n = K(a), ti(e, "class", "svgicon"), e.src !== (i = "/assets/ui/icons/check.svg?v=5699699") && ti(e, "src", i)
            },
            m(t, i) {
                Y(t, e, i), Y(t, s, i), Y(t, n, i)
            },
            p(t, e) {
                2 & e && a !== (a = wu(t[1].subscribed_until).format("MMM DD, YYYY HH:mm") + "") && tn(n, a)
            },
            d(t) {
                t && Q(e), t && Q(s), t && Q(n)
            }
        }
    }

    function wv(t) {
        let e, i, s, n, a, r, l, o, c = t[13].name + "";

        function d(...e) {
            return t[9](t[15], ...e)
        }
        return n = new gD({
            props: {
                amount: t[13].price
            }
        }), {
            c() {
                e = J("btn"), i = K(c), s = Z(), tW(n.$$.fragment), ti(e, "class", a = "btn black navbtn " + (t[5] == t[15] ? "active" : "") + " big")
            },
            m(t, a) {
                Y(t, e, a), G(e, i), G(e, s), tH(n, e, null), r = !0, l || (o = te(e, "click", d), l = !0)
            },
            p(i, s) {
                t = i, (!r || 32 & s && a !== (a = "btn black navbtn " + (t[5] == t[15] ? "active" : "") + " big")) && ti(e, "class", a)
            },
            i(t) {
                r || (tR(n.$$.fragment, t), r = !0)
            },
            o(t) {
                tF(n.$$.fragment, t), r = !1
            },
            d(t) {
                t && Q(e), tj(n), l = !1, o()
            }
        }
    }

    function wy(t) {
        let e, i;
        return {
            c() {
                e = J("div"), (i = J("p")).textContent = "" + rC.ui.elixir.thankyou, ti(i, "class", "fadeIn textsub"), ti(e, "class", "fadeIn card marg-top")
            },
            m(t, s) {
                Y(t, e, s), G(e, i)
            },
            p: C,
            i: C,
            o: C,
            d(t) {
                t && Q(e)
            }
        }
    }

    function w0(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v, y, b, x, w = (t[6] ? rC.ui.elixir.willgift : rC.ui.elixir.willadd) + "",
            k = rC.ui.elixir.subduration[t[5]] + "",
            C = rC.ui.elixir.willcost + "",
            S = (t[6] ? rC.ui.elixir.send : t[1].subscribed_until ? rC.ui.elixir.extend : rC.ui.activate) + "";
        u = new gD({
            props: {
                amount: t[8].price
            }
        });
        let E = [wx, wb],
            P = [];

        function M(t, e) {
            return t[6] ? 1 : 0
        }
        m = P[h = M(t)] = E[h](t);
        let D = "addsubscription" == t[0] && t[2] && ww(t),
            T = t[1].storepoints < t[8].price && w1();
        return {
            c() {
                e = J("div"), i = J("div"), s = K(w), n = Z(), a = J("span"), r = K(k), l = Z(), (o = J("span")).textContent = "" + rC.ui.elixir.subscription, c = K("? "), d = K(C), tW(u.$$.fragment), $ = K("."), m.c(), _ = tt(), D && D.c(), f = J("div"), p = J("div"), g = K(S), T && T.c(), ti(a, "class", "bold textwhite"), ti(o, "class", "textsub"), ti(i, "class", "textgrey"), ti(p, "class", v = "btn grey formatted " + ("addsubscription" == t[3] || t[1].storepoints < t[8].price ? "disabled" : "")), ti(f, "class", "subnav"), ti(e, "class", "fadeIn card marg-top"), tr(e, "padding", "18px")
            },
            m(m, v) {
                Y(m, e, v), G(e, i), G(i, s), G(i, n), G(i, a), G(a, r), G(i, l), G(i, o), G(i, c), G(i, d), tH(u, i, null), G(i, $), P[h].m(e, null), G(e, _), D && D.m(e, null), G(e, f), G(f, p), G(p, g), T && T.m(e, null), y = !0, b || (x = te(p, "click", t[12]), b = !0)
            },
            p(t, i) {
                (!y || 64 & i) && w !== (w = (t[6] ? rC.ui.elixir.willgift : rC.ui.elixir.willadd) + "") && tn(s, w), (!y || 32 & i) && k !== (k = rC.ui.elixir.subduration[t[5]] + "") && tn(r, k);
                let n = {};
                256 & i && (n.amount = t[8].price), u.$set(n);
                let a = h;
                (h = M(t)) === a ? P[h].p(t, i) : (tA(), tF(P[a], 1, 1, () => {
                    P[a] = null
                }), t8(), (m = P[h]) || (m = P[h] = E[h](t)).c(), tR(m, 1), m.m(e, _)), "addsubscription" == t[0] && t[2] ? D ? D.p(t, i) : ((D = ww(t)).c(), D.m(e, f)) : D && (D.d(1), D = null), (!y || 66 & i) && S !== (S = (t[6] ? rC.ui.elixir.send : t[1].subscribed_until ? rC.ui.elixir.extend : rC.ui.activate) + "") && tn(g, S), (!y || 266 & i && v !== (v = "btn grey formatted " + ("addsubscription" == t[3] || t[1].storepoints < t[8].price ? "disabled" : ""))) && ti(p, "class", v), t[1].storepoints < t[8].price ? T ? T.p(t, i) : ((T = w1()).c(), T.m(e, null)) : T && (T.d(1), T = null)
            },
            i(t) {
                y || (tR(u.$$.fragment, t), tR(m), y = !0)
            },
            o(t) {
                tF(u.$$.fragment, t), tF(m), y = !1
            },
            d(t) {
                t && Q(e), tj(u), P[h].d(), D && D.d(), T && T.d(), b = !1, x()
            }
        }
    }

    function wb(t) {
        let e, i, s, n;

        function a(e) {
            t[11].call(null, e)
        }
        let r = {};
        return void 0 !== t[7] && (r.name = t[7]), i = new xv({
            props: r
        }), tw.push(() => tV(i, "name", a)), {
            c() {
                e = J("div"), tW(i.$$.fragment), ti(e, "class", "subnav")
            },
            m(t, s) {
                Y(t, e, s), tH(i, e, null), n = !0
            },
            p(t, e) {
                let n = {};
                !s && 128 & e && (s = !0, n.name = t[7], tC(() => s = !1)), i.$set(n)
            },
            i(t) {
                n || (tR(i.$$.fragment, t), n = !0)
            },
            o(t) {
                tF(i.$$.fragment, t), n = !1
            },
            d(t) {
                t && Q(e), tj(i)
            }
        }
    }

    function wx(t) {
        let e, i, s, n, a, r, l = rC.ui.elixir.enable + "",
            o = wu(t[1].subscribed_until || void 0).add(t[8].days, "day").format("MMM DD, YYYY HH:mm") + "";
        return {
            c() {
                e = J("p"), i = K(l), s = Z(), n = J("span"), a = K(o), r = K("."), ti(n, "class", "textwhite"), ti(e, "class", "bold textsub")
            },
            m(t, l) {
                Y(t, e, l), G(e, i), G(e, s), G(e, n), G(n, a), G(e, r)
            },
            p(t, e) {
                258 & e && o !== (o = wu(t[1].subscribed_until || void 0).add(t[8].days, "day").format("MMM DD, YYYY HH:mm") + "") && tn(a, o)
            },
            i: C,
            o: C,
            d(t) {
                t && Q(e)
            }
        }
    }

    function ww(t) {
        let e, i;
        return {
            c() {
                e = J("p"), i = K(t[2]), ti(e, "class", "fadeIn textred")
            },
            m(t, s) {
                Y(t, e, s), G(e, i)
            },
            p(t, e) {
                4 & e && tn(i, t[2])
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function w1(t) {
        let e, i, s, n, a, r = rC.ui.elixir.pointserror + "";
        return {
            c() {
                e = J("p"), i = J("small"), s = K(r), n = Z(), (a = J("a")).textContent = `${rC.ui.elixir.buypoints}  ${rC.ui.elixir.currency}`, ti(a, "class", "textprimary"), ti(a, "href", "/store")
            },
            m(t, r) {
                Y(t, e, r), G(e, i), G(i, s), G(i, n), G(i, a)
            },
            p: C,
            d(t) {
                t && Q(e)
            }
        }
    }
    wu.prototype = w_.prototype, wu.extend = (t, e) => (t(e, w_, wu), wu), wu.locale = wd, wu.isDayjs = wc, wu.unix = t => wu(1e3 * t), wu.en = wo[wl], wu.Ls = wo;
    class w9 extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a, r = !1,
                    {
                        user: l
                    } = i,
                    {
                        flash: o
                    } = i,
                    {
                        flashmsg: c
                    } = i,
                    {
                        action: d
                    } = i,
                    {
                        apiCall: u
                    } = i,
                    $ = (t, e) => s(5, n = t),
                    h = t => s(6, r = !r),
                    m = t => u("addsubscription", "/api/account/addsubscription", {
                        value: n,
                        gift: r ? a : void 0
                    }, !0, t => {
                        "ok" == t.result && (s(5, n = void 0), s(0, o = "addsubscription"))
                    }),
                    _;
                return e.$$set = t => {
                    "user" in t && s(1, l = t.user), "flash" in t && s(0, o = t.flash), "flashmsg" in t && s(2, c = t.flashmsg), "action" in t && s(3, d = t.action), "apiCall" in t && s(4, u = t.apiCall)
                }, e.$$.update = () => {
                    32 & e.$$.dirty && s(8, _ = yW[n])
                }, [o, l, c, d, u, n, r, a, _, $, h, function t(e) {
                    s(7, a = e)
                }, m]
            }, function t(e) {
                let i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v, y, b, x = rC.ui.elixir.sendgift + "";

                function w(t, e) {
                    return t[1].subscribed_until ? wg : wp
                }
                s = new wi({});
                let k = w(e),
                    C = k(e);
                c = new gD({
                    props: {
                        amount: e[1].storepoints
                    }
                });
                let S = yW,
                    E = [];
                for (let P = 0; P < S.length; P += 1) E[P] = wv(wf(e, S, P));
                let M = t => tF(E[t], 1, 1, () => {
                        E[t] = null
                    }),
                    D = [w0, wy],
                    T = [];

                function A(t, e) {
                    return void 0 !== t[5] ? 0 : "addsubscription" == t[0] ? 1 : -1
                }
                return ~(p = A(e)) && (g = T[p] = D[p](e)), {
                    c() {
                        i = J("div"), tW(s.$$.fragment), (n = J("small")).textContent = "" + rC.ui.elixir.subscription, a = J("div"), C.c(), (l = J("small")).textContent = "" + rC.ui.elixir.currency, o = J("div"), tW(c.$$.fragment), d = Z(), (u = J("a")).textContent = `${rC.ui.elixir.buypoints}  ${rC.ui.elixir.currency}`, ($ = J("p")).textContent = "" + rC.ui.elixir.support, h = J("div");
                        for (let t = 0; t < E.length; t += 1) E[t].c();
                        m = J("btn"), _ = K(x), g && g.c(), ti(n, "class", "textgrey"), ti(a, "class", r = "cardinfo " + (e[1].subscribed_until ? "textsub" : "textgrey")), ti(l, "class", "textgrey"), ti(u, "class", "textwhite"), ti(u, "href", "/store"), ti(o, "class", "cardinfo"), ti($, "class", "textgrey"), ti(m, "class", f = "btn navbtn " + (e[6] ? "active white" : "") + " big"), ti(h, "class", "subnav"), ti(i, "class", "card")
                    },
                    m(t, r) {
                        Y(t, i, r), tH(s, i, null), G(i, n), G(i, a), C.m(a, null), G(i, l), G(i, o), tH(c, o, null), G(o, d), G(o, u), G(i, $), G(i, h);
                        for (let f = 0; f < E.length; f += 1) E[f].m(h, null);
                        G(h, m), G(m, _), ~p && T[p].m(i, null), v = !0, y || (b = te(m, "click", e[10]), y = !0)
                    },
                    p(t, [e]) {
                        k === (k = w(t)) && C ? C.p(t, e) : (C.d(1), (C = k(t)) && (C.c(), C.m(a, null))), (!v || 2 & e && r !== (r = "cardinfo " + (t[1].subscribed_until ? "textsub" : "textgrey"))) && ti(a, "class", r);
                        let s = {};
                        if (2 & e && (s.amount = t[1].storepoints), c.$set(s), 32 & e) {
                            let n;
                            for (S = yW, n = 0; n < S.length; n += 1) {
                                let l = wf(t, S, n);
                                E[n] ? (E[n].p(l, e), tR(E[n], 1)) : (E[n] = wv(l), E[n].c(), tR(E[n], 1), E[n].m(h, m))
                            }
                            for (tA(), n = S.length; n < E.length; n += 1) M(n);
                            t8()
                        }(!v || 64 & e && f !== (f = "btn navbtn " + (t[6] ? "active white" : "") + " big")) && ti(m, "class", f);
                        let o = p;
                        (p = A(t)) === o ? ~p && T[p].p(t, e) : (g && (tA(), tF(T[o], 1, 1, () => {
                            T[o] = null
                        }), t8()), ~p ? ((g = T[p]) || (g = T[p] = D[p](t)).c(), tR(g, 1), g.m(i, null)) : g = null)
                    },
                    i(t) {
                        if (!v) {
                            tR(s.$$.fragment, t), tR(c.$$.fragment, t);
                            for (let e = 0; e < S.length; e += 1) tR(E[e]);
                            tR(g), v = !0
                        }
                    },
                    o(t) {
                        tF(s.$$.fragment, t), tF(c.$$.fragment, t), E = E.filter(Boolean);
                        for (let e = 0; e < E.length; e += 1) tF(E[e]);
                        tF(g), v = !1
                    },
                    d(t) {
                        t && Q(i), tj(s), C.d(), tj(c), X(E, t), ~p && T[p].d(), y = !1, b()
                    }
                }
            }, A, {
                user: 1,
                flash: 0,
                flashmsg: 2,
                action: 3,
                apiCall: 4
            })
        }
    }

    function w3(t) {
        let e, i, s, n;
        return (s = new fg({
            props: {
                title: "Store / Elixir",
                icon: "gem",
                $$slots: {
                    default: [w2]
                },
                $$scope: {
                    ctx: t
                }
            }
        })).$on("close", t[6]), {
            c() {
                e = J("div"), i = J("div"), tW(s.$$.fragment), ti(i, "class", "uiscaled"), ti(e, "class", "absCentered container svelte-1un8upk")
            },
            m(t, a) {
                Y(t, e, a), G(e, i), tH(s, i, null), n = !0
            },
            p(t, e) {
                let i = {};
                302 & e && (i.$$scope = {
                    dirty: e,
                    ctx: t
                }), s.$set(i)
            },
            i(t) {
                n || (tR(s.$$.fragment, t), n = !0)
            },
            o(t) {
                tF(s.$$.fragment, t), n = !1
            },
            d(t) {
                t && Q(e), tj(s)
            }
        }
    }

    function wk(t) {
        let e, i;
        return e = new w9({
            props: {
                user: t[5],
                flash: t[1],
                flashmsg: t[2],
                action: t[3],
                apiCall: t[0]
            }
        }), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            p(t, i) {
                let s = {};
                32 & i && (s.user = t[5]), 2 & i && (s.flash = t[1]), 4 & i && (s.flashmsg = t[2]), 8 & i && (s.action = t[3]), e.$set(s)
            },
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }

    function w2(t) {
        let e, i, s = t[5] && wk(t);
        return {
            c() {
                s && s.c(), e = tt()
            },
            m(t, n) {
                s && s.m(t, n), Y(t, e, n), i = !0
            },
            p(t, i) {
                t[5] ? s ? (s.p(t, i), 32 & i && tR(s, 1)) : ((s = wk(t)).c(), tR(s, 1), s.m(e.parentNode, e)) : s && (tA(), tF(s, 1, 1, () => {
                    s = null
                }), t8())
            },
            i(t) {
                i || (tR(s), i = !0)
            },
            o(t) {
                tF(s), i = !1
            },
            d(t) {
                s && s.d(t), t && Q(e)
            }
        }
    }
    class w4 extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a;
                N(e, iv, t => s(4, n = t)), N(e, wt, t => s(5, a = t));
                let r, l, o, c = async (t, e, i, n, a) => {
                    s(3, o = t);
                    let c = await xs(e, i);
                    s(3, o = void 0), "ok" === c.result ? s(1, r = void 0) : (s(1, r = t), s(2, l = c.result)), n && we(), a && a(c)
                }, d = t => L(iv, n = !1);
                return e.$$.update = () => {
                    16 & e.$$.dirty && n && we()
                }, [c, r, l, o, n, a, d]
            }, function t(e) {
                let i, s, n = e[4] && w3(e);
                return {
                    c() {
                        n && n.c(), i = tt()
                    },
                    m(t, e) {
                        n && n.m(t, e), Y(t, i, e), s = !0
                    },
                    p(t, [e]) {
                        t[4] ? n ? (n.p(t, e), 16 & e && tR(n, 1)) : ((n = w3(t)).c(), tR(n, 1), n.m(i.parentNode, i)) : n && (tA(), tF(n, 1, 1, () => {
                            n = null
                        }), t8())
                    },
                    i(t) {
                        s || (tR(n), s = !0)
                    },
                    o(t) {
                        tF(n), s = !1
                    },
                    d(t) {
                        n && n.d(t), t && Q(i)
                    }
                }
            }, A, {
                apiCall: 0
            })
        }
        get apiCall() {
            return this.$$.ctx[0]
        }
    }

    function wC(t) {
        let e, i;
        return {
            c() {
                e = J("ins"), (i = J("script")).textContent = "(adsbygoogle = window.adsbygoogle || []).push({});", ti(e, "class", "adsbygoogle"), tr(e, "display", "inline-block"), tr(e, "width", "728px"), tr(e, "height", "90px"), ti(e, "data-ad-client", "ca-pub-6128207871826113"), ti(e, "data-ad-slot", "2385450998")
            },
            m(t, s) {
                Y(t, e, s), Y(t, i, s)
            },
            d(t) {
                t && Q(e), t && Q(i)
            }
        }
    }
    class wS extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a;
                N(e, iv, t => s(0, n = t)), N(e, eD, t => s(1, a = t));
                let r = t => L(iv, n = !0);
                return [n, a, r]
            }, function t(e) {
                let i, s, n, a, r, l, o, c = e[1] % 2 == 0 && wC();
                return {
                    c() {
                        i = J("div"), s = J("h3"), n = K("Hordes.io is free! Buy "), (a = J("span")).innerHTML = '<span class="textwhite">Hordes</span>  <img class="svgicon texticon" src="/assets/ui/icons/gem.svg?v=5699699">  Elixir', r = K(" to hide this window and support development."), c && c.c(), ti(a, "class", "btn textsub"), ti(s, "class", "textgrey blocktext svelte-svpjti"), ti(i, "class", "container panel-black svelte-svpjti")
                    },
                    m(t, d) {
                        Y(t, i, d), G(i, s), G(s, n), G(s, a), G(s, r), c && c.m(i, null), l || (o = te(a, "click", e[2]), l = !0)
                    },
                    p(t, [e]) {
                        t[1] % 2 == 0 ? c || ((c = wC()).c(), c.m(i, null)) : c && (c.d(1), c = null)
                    },
                    i: C,
                    o: C,
                    d(t) {
                        t && Q(i), c && c.d(), l = !1, o()
                    }
                }
            }, A, {})
        }
    }

    function w7(t, e, i) {
        let s = t.slice();
        return s[4] = e[i], s
    }

    function wE(t) {
        let e, i, s, n = rQ(t[4].viewers) + "";
        return {
            c() {
                e = J("div"), i = J("span"), s = K(n), ti(i, "class", "textgreen"), ti(e, "class", "bold viewcount textbox svelte-13wcf6i")
            },
            m(t, n) {
                Y(t, e, n), G(e, i), G(i, s)
            },
            p(t, e) {
                2 & e && n !== (n = rQ(t[4].viewers) + "") && tn(s, n)
            },
            d(t) {
                t && Q(e)
            }
        }
    }

    function w6(t) {
        let e, i, s, n, a, r, l, o = t[4].name + "",
            c = t[4].viewers && wE(t);
        return {
            c() {
                e = J("a"), i = J("div"), c && c.c(), s = J("div"), n = K(o), ti(s, "class", "name textbox svelte-13wcf6i"), ti(i, "class", "border black preview svelte-13wcf6i"), ti(i, "style", a = "background-image:url(" + (t[4].preview || "") + "); " + (t[0] ? "margin-top:2px;" : "")), ti(e, "class", "fadeIn stream svelte-13wcf6i"), ti(e, "target", "_blank"), ti(e, "rel", "noopener noreferrer"), ti(e, "href", r = t[4].url), ti(e, "style", l = t[0] ? "" : "width:calc(100%/6);")
            },
            m(t, a) {
                Y(t, e, a), G(e, i), c && c.m(i, null), G(i, s), G(s, n)
            },
            p(t, d) {
                t[4].viewers ? c ? c.p(t, d) : ((c = wE(t)).c(), c.m(i, s)) : c && (c.d(1), c = null), 2 & d && o !== (o = t[4].name + "") && tn(n, o), 3 & d && a !== (a = "background-image:url(" + (t[4].preview || "") + "); " + (t[0] ? "margin-top:2px;" : "")) && ti(i, "style", a), 2 & d && r !== (r = t[4].url) && ti(e, "href", r), 1 & d && l !== (l = t[0] ? "" : "width:calc(100%/6);") && ti(e, "style", l)
            },
            d(t) {
                t && Q(e), c && c.d()
            }
        }
    }
    class wP extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, {
                        vertical: a = !1
                    } = i,
                    r = a ? [{
                        name: rC.ui.streamLoad
                    }] : [],
                    l = async () => {
                        n = setTimeout(l, 2e4), s(1, r = await xs("/api/twitch/streams", {
                            max: 6
                        }))
                    };
                return tg(l), ty(t => {
                    n && clearTimeout(n)
                }), e.$$set = t => {
                    "vertical" in t && s(0, a = t.vertical)
                }, [a, r]
            }, function t(e) {
                let i, s, n = e[1],
                    a = [];
                for (let r = 0; r < n.length; r += 1) a[r] = w6(w7(e, n, r));
                return {
                    c() {
                        i = J("div");
                        for (let t = 0; t < a.length; t += 1) a[t].c();
                        ti(i, "style", s = "pointer-events: all; " + (e[0] ? "float:right; clear:right; width:150px;" : "display: flex; justify-content: center;"))
                    },
                    m(t, e) {
                        Y(t, i, e);
                        for (let s = 0; s < a.length; s += 1) a[s].m(i, null)
                    },
                    p(t, [e]) {
                        if (3 & e) {
                            let r;
                            for (n = t[1], r = 0; r < n.length; r += 1) {
                                let l = w7(t, n, r);
                                a[r] ? a[r].p(l, e) : (a[r] = w6(l), a[r].c(), a[r].m(i, null))
                            }
                            for (; r < a.length; r += 1) a[r].d(1);
                            a.length = n.length
                        }
                        1 & e && s !== (s = "pointer-events: all; " + (t[0] ? "float:right; clear:right; width:150px;" : "display: flex; justify-content: center;")) && ti(i, "style", s)
                    },
                    i: C,
                    o: C,
                    d(t) {
                        t && Q(i), X(a, t)
                    }
                }
            }, A, {
                vertical: 0
            })
        }
    }

    function wM(t) {
        let e, i, s, n, a, r, l, o, c, d, u, $, h, m, _, f = t[1][3] + "",
            p = t[1][1] + "",
            g = t[1][0] + "",
            v = t[1][2] + "",
            y = t[1][4] + "";
        return {
            c() {
                e = J("small"), i = J("div"), s = K(f), n = J("div"), a = K(p), r = K(" fps"), l = J("div"), o = K(g), c = K(" ms"), d = J("div"), u = K(v), $ = K(" KBs"), h = J("div"), m = K(y), _ = K(" BFR"), ti(i, "class", "textyellow"), ti(n, "class", "textgreen"), ti(l, "class", "textcyan"), ti(d, "class", "textorange"), ti(h, "class", "textpurp"), ti(e, "class", "marg-top bar btn black grey svelte-1apx3f3")
            },
            m(t, f) {
                Y(t, e, f), G(e, i), G(i, s), G(e, n), G(n, a), G(n, r), G(e, l), G(l, o), G(l, c), G(e, d), G(d, u), G(d, $), G(e, h), G(h, m), G(h, _)
            },
            p(t, e) {
                2 & e && f !== (f = t[1][3] + "") && tn(s, f), 2 & e && p !== (p = t[1][1] + "") && tn(a, p), 2 & e && g !== (g = t[1][0] + "") && tn(o, g), 2 & e && v !== (v = t[1][2] + "") && tn(u, v), 2 & e && y !== (y = t[1][4] + "") && tn(m, y)
            },
            d(t) {
                t && Q(e)
            }
        }
    }
    class w5 extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a;
                return N(e, iq, t => s(0, n = t)), N(e, e9, t => s(1, a = t)), [n, a]
            }, function t(e) {
                let i, s = e[0] && wM(e);
                return {
                    c() {
                        s && s.c(), i = tt()
                    },
                    m(t, e) {
                        s && s.m(t, e), Y(t, i, e)
                    },
                    p(t, [e]) {
                        t[0] ? s ? s.p(t, e) : ((s = wM(t)).c(), s.m(i.parentNode, i)) : s && (s.d(1), s = null)
                    },
                    i: C,
                    o: C,
                    d(t) {
                        s && s.d(t), t && Q(i)
                    }
                }
            }, A, {})
        }
    }

    function wD(t) {
        let e, i, s, n;
        return {
            c() {
                ti(e = J("img"), "class", "btn border black bgblack round warIcon svelte-1npf5af"), e.src !== (i = "/assets/ui/icons/war0.png?v=5699699") && ti(e, "src", i)
            },
            m(i, a) {
                Y(i, e, a), s || (n = te(e, "click", t[3]), s = !0)
            },
            p: C,
            d(t) {
                t && Q(e), s = !1, n()
            }
        }
    }
    class wT extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a, r;
                N(e, ek, t => s(1, n = t)), N(e, e2, t => s(2, a = t)), tg(() => {
                    r.appendChild($c), $f(!1)
                });
                let l = t => L(e2, a = !a);
                return [r, n, a, l, function t(e) {
                    tw[e ? "unshift" : "push"](() => {
                        s(0, r = e)
                    })
                }]
            }, function t(e) {
                let i, s = void 0 !== e[1] && wD(e);
                return {
                    c() {
                        i = J("div"), s && s.c(), ti(i, "class", "marg-top container panel-black svelte-1npf5af")
                    },
                    m(t, n) {
                        Y(t, i, n), s && s.m(i, null), e[4](i)
                    },
                    p(t, [e]) {
                        void 0 !== t[1] ? s ? s.p(t, e) : ((s = wD(t)).c(), s.m(i, null)) : s && (s.d(1), s = null)
                    },
                    i: C,
                    o: C,
                    d(t) {
                        t && Q(i), s && s.d(), e[4](null)
                    }
                }
            }, A, {})
        }
    }

    function wA(t) {
        let e, i;
        return e = new wS({}), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }

    function w8(t) {
        let e, i;
        return e = new wP({
            props: {
                vertical: !0
            }
        }), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }
    class wR extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a, r, l, o, c, d;
                return N(e, eO, t => s(0, n = t)), N(e, eD, t => s(1, a = t)), N(e, eE, t => s(2, r = t)), N(e, eR, t => s(3, l = t)), N(e, e8, t => s(4, o = t)), N(e, eT, t => s(5, c = t)), N(e, ig, t => s(6, d = t)), we(t => {
                    t && t.subscribed_until && lY("sub", "Hordes Elixir active $gt", !0)
                }), [n, a, r, l, o, c, d]
            }, function t(e) {
                let i, s, n, a, r, l, o, c, d, u, $, h, m, _, f, p, g, v, y, b, x, w, k, C, S, E, P, M, D, T, A, R, F, N, I, U, z, O, L;
                i = new vM({}), n = new _V({});
                let B = e[0] && !e[0].subscribed_until && (e[1] || e[2] || e[3] || e[4] || e[5]) && wA();
                l = new xi({}), o = new xu({}), c = new _Q({}), d = new v8({}), u = new fx({}), $ = new bX({}), h = new f_({}), m = new v2({}), _ = new vE({}), f = new vN({}), p = new yn({}), g = new bW({}), v = new y7({}), y = new yV({}), b = new yZ({}), x = new bd({}), w = new b9({}), k = new xG({}), C = new xJ({}), S = new xO({}), E = new w4({}), M = new vO({}), D = new wT({}), T = new w5({}), A = new vL({});
                let q = e[6] && w8();
                return I = new fT({}), U = new v0({}), z = new xZ({}), O = new bK({}), {
                    c() {
                        tW(i.$$.fragment), s = J("div"), tW(n.$$.fragment), a = J("div"), B && B.c(), r = tt(), tW(l.$$.fragment), tW(o.$$.fragment), tW(c.$$.fragment), tW(d.$$.fragment), tW(u.$$.fragment), tW($.$$.fragment), tW(h.$$.fragment), tW(m.$$.fragment), tW(_.$$.fragment), tW(f.$$.fragment), tW(p.$$.fragment), tW(g.$$.fragment), tW(v.$$.fragment), tW(y.$$.fragment), tW(b.$$.fragment), tW(x.$$.fragment), tW(w.$$.fragment), tW(k.$$.fragment), tW(C.$$.fragment), tW(S.$$.fragment), tW(E.$$.fragment), P = J("div"), tW(M.$$.fragment), tW(D.$$.fragment), tW(T.$$.fragment), tW(A.$$.fragment), q && q.c(), R = J("div"), F = J("div"), N = J("div"), tW(I.$$.fragment), tW(U.$$.fragment), tW(z.$$.fragment), tW(O.$$.fragment), ti(P, "class", "l-corner-ur uiscaled"), ti(a, "class", "container svelte-1j9lddf"), ti(N, "class", "actionbarcontainer svelte-1j9lddf"), ti(F, "class", "uiscaled"), ti(R, "class", "container svelte-1j9lddf"), ti(s, "class", "l-ui layout svelte-1j9lddf")
                    },
                    m(t, e) {
                        tH(i, t, e), Y(t, s, e), tH(n, s, null), G(s, a), B && B.m(a, null), G(a, r), tH(l, a, null), tH(o, a, null), tH(c, a, null), tH(d, a, null), tH(u, a, null), tH($, a, null), tH(h, a, null), tH(m, a, null), tH(_, a, null), tH(f, a, null), tH(p, a, null), tH(g, a, null), tH(v, a, null), tH(y, a, null), tH(b, a, null), tH(x, a, null), tH(w, a, null), tH(k, a, null), tH(C, a, null), tH(S, a, null), tH(E, a, null), G(a, P), tH(M, P, null), tH(D, P, null), tH(T, P, null), tH(A, P, null), q && q.m(P, null), G(s, R), G(R, F), G(F, N), tH(I, N, null), tH(U, N, null), tH(z, R, null), tH(O, s, null), L = !0
                    },
                    p(t, [e]) {
                        t[0] && !t[0].subscribed_until && (t[1] || t[2] || t[3] || t[4] || t[5]) ? B ? 63 & e && tR(B, 1) : ((B = wA()).c(), tR(B, 1), B.m(a, r)) : B && (tA(), tF(B, 1, 1, () => {
                            B = null
                        }), t8()), t[6] ? q ? 64 & e && tR(q, 1) : ((q = w8()).c(), tR(q, 1), q.m(P, null)) : q && (tA(), tF(q, 1, 1, () => {
                            q = null
                        }), t8())
                    },
                    i(t) {
                        L || (tR(i.$$.fragment, t), tR(n.$$.fragment, t), tR(B), tR(l.$$.fragment, t), tR(o.$$.fragment, t), tR(c.$$.fragment, t), tR(d.$$.fragment, t), tR(u.$$.fragment, t), tR($.$$.fragment, t), tR(h.$$.fragment, t), tR(m.$$.fragment, t), tR(_.$$.fragment, t), tR(f.$$.fragment, t), tR(p.$$.fragment, t), tR(g.$$.fragment, t), tR(v.$$.fragment, t), tR(y.$$.fragment, t), tR(b.$$.fragment, t), tR(x.$$.fragment, t), tR(w.$$.fragment, t), tR(k.$$.fragment, t), tR(C.$$.fragment, t), tR(S.$$.fragment, t), tR(E.$$.fragment, t), tR(M.$$.fragment, t), tR(D.$$.fragment, t), tR(T.$$.fragment, t), tR(A.$$.fragment, t), tR(q), tR(I.$$.fragment, t), tR(U.$$.fragment, t), tR(z.$$.fragment, t), tR(O.$$.fragment, t), L = !0)
                    },
                    o(t) {
                        tF(i.$$.fragment, t), tF(n.$$.fragment, t), tF(B), tF(l.$$.fragment, t), tF(o.$$.fragment, t), tF(c.$$.fragment, t), tF(d.$$.fragment, t), tF(u.$$.fragment, t), tF($.$$.fragment, t), tF(h.$$.fragment, t), tF(m.$$.fragment, t), tF(_.$$.fragment, t), tF(f.$$.fragment, t), tF(p.$$.fragment, t), tF(g.$$.fragment, t), tF(v.$$.fragment, t), tF(y.$$.fragment, t), tF(b.$$.fragment, t), tF(x.$$.fragment, t), tF(w.$$.fragment, t), tF(k.$$.fragment, t), tF(C.$$.fragment, t), tF(S.$$.fragment, t), tF(E.$$.fragment, t), tF(M.$$.fragment, t), tF(D.$$.fragment, t), tF(T.$$.fragment, t), tF(A.$$.fragment, t), tF(q), tF(I.$$.fragment, t), tF(U.$$.fragment, t), tF(z.$$.fragment, t), tF(O.$$.fragment, t), L = !1
                    },
                    d(t) {
                        tj(i, t), t && Q(s), tj(n), B && B.d(), tj(l), tj(o), tj(c), tj(d), tj(u), tj($), tj(h), tj(m), tj(_), tj(f), tj(p), tj(g), tj(v), tj(y), tj(b), tj(x), tj(w), tj(k), tj(C), tj(S), tj(E), tj(M), tj(D), tj(T), tj(A), q && q.d(), tj(I), tj(U), tj(z), tj(O)
                    }
                }
            }, A, {})
        }
    }

    function wF(t) {
        let e, i;
        return e = new wR({}), {
            c() {
                tW(e.$$.fragment)
            },
            m(t, s) {
                tH(e, t, s), i = !0
            },
            i(t) {
                i || (tR(e.$$.fragment, t), i = !0)
            },
            o(t) {
                tF(e.$$.fragment, t), i = !1
            },
            d(t) {
                tj(e, t)
            }
        }
    }
    class wN extends tY {
        constructor(t) {
            super(), tG(this, t, function t(e, i, s) {
                let n, a, r;
                return N(e, el, t => s(0, n = t)), N(e, en, t => s(1, a = t)), N(e, ew, t => s(2, r = t)), [n, a, r]
            }, function t(e) {
                let i, s, n, a;
                i = new $F({
                    props: {
                        active: e[0]
                    }
                });
                let r = e[1] && !e[0] && e[2] && wF();
                return n = new _B({}), {
                    c() {
                        tW(i.$$.fragment), r && r.c(), s = tt(), tW(n.$$.fragment)
                    },
                    m(t, e) {
                        tH(i, t, e), r && r.m(t, e), Y(t, s, e), tH(n, t, e), a = !0
                    },
                    p(t, [e]) {
                        let n = {};
                        1 & e && (n.active = t[0]), i.$set(n), t[1] && !t[0] && t[2] ? r ? 7 & e && tR(r, 1) : ((r = wF()).c(), tR(r, 1), r.m(s.parentNode, s)) : r && (tA(), tF(r, 1, 1, () => {
                            r = null
                        }), t8())
                    },
                    i(t) {
                        a || (tR(i.$$.fragment, t), tR(r), tR(n.$$.fragment, t), a = !0)
                    },
                    o(t) {
                        tF(i.$$.fragment, t), tF(r), tF(n.$$.fragment, t), a = !1
                    },
                    d(t) {
                        tj(i, t), r && r.d(t), t && Q(s), tj(n, t)
                    }
                }
            }, A, {})
        }
    }
    let wI = [uZ, uz, oi, $w, dQ, rs, r5, $T, $2],
        wU = !1,
        wz = () => {
            wI.forEach(t => {
                t.init && t.init()
            }), new wN({
                target: document.querySelector("body")
            })
        },
        wO = t => {
            wI.forEach(e => {
                e.preTick && e.preTick(t)
            })
        },
        wL = t => {
            wU && wI.forEach(e => {
                e.tick && e.tick(t)
            })
        },
        wB = (t, e) => {
            wU && wI.forEach(i => {
                i.postTick && i.postTick(t, e)
            })
        },
        wq = t => {
            wI.forEach(e => {
                e.onWorldEnter && e.onWorldEnter(t)
            }), wU = !0
        },
        wV = t => {
            wU && wI.forEach(e => {
                e.onWorldDestroy && e.onWorldDestroy(t)
            }), wU = !1
        };
    class wW {
        constructor(t) {
            this.id = 0, this.pos = [-0, -0, -0], this.rot = [-0, -0, -0], this.scale = 1, this.matrix = void 0, this.loaded = !1
        }
        setWorldMatrix(t, e) {
            this.matrix = t, sj(ar, e, this.pos), sH(al, this.scale), nk(a$, this.rot), nb(this.matrix, a$, ar, al)
        }
        loadGeometry(t, e) {
            if (!this.loaded) {
                let i = d.get(this.id);
                this.loaded = !0, 0 === i.geometry ? this.postGeometryLoad(t, e) : lg(i.geometry, (i, s) => {
                    let n = !t.finishedLoadingChunks.has(e.id);
                    this.postGeometryLoad(t, e), n && this.onGeometryLoad(t, e, i, s)
                })
            }
        }
        onUpdate(t, e, i) {}
        postGeometryLoad(t, e) {
            e.onPropFinishLoading(this)
        }
        onGeometryLoad(t, e, i, s) {
            let n = i.position.data,
                a = i.normal.data,
                r = s.coll,
                l = new Map,
                o = new Map,
                c = this.matrix;
            for (let d = 0, u = r.length; d < u; d += 3) {
                let $ = 3 * r[d],
                    h = 3 * r[d + 1],
                    m = 3 * r[d + 2],
                    _ = [wH($, l, n, c), wH(h, l, n, c), wH(m, l, n, c)],
                    f = cd(cr(), _);
                _.push(wj($, o, a, c)), t.triangleGrid.add(_, f)
            }
        }
        onRemove() {}
    }
    let wH = (t, e, i, s) => {
            if (e.has(t)) return e.get(t); {
                let n = [i[t], i[t + 1], i[t + 2]];
                return ni(n, n, s), e.set(t, n), n
            }
        },
        wj = (t, e, i, s) => {
            if (e.has(t)) return e.get(t);
            let n = [i[t], i[t + 1], i[t + 2]];
            return function t(e, i, s) {
                let n = i[0],
                    a = i[1],
                    r = i[2];
                return e[0] = s[0] * n + s[4] * a + s[8] * r, e[1] = s[1] * n + s[5] * a + s[9] * r, e[2] = s[2] * n + s[6] * a + s[10] * r, e
            }(n, n, s), sZ(n, n), e.set(t, n), n
        };
    class wG extends wW {
        constructor(t) {
            super(t || {}), this.mesh = void 0, this.effects = []
        }
        onUpdate(t, e, i) {
            void 0 !== this.mesh && this.updateMesh(e), super.onUpdate(t, e, i)
        }
        updateMesh(t) {
            this.setWorldMatrix(this.mesh.worldMatrix, t), sj(this.mesh.position, t, this.pos), sW(this.mesh.rotation, this.rot[0], this.rot[1], this.rot[2]), sH(this.mesh.scale, this.scale), this.mesh.data.multi && (this.mesh.data.multi.needsUpdate = !0)
        }
        onRemove(t) {
            if (super.onRemove(t), d.get(this.id).effects.length) {
                this.deleteEffects();
                let e = t.effectProps.indexOf(this);
                e >= 0 && t.effectProps.splice(e, 1)
            }
            this.mesh && (this.mesh.data.multi ? this.mesh.data.multi.remove(this.mesh) : nA(this.mesh), this.mesh = void 0)
        }
        postGeometryLoad(t, e) {
            if (super.postGeometryLoad(t, e), void 0 === this.mesh) {
                let i = d.get(this.id);
                0 === i.geometry ? this.mesh = nT() : (this.mesh = hZ(this.id, !0, !0, !1, !0), i.tilescale > 0 && (this.mesh.data.tile[0] = this.scale * i.tilescale)), this.updateMesh(e.origin), i.effects.length && (e.effectProps.push(this), 7 === e.state && this.createEffects())
            }
        }
        createEffects() {
            let t = d.get(this.id).effects;
            for (let e = 0; e < t.length; ++e) {
                let i = t[e],
                    s = nT();
                sV(s.position, i.pos), sV(s.scale, i.scale), sV(s.rotation, i.rot), nC(s, this.mesh), nE(s, !0);
                let n = mp(i.id, s, 0, !0);
                this.effects.push(n)
            }
        }
        deleteEffects() {
            for (let t = 0; t < this.effects.length; ++t) this.effects[t].done = !0;
            this.effects.length = 0
        }
    }
    class wY {
        constructor() {
            this.id = 0, this.x = 0, this.z = 0, this.origin = [0, 0, 0], this.deserialized = !1, this.props = {}, this.normals = [];
            for (let t = 0; t < 6144; ++t) this.normals[t] = 0;
            this.data = void 0, this.loadingProps = 0
        }
        init(t, e, i) {
            this.id = t, this.x = e, this.z = i, this.origin[0] = 64 * e, this.origin[2] = 64 * i, this.deserialized = !1, this.props = {}, this.data = void 0, this.loadingProps = 0
        }
        onBeginLoading() {
            as.onChunkBeginLoading(this)
        }
        onFinishLoading() {
            as.onChunkFinishLoading(this)
        }
        deserialize(t, e) {
            this.parse(aN.chunk.decode(t), t, e)
        }
        parse(t) {
            this.data = t, this.updateNormals(), this.unpackProps(!0), this.deserialized = !0
        }
        getHeight(t, e) {
            let i = (t /= 2) % 1,
                s = (e /= 2) % 1;
            if (0 === i && 0 === s) return .030517578125 * this.data.terrain[t + 33 * e]; {
                let n = Math.floor(t),
                    a = Math.floor(e),
                    r = i + s < 1,
                    l = r ? -(i - 1 + s) : -(s - 1),
                    o = r ? s : -(i - 1);
                return .030517578125 * (l * this.data.terrain[n + 33 * a + (r ? 0 : 1)] + o * this.data.terrain[n + 33 * Math.min(32, a + 1)] + (1 - l - o) * this.data.terrain[n + 1 + 33 * (a + (r ? 0 : 1))])
            }
        }
        getHeightFromWorld(t, e) {
            return t -= this.origin[0], e -= this.origin[2], this.getHeight(t, e)
        }
        updateNormals() {
            let t = [-0, -0, -0];
            for (let e = 0; e < 32; ++e)
                for (let i = 0; i < 32; ++i) {
                    let s = 3 * (2 * i + 32 * e * 2),
                        n = 2 * i,
                        a = 2 * e;
                    sW(ac, n, this.getHeight(n, a), a), sW(ad, n, this.getHeight(n, a + 2), a + 2), sW(au, n + 2, this.getHeight(n + 2, a), a), or(t, ac, ad, au), this.normals[s] = t[0], this.normals[s + 1] = t[1], this.normals[s + 2] = t[2], sW(ac, n + 2, this.getHeight(n + 2, a), a), sW(au, n + 2, this.getHeight(n + 2, a + 2), a + 2), or(t, ac, ad, au), this.normals[s + 3] = t[0], this.normals[s + 4] = t[1], this.normals[s + 5] = t[2]
                }
        }
        getNeighborChunk(t, e) {
            return t < 64 ? this.front : e < 64 ? this.right : this.frontRight || this.right || this.front
        }
        unpackProps(t) {
            let e = {};
            for (let i = 0, s = this.data.props.length; i < s; ++i) {
                let n = this.data.props[i];
                null == this.props[n.id] && (this.props[n.id] = []), void 0 === e[n.id] && (e[n.id] = 0);
                let a = mI(this, this.props[n.id][e[n.id]] || new wG, n);
                t && this.onPropBeginLoading(a), this.props[n.id][e[n.id]] = a, e[n.id]++
            }
            for (let r in this.props) this.props[r].forEach(t => {
                t.onUpdate(as, this.origin, as.bounds), t.loadGeometry(as, this)
            });
            for (let l in this.props) {
                let o = e[l] || 0;
                if (this.props[l] && o < this.props[l].length) {
                    for (let c = o; c < this.props[l].length; ++c) this.props[l][c].onRemove(this);
                    this.props[l].splice(o)
                }
            }
            0 == this.data.props.length && this.onAllPropsFinishLoading()
        }
        destroy() {
            for (let t in this.props) this.props[t].forEach(t => t.onRemove(this))
        }
        onPropBeginLoading(t) {
            this.loadingProps++
        }
        onPropFinishLoading(t) {
            this.loadingProps--, 0 === this.loadingProps && this.onAllPropsFinishLoading()
        }
        onAllPropsFinishLoading() {
            this.onFinishLoading()
        }
    }
    let wQ = [],
        wX = 0,
        wJ = () => {
            let t = wQ.shift();
            t[0](...t[1])
        },
        wK = (t, e, i) => {
            if (i)
                for (; wX > 0;) wX--, wJ();
            else wX > 0 && (wX--, requestIdleCallback(wJ, {
                timeout: 5e3
            }))
        },
        wZ = (t, e, i) => {
            wQ.push([t, e]), wX++
        },
        kt = (t, e) => {
            e.state = 3, e.deserialize(t)
        };
    class ke extends wY {
        constructor() {
            super(), this.center2d = [0, 0], this.geometry = {}, this.meshes = {}, this.state = 0, this.effectProps = [], this.neighbors = []
        }
        init(t, e, i, s) {
            super.init(t, e, i, s), this.center2d[0] = this.origin[0] + 32, this.center2d[1] = this.origin[2] + 32, this.neighbors.length = 0;
            for (let n = Math.max(0, e - 1); n <= Math.min(s.chunkAmount - 1, e + 1); n++)
                for (let a = Math.max(0, i - 1); a <= Math.min(s.chunkAmount - 1, i + 1); a++) {
                    let r = n + a * s.chunkAmount;
                    r !== this.id && this.neighbors.push(r)
                }
            this.state = 0
        }
        load() {
            this.state >= 2 || (super.onBeginLoading(), this.state = 2, fetch(`data/world/${as.file}/${this.id}?v=5699699`, {
                cache: "default"
            }).then(t => {
                t.arrayBuffer().then(t => {
                    wZ(kt, [new Uint8Array(t), this])
                }).catch(() => {
                    console.log(`failed to load chunk ${this.id}, retrying`), this.state = 1, this.load()
                })
            }))
        }
        isInRange() {
            let t = as.player.pos[0] - this.center2d[0],
                e = as.player.pos[2] - this.center2d[1];
            return t * t + e * e
        }
        tickDelta(t, e, i) {
            let s = void 0 !== i.player ? this.isInRange() : 1 / 0,
                n = s < _R;
            if (0 == this.state || 3 === this.state) {
                if (n) {
                    0 === this.state && (this.state = 1);
                    let a = !0;
                    for (let r = 0; r < this.neighbors.length; ++r) {
                        let l = i.chunksMap.get(this.neighbors[r]);
                        l ? l.state < 3 && (0 === l.state && (l.state = 1), a = !1) : a = !1
                    }
                    3 === this.state && a && (this.state = 4, this.rebuild(!0, !0, !0, !0))
                }
            } else this.state >= 5 ? (n && this.state < 7 ? (this.addToScene(), this.state = 7) : n || 7 !== this.state || (this.removeFromScene(), this.state = 6), void 0 !== this.meshes.foliage && (this.meshes.foliage.transform.visible = s < 19600)) : 1 === this.state && (this.load(), this.state = 2)
        }
        rebuild(t, e, i, s) {
            wZ(_L, [this, t, e, i, s])
        }
        addToScene() {
            for (let t = 0; t < this.effectProps.length; ++t) this.effectProps[t].createEffects();
            hy(this.meshes.terrain.transform)
        }
        removeFromScene() {
            for (let t = 0; t < this.effectProps.length; ++t) this.effectProps[t].deleteEffects();
            h0(this.meshes.terrain.transform)
        }
        destroy() {
            super.destroy(), 7 === this.state && this.removeFromScene()
        }
    }
    class ki {
        constructor(t, e, i, s, n, a) {
            this.nodes = new Map, this.width = t, this.height = e, this.depth = i, this.yd = n, this.zd = a, this.xm = s - 1, this.ym = n - 1, this.zm = a - 1, this.xs = t / s, this.ys = e / n, this.zs = i / a
        }
        clear() {
            this.nodes.clear()
        }
        add(t, e) {
            let i = Math.max(0, Math.min(this.xm, ~~(e[0] / this.xs))),
                s = Math.max(0, Math.min(this.ym, ~~(e[1] / this.ys))),
                n = Math.max(0, Math.min(this.zm, ~~(e[2] / this.zs))),
                a = Math.max(0, Math.min(this.xm, ~~(e[3] / this.xs))),
                r = Math.max(0, Math.min(this.ym, ~~(e[4] / this.ys))),
                l = Math.max(0, Math.min(this.zm, ~~(e[5] / this.zs)));
            for (let o = i; o <= a; ++o)
                for (let c = s; c <= r; ++c)
                    for (let d = n; d <= l; ++d) {
                        let u = o * this.yd * this.zd + c * this.zd + d;
                        this.nodes.has(u) || this.nodes.set(u, {
                            aabbs: [],
                            content: [],
                            count: 0
                        });
                        let $ = this.nodes.get(u);
                        $.content.push(t), $.aabbs.push(e), $.count++
                    }
        }
        queryAABB(t) {
            let e = Math.max(0, Math.min(this.xm, ~~(t[0] / this.xs))),
                i = Math.max(0, Math.min(this.ym, ~~(t[1] / this.ys))),
                s = Math.max(0, Math.min(this.zm, ~~(t[2] / this.zs))),
                n = Math.max(0, Math.min(this.xm, ~~(t[3] / this.xs))),
                a = Math.max(0, Math.min(this.ym, ~~(t[4] / this.ys))),
                r = Math.max(0, Math.min(this.zm, ~~(t[5] / this.zs))),
                l = [];
            for (let o = e; o <= n; ++o)
                for (let c = i; c <= a; ++c)
                    for (let d = s; d <= r; ++d) {
                        let u = o * this.yd * this.zd + c * this.zd + d;
                        if (this.nodes.has(u)) {
                            let $ = this.nodes.get(u);
                            for (let h = 0; h < $.count; ++h) {
                                let m = $.content[h];
                                co($.aabbs[h], t) && !l.includes(m) && l.push(m)
                            }
                        }
                    }
            return l
        }
        queryRay(t, e, i) {
            let s = t[0] + e[0],
                n = t[1] + e[1],
                a = t[2] + e[2],
                r = Math.max(0, Math.min(this.xm, ~~(Math.min(t[0], s) / this.xs))),
                l = Math.max(0, Math.min(this.ym, ~~(Math.min(t[1], n) / this.ys))),
                o = Math.max(0, Math.min(this.zm, ~~(Math.min(t[2], a) / this.zs))),
                c = Math.max(0, Math.min(this.xm, ~~(Math.max(t[0], s) / this.xs))),
                d = Math.max(0, Math.min(this.ym, ~~(Math.max(t[1], n) / this.ys))),
                u = Math.max(0, Math.min(this.zm, ~~(Math.max(t[2], a) / this.zs))),
                $ = [];
            for (let h = r; h <= c; ++h)
                for (let m = l; m <= d; ++m)
                    for (let _ = o; _ <= u; ++_) {
                        let f = h * this.yd * this.zd + m * this.zd + _;
                        if (this.nodes.has(f)) {
                            let p = this.nodes.get(f);
                            for (let g = 0; g < p.count; ++g) {
                                let v = p.content[g];
                                c$(p.aabbs[g], t, i, 0, 1) && !$.includes(v) && $.push(v)
                            }
                        }
                    }
            return $
        }
    }
    let ks = {
            origin: [0, 0, 0],
            dir: [0, -1, 0],
            invDir: [0, 0, 0]
        },
        kn = (t, e, i, s, n, a, r) => {
            var l, o;
            sW(t.origin, e, i, s), sW(t.dir, n, a, r), l = t.invDir, o = t.dir, l[0] = 1 / o[0], l[1] = 1 / o[1], l[2] = 1 / o[2]
        };
    class ka {
        constructor(t) {
            this.entity = t, this.buffs = new Map, this.casters = new Map, fz.forEach(t => {
                this[t] = new Set
            }), this.tags = new Map;
            for (let e = 0; e < 10; ++e) this.tags.set(e, new Set)
        }
        tick(t, e, i) {}
        setBuff(t, e, i, s, n, a) {
            i <= 0 && console.error("buff with zero or less stacks");
            let r = this.buffs.get(t) || this.buffs.set(t, new Map).get(t),
                l = r.get(e) || {};
            if (l.caster = e, l.id = t, l.level = a, l.stacks = i, l.logic = pG.get(t), l.timer = new aH(s, n), l.active = !0, l.uniqueInstances = 0, l.remove = !1, void 0 !== l.logic.intervalDuration) {
                let o = s;
                l.interval && (o = l.interval.start);
                let c = as.entity(e);
                l.interval = new aH(o, l.logic.intervalHaste && void 0 !== c ? l.logic.intervalDuration / b2(c.stats.getStat(16)) : l.logic.intervalDuration)
            } else l.interval = new aH(0, 0);
            return r.set(e, l), l.logic.onSet(l, e, this), (this.casters.get(e) || this.casters.set(e, new Map).get(e)).set(t, l), l.logic.unique && this.updateUniqueState(t), l
        }
        removeBuff(t, e) {
            let i = this.buffs.get(t);
            if (i) {
                let s = i.get(e);
                if (s) {
                    s.logic.onRemove(s, e, this), i.delete(e), 0 === i.size && this.buffs.delete(t);
                    let n = this.casters.get(e);
                    return n.delete(t), 0 === n.size && this.casters.delete(e), s.logic.unique && this.updateUniqueState(t), s
                }
            }
        }
        updateUniqueState(t) {
            let e = this.buffs.get(t);
            if (e) {
                let i;
                e.forEach((t, s) => {
                    (!i || t.level > i.level) && (i = t), t.active = !1, t.uniqueInstances = e.size
                }), i.active = !0
            }
        }
        clear(t) {
            this.buffs.forEach((e, i) => {
                e.forEach((e, s) => {
                    e.logic.passive == t && e.logic.clearOnDeath && this.removeBuff(i, s)
                })
            })
        }
        clearTempBuffs() {
            this.clear(!1)
        }
        clearPassiveBuffs() {
            this.clear(!0)
        }
        onDeath() {
            this.clearTempBuffs()
        }
    }
    let kr = (t, e, i, s) => {
            t.walking = void 0 === t.entity.mount && t.walking, kd(t), ku(t), kc(t), ko(t, e, i), kl(t, e, i)
        },
        kl = (t, e, i, s) => {
            if (t.body[0].visible && t.entity.buffs.visualIncapacitate > 0) {
                sG(t.body[0].rotation, .3 * (Math.sin(2.2 * i) + .3 * Math.sin(2.1 * i)) + 1, .3 * (Math.sin(2.1 * i) + .6 * Math.sin(2 * i)), .3 * (Math.sin(.8 * i) + .5 * Math.sin(2.3 * i)));
                for (let n = 2; n <= 3; ++n) t.body[n].position[1] -= .2
            }
        },
        ko = (t, e, i, s) => {
            let n = t.body[2];
            if (n.visible && (void 0 !== t.body[6] && (t.sheathed || (t.entity.mount ? k$(t, !0) : !t.entity.target || t.walking || t.falling ? (n.rotation[0] += .5, n.position[1] -= .2, n.position[0] -= .1) : (n.rotation[0] += 1, n.rotation[2] += .6, n.position[2] -= .3, n.position[1] -= .2, n.position[0] -= .1, t.body[4].position[0] -= .05, t.body[5].position[0] += .05, t.body[4].position[2] -= .2, t.body[0].position[1] += .05 * Math.sin(3 * i) - .05, t.body[0].rotation[1] -= .05 * Math.cos(3 * i)))), t.currentAnim && 13 !== t.currentAnim.info.movement)) {
                let a = aV.easeInOutCubic(t.currentAnim.fract),
                    r = -Math.sin(7.5 * a - 1.5),
                    l = -Math.sin(6.28 * a),
                    o = -Math.sin(3.14 * a),
                    c = aV.easeOutExpo(-o);
                switch (sQ(n.rotation, n.rotation, 1 - c), t.currentAnim.info.movement) {
                    case 0:
                        if (void 0 !== t.body[6]) k$(t, !1), sG(n.rotation, 1.7 * o, 1.5 * c, r * c + .5 * c), n.position[2] -= o - a * c, n.position[1] += Math.sin(13 * a + 3) * c * .5, n.position[0] += (1.5 * a - .5) * c, t.body[0].rotation[1] += 1.5 * l;
                        else {
                            let d = Math.cos(6.28 * a);
                            t.body[0].position[2] += (.3 + .2 * Math.sin(6.28 * a - 3.14)) * c, t.body[0].rotation[0] += .5 * Math.sin(3.28 * a) * c;
                            for (let u = 0; u <= 1; ++u) {
                                let $ = t.body[2 + u];
                                $.visible && (sQ($.position, $.position, 1 - c), $.position[2] += (1 - .5 * d) * c, $.position[1] += Math.sin(6.28 * a) * (a > .5 ? .7 : 1), $.position[0] += (u ? .5 + .2 * o : -.5 - .2 * o) * c, sW($.rotation, 0, 1.5, 0))
                            }
                        }
                        break;
                    case 1:
                        k$(t, !1), n.rotation[0] -= 1.7 * o, n.rotation[1] += 1.5 * c - c, n.rotation[2] += r * c + .5 * c, n.position[2] += c, n.position[0] -= .5 * c, t.body[0].rotation[1] -= 1.5 * l - .5 * c;
                        break;
                    case 12:
                        k$(t, !1), n.rotation[0] = 1.7, n.rotation[1] = 0, n.rotation[2] = .5, n.position[2] = 1.3, n.position[1] = .2, n.position[0] = -.5;
                        break;
                    case 4:
                        k$(t, !1), n.rotation[0] += 1.7 * o, n.rotation[1] -= 1.5 * o, n.position[0] -= .5 * c, t.body[0].rotation[1] = 2 * a * Math.PI + 3 * c;
                        break;
                    case 3:
                        k$(t, !0), sW(t.body[0].rotation, o, 0, 0), sW(n.position, -.3, 0, .7);
                        break;
                    case 11:
                        k$(t, !1), sW(t.body[0].rotation, .4 * o, 0, .3 * o), n.rotation[0] -= .8 * o, n.rotation[1] += .4 * o;
                        break;
                    case 9:
                        k$(t, !1), sW(n.rotation, 0, 0, 0);
                        break;
                    case 5:
                        k$(t, !0)
                }
            }
            let h = t.body[3];
            void 0 !== t.body[7] && h.visible && (!t.entity.target || t.walking || t.falling ? (h.rotation[2] -= .1, h.position[1] += .1) : (h.rotation[2] -= .2, h.rotation[1] -= 1, h.position[1] += .1, h.position[2] += .4))
        },
        kc = t => {
            for (let e = 0; e <= 1; ++e) {
                let i = t.body[4 + e];
                if (i.visible) {
                    if (t.entity.mount) t.entity.mount.mountLegs(i, e);
                    else {
                        let s = oo(t.entity.steer);
                        if (t.currentAnim && 10 === t.currentAnim.info.movement) {
                            sW(i.position, 0, 0, 0);
                            continue
                        }
                        if (t.falling) {
                            if (0 == t.flip) {
                                let n = .1 * Math.max(-1, Math.min(0, .2 * t.entity.vel[1])),
                                    a = e ? .3 * t.cycle(0) - n : .3 * t.cycle(.5) + n;
                                sW(ar, e ? .3 - n : -.3 + n, -.65, a), na(i.position, ar, 0), sW(i.rotation, -a, s, 0)
                            } else sW(i.position, e ? .3 : -.3, -.3, 0), sW(i.rotation, 0, 0, 0)
                        } else if (t.entity.inWater > t.entity.radius) t.walking ? (sW(i.rotation, 1.3, e ? .1 : -.1, 0), sW(i.position, e ? .3 : -.3, .4 * Math.cos(t.cycleRad + e * Math.PI), -1.1)) : (sW(i.rotation, 1, e ? .1 : -.1, 0), sW(i.position, e ? .3 : -.3, -.7, .4 * Math.cos(t.cycleRad + e * Math.PI)));
                        else {
                            if (t.walking) {
                                let r = t.entity.steer[1] < 0 ? .4 : .6,
                                    l = t.cycle(0) * r * 1.3;
                                sW(ar, e ? .3 : -.3, Math.max(0, .6 * Math.cos(t.cycleRad + (e ? 0 : Math.PI))) - .55, t.cycle(e ? 0 : .5) * r), na(i.position, ar, s), sW(i.rotation, e ? -l : l, s, 0)
                            } else sW(i.rotation, 0, e ? .1 : -.1, 0), sW(i.position, e ? .45 : -.45, -.65, 0);
                            t.currentAnim && !t.walking && (5 != t.currentAnim.info.movement && 13 != t.currentAnim.info.movement && 6 != t.currentAnim.info.movement && 9 != t.currentAnim.info.movement || sW(i.position, e ? .4 : -.55, -.65, e ? .2 : -.3))
                        }
                    }
                }
            }
        },
        kd = t => {
            if (t.body[0].visible) {
                if (t.falling && void 0 === t.entity.mount ? (t.transform.rotation[0] = t.cycleRad * t.flip, sW(t.body[0].position, 0, 0 != t.flip ? .3 : .5, 0)) : (t.walking ? t.entity.inWater > t.entity.radius ? sW(t.body[0].position, 0, -.1, 0) : sW(t.body[0].position, 0, .1 * Math.cos(2 * t.cycleRad) + .4, 0) : t.entity.inWater > t.entity.radius ? sW(t.body[0].position, 0, .3, 0) : sW(t.body[0].position, 0, void 0 === t.entity.mount ? .1 * t.cycle(0) + .4 : .4, 0), 0 !== t.transform.rotation[0] && (t.transform.rotation[0] = 0)), t.entity.inWater > t.entity.radius) t.walking ? sW(t.body[0].rotation, 1.2, 0, .1 * Math.sin(t.cycleRad)) : sW(t.body[0].rotation, .1 * Math.sin(t.cycleRad) - .1, 0, .05 * Math.cos(t.cycleRad));
                else {
                    sW(t.body[0].rotation, -(5 * t.pushBack[1]) + t.movementPushback[2], 0, 5 * t.pushBack[0] - t.movementPushback[0]), o_(t.body[0].position, t.body[0].position, t.pushBackOffset), sX(t.body[0].position, t.body[0].position, t.movementPushback, 1);
                    let e = -(.5 * t.movementPushback[1]);
                    sW(t.body[0].scale, 1 + e, 1 - e, 1 + e)
                }
                if (void 0 !== t.currentAnim) {
                    let i = t.currentAnim.info.movement;
                    if (5 != i && 6 != i || (t.body[0].rotation[1] -= .3 + .05 * t.cycle(.2), t.body[0].rotation[0] += .3 + .02 * t.cycle(.4), t.body[0].position[1] -= .1 + .05 * t.cycle(.6), t.body[0].position[0] -= .05), 6 == i) t.body[0].rotation[1] *= 1 - t.currentAnim.fract;
                    else if (10 == i) sW(t.body[0].position, 0, .2 + .5 * Math.sin(t.currentAnim.fract * Math.PI), 0), t.body[0].rotation[0] += t.currentAnim.fract * os, t.body[0].rotation[1] += oo(t.entity.steer);
                    else if (9 == i) {
                        let s = aV.easeOutQuad(aL(2 * t.currentAnim.fract, 0, 1));
                        t.body[0].position[1] += .2 * Math.sin(3 + 5 * s), t.body[0].rotation[0] += .5 - .5 * s
                    } else 12 == i ? t.body[0].rotation[1] = t.currentAnim.fract * Math.PI * 2 : 13 == i && (t.body[0].position[2] -= .2 + .05 * t.cycle(.4), t.body[0].rotation[0] = .12 * t.cycle(.8) - .2, t.body[0].rotation[1] = -.2, t.body[0].rotation[2] = .2 + .05 * t.cycle(.15))
                }
            }
        },
        ku = t => {
            for (let e = 0; e <= 1; ++e) {
                let i = t.body[2 + e];
                if (i.visible) {
                    if (t.falling && void 0 === t.entity.mount) sW(i.position, e ? .6 : -.6, -aL(t.entity.vel[1], -5, 5) / 20, 0), i.position[0] += (e ? 1 : -1) * Math.sin(3.1 * i.position[1] + .8) * .3, sW(i.rotation, 0, e ? Math.PI : 0, -.3 - i.position[1]);
                    else if (t.entity.inWater > t.entity.radius) {
                        if (t.walking) {
                            let s = t.cycle(0),
                                n = t.entity.steer[1] < 0 ? .3 : .5,
                                a = Math.sin(2 * t.cycleRad + 5);
                            sW(i.rotation, 0, s * n * 1.3 + (e ? Math.PI : 0), 0), sW(i.position, (e ? .7 : -.7) + a * (e ? -.2 : .2), .2 + s * n * (e ? -1.5 : 1.5), s * (e ? -.3 : .3) - .2)
                        } else {
                            let r = Math.cos(t.cycleRad + 2 * e);
                            sW(i.rotation, 0, (e ? -.43 + Math.PI : .43) + .15 * r * (e ? 1 : -1), .3), sW(i.position, e ? .7 : -.7, .05 * r - .2, .6 - .2 * r)
                        }
                    } else if (t.walking) {
                        let l = t.cycle(0),
                            o = t.entity.steer[1] < 0 ? .3 : .5,
                            c = Math.sin(2 * t.cycleRad + 5);
                        sW(i.rotation, 0, l * o * 1.3 + (e ? Math.PI : 0), 0), sW(i.position, (e ? .7 : -.7) + c * (e ? -.2 : .2), l * (e ? .3 : -.3) - .2, .2 + l * o * (e ? -1.5 : 1.5)), i.position[0] = e ? Math.max(.5, i.position[0]) : Math.min(-.5, i.position[0])
                    } else if (t.entity.mount) sW(i.rotation, 0, e ? -1.3 + Math.PI : 1.3, .3), sW(i.position, e ? .3 : -.3, -.5, .7);
                    else {
                        let d = t.cycle(0);
                        sW(i.rotation, 0, (e ? -.43 + Math.PI : .43) + .15 * d * (e ? 1 : -1), .3), sW(i.position, e ? .7 : -.7, .08 * d - .3, .15 - .1 * d)
                    }
                    if (t.currentAnim) {
                        let u = t.currentAnim.info.movement;
                        if (5 == u || 6 == u) 0 == e ? (i.position[0] -= .2, i.position[1] -= .2, 6 == u && (sQ(i.position, i.position, 1 - t.currentAnim.fract), i.position[0] += -(.3 * t.currentAnim.fract), i.position[2] += .8 * Math.sin(7 * Math.min(.5, t.currentAnim.fract) + 4) + .4)) : (i.position[0] -= .4, i.position[2] += .5 - .2 * t.cycle(.3), i.rotation[1] += .6 + .2 * t.cycle(.4), i.rotation[0] -= .8, 6 == u && (sQ(i.position, i.position, 1 - t.currentAnim.fract), i.position[0] += .3 * t.currentAnim.fract, i.position[2] += .7 * Math.sin(7 * Math.min(.5, t.currentAnim.fract) + 4) + .3));
                        else if (9 === u) {
                            let $ = aV.easeInOutCubic(aL(2 * t.currentAnim.fract, 0, 1));
                            sW(i.rotation, 1 - $, 0, 0);
                            let h = Math.sin(3 * $);
                            0 == e ? sW(i.position, -.12 - .35 * h, 1.2 * $ - .1, .3 + h) : sW(i.position, .12 + .35 * h, 1.2 * $, .3 + h)
                        } else if (11 === u) {
                            let m = Math.sin(3 * aV.easeInOutCubic(t.currentAnim.fract));
                            i.position[0] += m * (e ? .3 : 0), i.position[1] = m * (e ? -.2 : 1) - .3, i.position[2] = m * (e ? -.3 : 1)
                        } else 13 === u && (i.position[0] = e ? .6 : 0, i.position[1] = e ? .7 : 1, i.position[2] = .8, i.rotation[0] = e ? .2 * t.cycle(.4) : .2 * t.cycle(.2), i.rotation[1] = e ? 2 : 1, i.rotation[2] = e ? 2 : 1)
                    }
                    if (t.body[8 + e]) {
                        let _ = t.body[8 + e];
                        _.visible && (n5(_, i.position, !1, an), sQ(_.rotation, _.rotation, .5), _.rotation[1] -= e ? .8 : -.8, _.rotation[2] -= e ? .5 : -.5)
                    }
                }
            }
        },
        k$ = (t, e) => {
            t.sheathed !== e && (t.sheathed = e, void 0 !== t.body[6] && (nC(t.body[6], e ? t.body[0] : t.body[2]), t.sheathed ? sV(t.body[6].position, t.skin.sheathedPos) : sV(t.body[6].position, t.skin.unsheathedPos)), void 0 !== t.body[7] && (nC(t.body[7], e ? t.body[0] : t.body[3]), t.sheathed ? (sW(t.body[7].position, 0, -.2, -.65), sW(t.body[7].rotation, 0, -1.57, 0)) : (sW(t.body[7].position, -.2, 0, 0), sW(t.body[7].rotation, 0, 0, 0))))
        },
        kh = (t, e, i, s) => {
            let n = t.body[3];
            if (n.visible && (sW(n.rotation, .2, 1.7 + .15 * t.cycleSin, .4), sW(n.position, .1 + .2 * t.cycleSin, -.3, .9), t.entity.target > 0 && (n.position[0] = .2, n.position[1] += .15, n.position[2] += .1, n.rotation[0] += .2, n.rotation[1] = 1.8, n.rotation[2] -= .2), t.currentAnim)) switch (t.currentAnim.info.movement) {
                case 5: {
                    k$(t, !1);
                    let a = aV.easeOutQuad(aL(2 * t.currentAnim.fract, 0, 1));
                    sW(n.rotation, 1.2, 2, .3), sW(n.position, .2, 0, .8 + .8 * a), sW(t.body[2].position, -.1 - .6 * Math.sin(2 * a), .1 * a, .8 - .8 * a), sW(t.body[0].position, 0, .6 - .2 * a, 0), sW(t.body[0].rotation, .2 - .2 * a, .3 * a - .4, 0);
                    break
                }
                case 7: {
                    k$(t, !1);
                    let r = aV.easeOutFlick(aL(2 * (t.currentAnim.fract - .5), 0, 1));
                    sW(n.rotation, 1.2, 2, .3 + .1 * r), sW(n.position, .2, .3 * r, 1.6), sW(t.body[2].position, -.7, .1, -(.7 * r)), sW(t.body[0].position, 0, .4, 0), sW(t.body[0].rotation, 0, -.1, 0);
                    break
                }
                case 8: {
                    k$(t, !1);
                    let l = aV.easeOutQuad(aL(2 * t.currentAnim.fract, 0, 1));
                    sW(t.body[2].position, -.5 - .3 * l, .3 * l - .3, .6 * Math.sin(6.28 * l)), sW(n.rotation, .2 + .5 * l, 2, .3), sW(n.position, .2, .3 * l - .4, .8 + .8 * l), t.body[0].rotation[1] = 0, t.body[0].rotation[0] = .2 * l - .2
                }
            }!t.walking && t.body[4].visible && (t.body[4].position[2] -= .3, t.body[5].position[2] += .1)
        },
        km = [
            [kr, kh],
            [kr, (t, e, i, s) => {
                let n = t.body[2];
                sG(n.rotation, .9, -.4, 0), n.position[2] -= .1
            }],
            [(t, e, i, s) => {
                let n = t.cycle(.5);
                if (sW(t.body[0].scale, .1 * n + 1, 1 + .1 * t.cycleSin, .1 * n + 1), sW(t.body[0].position, 0, .1 * t.cycleSin - .1, 0), sW(t.body[0].rotation, -(5 * t.pushBack[1]), 0, 5 * t.pushBack[0]), o_(t.body[0].position, t.body[0].position, t.pushBackOffset), t.currentAnim) {
                    let a = aV.easeOutExpo(t.currentAnim.fract ** 3);
                    0 === t.currentAnim.info.movement && (t.body[0].position[2] += Math.sin(6.28 * a - 3.14))
                }
                for (let r = 0; r < 2; ++r) {
                    let l = t.body[16 + r];
                    if (l.visible = t.transform.visible, !l.visible) continue;
                    for (let o = 0; o < l.children.length; ++o) l.children[o].visible = !0;
                    let c = 0 == r ? t.transform : t.body[16 + r - 1];
                    sY(ar, c.position, l.position), sW(ao, 0, 0, -(.7 * c.scale[0])), na(al, ao, c.rotation[1]), sj(ar, ar, al);
                    let d = sq(ar);
                    d > 30 * t.entity.size ? sV(l.position, t.entity.pos) : sX(l.position, l.position, ar, Math.max(0, Math.min(.5, 20 * e * (d - .7 * l.scale[1])))), sW(l.rotation, 0, oc(sY(ar, c.position, l.position)), 0), sH(l.scale, .3 * (3 - r) * (.8 + .1 * t.cycle(.3 * r)) * t.transform.scale[0]), l.position[1] = Math.max(s.getHeight(l.position[0], l.position[2]) + .5 * l.scale[1], l.position[1] - 2.5 * e), nE(l, !1)
                }
            }],
            [kr, (t, e, i, s) => {
                if (!t.currentAnim)
                    for (let n = 0; n < 2; ++n) {
                        let a = t.body[2 + n];
                        if (!a.visible) continue;
                        let r = t.cycle(1.3);
                        sW(a.rotation, .78, 0, n ? .2 * r : -(.2 * r)), sW(a.position, n ? .2 : -.2, -.4, .6)
                    }
            }],
            [(t, e, i, s) => {
                if (t.walking && !t.falling) {
                    t.speed = t.entity.speed * (-1 === t.entity.steer[1] ? -1.2 : 1) * .04 / (.6 + .6 * t.entity.size);
                    let n = Math.cos(t.cycleRad);
                    sW(t.body[4].rotation, 0, .2 * t.cycleSin, .2 * t.cycleSin), sW(t.body[4].position, 0, .3 * Math.abs(n) + .2, 0), sW(t.body[5].rotation, 0, Math.PI + .2 * n, .2 * n), sW(t.body[5].position, 0, .3 * Math.abs(t.cycleSin), 0), sW(t.body[0].position, .01 * t.cycle(.3), .02 * t.cycleSin, 0), sW(t.body[0].rotation, 0, .01 * t.cycleSin, .01 * Math.sin(2 * t.cycleRad)), t.entity.target > 0 && .3 > Math.random() && t.fraction(.1, e) && t.playSound(t.skin.sounds[6], !1)
                } else {
                    if (t.speed = .5, t.currentAnim) {
                        let a = aV.easeOutExpo(t.currentAnim.fract ** 3);
                        if (0 === t.currentAnim.info.movement) {
                            let r = Math.sin(6.28 * a - 3.14);
                            sW(t.body[0].position, 0, Math.max(0, -r), .5 * r);
                            for (let l = 0; l < 2; ++l) {
                                let o = t.body[4 + l],
                                    c = 0 == l ? 1 : -1,
                                    d = 1 == l ? Math.PI : 0;
                                sW(o.rotation, c * Math.min(r, 0), d + .1 * r * c, 0), sW(o.position, 0, Math.max(0, -r), .5 * r)
                            }
                        }
                    } else {
                        sW(t.body[0].position, 0, .1 * t.cycle(-.1), 0);
                        for (let u = 0; u < 2; ++u) {
                            let $ = t.body[4 + u],
                                h = t.cycle(0 == u ? 0 : .5);
                            sW($.rotation, 0, 1 == u ? Math.PI : 0, t.falling ? .4 : 0), sW($.position, 0, .1 * h, 0)
                        }
                    }
                    sW(t.body[0].rotation, 0, 0, 0)
                }
                sW(t.body[0].rotation, t.body[0].rotation[0] - 5 * t.pushBack[1], t.body[0].rotation[1], t.body[0].rotation[2] + 5 * t.pushBack[0])
            }],
            [(t, e, i, s) => {
                sW(t.transform.rotation, -(2 * t.pushBack[1]), t.entity.rot, 2 * t.pushBack[0])
            }],
            [kr, (t, e, i, s) => {
                for (let n = 0; n < 2; ++n) {
                    let a = t.body[2 + n];
                    a.position[1] *= .8, a.position[2] *= .8, a.position[1] += .5;
                    let r = t.body[4 + n];
                    r.position[1] -= 0, r.position[0] += n ? .4 : -.4
                }
                sW(t.body[0].scale, 1.8, 2, 1.8), t.body[0].position[1] += 1
            }],
            [kr],
            [],
            [kr, (t, e, i, s) => {
                sW(t.body[2].position, -.8, -.2, .7), sW(t.body[2].rotation, 1.8 + .1 * t.cycleSin, 0, 0)
            }],
            [kr, (t, e, i, s) => {
                sW(t.body[18].rotation, 0, 0, .3 * i), sW(t.body[3].position, .8, -.2, .7), sW(t.body[3].rotation, 1.8, 0, 0)
            }],
            [kr, (t, e, i, s) => {
                sG(t.body[0].rotation, .1 * (Math.sin(1.8 * i) * Math.cos(12 * i) * .3 + .3 * Math.sin(1.4 * i)) - .2, .15 * (Math.sin(1.3 * i) + .6 * Math.sin(2.4 * i)), .2 * (Math.sin(.2 * i) + .5 * Math.sin(1.9 * i)));
                for (let n = 0; n < 2; ++n) {
                    let a = t.body[2 + n];
                    a.rotation[0] += .2 * (Math.sin(2 * i) * Math.cos(9 * i) + Math.sin(1.3 * i)), a.rotation[1] += .3 * (Math.sin(2 * i - 2) * Math.cos(7 * i) + Math.sin(.8 * i));
                    let r = t.body[4 + n];
                    r.rotation[1] += .3 * Math.sin(.2 * i - n), r.position[0] += n ? .15 : -.15
                }
            }],
            [kr, kh, (t, e, i, s) => {
                sG(t.body[0].rotation, .1 * (Math.sin(1.8 * i) * Math.cos(12 * i) * .3 + .3 * Math.sin(1.4 * i)) - .2, .15 * (Math.sin(1.3 * i) + .6 * Math.sin(2.4 * i)), .2 * (Math.sin(.2 * i) + .5 * Math.sin(1.9 * i)));
                for (let n = 0; n <= 1; ++n) {
                    let a = t.body[2 + n];
                    a.visible && sG(a.rotation, .2 * (Math.sin(2 * i) * Math.cos(9 * i) + Math.sin(1.3 * i)), .3 * (Math.sin(2 * i - 2) * Math.cos(7 * i) + Math.sin(.8 * i)), 0);
                    let r = t.body[4 + n];
                    r.visible && (r.rotation[1] += .3 * Math.sin(.2 * i - n), r.position[0] += n ? .15 : -.15)
                }
            }],
            [kr, (t, e, i, s) => {
                sG(t.body[0].rotation, .1 * (Math.sin(1.8 * i) * Math.cos(12 * i) * .3 + .3 * Math.sin(1.4 * i)) - .2, .15 * (Math.sin(1.3 * i) + .6 * Math.sin(2.4 * i)), .2 * (Math.sin(.2 * i) + .5 * Math.sin(1.9 * i)));
                for (let n = 0; n < 2; ++n) {
                    let a = t.body[2 + n];
                    a.visible && sG(a.rotation, .2 * (Math.sin(2 * i) * Math.cos(9 * i) + Math.sin(1.3 * i)), .3 * (Math.sin(2 * i - 2) * Math.cos(7 * i) + Math.sin(.8 * i)), 0), t.body[4 + n].visible && (a.rotation[1] += .3 * Math.sin(.2 * i - n), a.position[0] += n ? .15 : -.15)
                }
            }],
            [kr, (t, e, i, s) => {
                t.body[2].position[2] += .6, sG(t.body[2].rotation, -2.1, -4.1, -.2)
            }],
            [kr, (t, e, i, s) => {
                if (void 0 === t.currentAnim || 0 === t.currentAnim.info.movement)
                    for (let n = 0; n < 2; ++n) {
                        let a = t.body[2 + n];
                        sW(a.position, n ? .5 : -.5, n ? .1 : -.1, 1), sW(a.rotation, 0, 1.5, 0)
                    }
                sG(t.body[0].rotation, .1 * (Math.sin(1.8 * i) * Math.cos(2 * i) * .3 + .3 * Math.sin(1.4 * i)) + .2, .1 * (Math.sin(1.3 * i) + .6 * Math.sin(2.4 * i)), .1 * (Math.sin(.4 * i) + .5 * Math.sin(1.9 * i)));
                for (let r = 0; r < 2; ++r) t.body[4 + r].rotation[1] += .3 * Math.sin(.2 * i - r)
            }]
        ];
    class k_ {
        constructor(t, e, i, s, n) {
            this.transform = nT(), this.transform.matrixAutoUpdate = !0, this.soundPrio = t.radius > 3 ? 1 : 0, this.entity = t, this.cycleOne = 0, this.cycleRad = l4(0, 1), this.cycleSin = 0, this.speed = 1, this.lastFlags = 0, this.deathTimer = new aH(0, 0), this.hurtSoundTimer = new aH(0, 5), this.idleSoundTimer = new aH(as.time + l4(0, 20), 20), this.pushBack = [0, 0], this.pushBackVel = [0, 0], this.pushBackOffset = [0, 0], this.movementPushback = [0, 0, 0], this.movementPushbackVel = [0, 0, 0], this.groundNormal = [0, 0, 0], this.cDist = 1 / 0, this.cDistLast = 1 / 0, this.inFog = !0, this.animQueue = [], this.currentAnim = void 0, this.eyesBlink = 0, this.capeoffset = 0, this.walking = !0, this.falling = !1, this.hasDied = !1, this.flip = 0, this.hasJustJumped = !1, this.hasJustLanded = !0, this.sheathed = !1, this.needsColorUpdate = !1, this.colors = new Set, this.body = [], this.meshes = [], this.effects = [], this.skin = m.get(e), this.skeleton = _.get(this.skin.skeleton), this.animset = km[this.skin.animset], i || (i = this.skin.colPrim), s || (s = this.skin.colSec);
            for (let a = 0; a < this.skin.body.length; ++a) {
                let r = this.skin.body[a],
                    l = r.col;
                1 === r.bid && void 0 !== n ? l = n : 1 === r.colMode ? l = i : 2 === r.colMode && (l = s);
                let o = this.mesh(r.bid, r.pid, 1 === r.dynamic, r.mid, r.lod, l, 1 === r.ts);
                o && (sV(o.position, r.pos), sV(o.scale, r.scl), sV(o.rotation, r.rot))
            }
            for (let c = 0; c < this.skin.effects.length; ++c) {
                let d = this.skin.effects[c];
                this.effects.push(mp(d.id, this.body[d.bid], 0, !1))
            }
        }
        cycle(t) {
            return 0 == t ? this.cycleSin : Math.sin(this.cycleRad + 2 * t * Math.PI)
        }
        checkCycleReset() {
            let t = this.falling << 1 | (!this.falling && this.walking) << 2;
            t != this.lastFlags && (this.cycleOne = 0, this.lastFlags = t)
        }
        addPushBack(t, e, i) {
            this.cDist < 50 && (this.pushBackVel[0] -= t * i / this.entity.size, this.pushBackVel[1] -= e * i / this.entity.size)
        }
        addRandomPushback(t) {
            this.cDist < 50 && (this.pushBackVel[0] -= l4(-1, 1) * t / this.entity.size, this.pushBackVel[1] -= l4(-1, 1) * t / this.entity.size)
        }
        tickPushBack(t, e, i) {
            this.cDist < 50 && (nY(this.pushBackVel, this.pushBackVel, this.pushBack, -(1500 * t) / this.entity.size), nG(this.pushBackVel, this.pushBackVel, 1 - 30 * t), nY(this.pushBack, this.pushBack, this.pushBackVel, t), function t(e, i, s) {
                let n = Math.sin(s),
                    a = Math.cos(s);
                return e[0] = i[1] * n + i[0] * a, e[1] = i[1] * a - i[0] * n, e
            }(this.pushBackOffset, this.pushBack, -this.entity.rot)), this.cDist < 25 && (sX(this.movementPushback, this.movementPushback, this.movementPushbackVel, 60 * t), sX(this.movementPushbackVel, this.movementPushbackVel, this.movementPushbackVel, -20 * t), sX(this.movementPushbackVel, this.movementPushbackVel, this.movementPushback, -10 * t), this.movementPushbackVel[2] += .01 * this.entity.steer[1], this.movementPushbackVel[0] -= .01 * this.entity.steer[0])
        }
        disableVis(t) {
            for (let e = 0, i = t.children.length; e < i; ++e) {
                let s = t.children[e];
                s.visible = !1, this.disableVis(s)
            }
        }
        checkVis(t, e, i) {
            for (let s = 0, n = t.children.length; s < n; ++s) {
                let a = t.children[s];
                0 > this.meshes.indexOf(a) || (a.visible = a.data.lod * e / this.cDist > i, a.visible ? this.checkVis(a, e, i) : this.disableVis(a))
            }
        }
        updateVisibility() {
            let t = void 0 !== this.entity.mount ? 1 / 0 : Math.max(60, Math.min(150, .7 * nZ.far));
            return this.cDist = sJ(this.transform.position, nZ.worldPosition), this.inFog = this.cDist > t, this.inFog || sO.disableoffscreen && !nZ.frustumIntersectsSphere(this.entity.visualPosition, this.transform.scale[1]) ? (this.cDistLast = 0, this.transform.visible && (this.transform.visible = !1, this.meshes.forEach(t => t.visible = !1), this.clearAnims()), !1) : (!this.hasDied && Math.abs(this.cDistLast - this.cDist) > 1 && (this.cDistLast = this.cDist, this.checkVis(this.transform, Math.max(1, this.transform.scale[1]), 1.5 / (45 + t))), this.transform.visible = !0, !0)
        }
        tick(t, e, i) {
            this.updateVisibility() && (this.needsColorUpdate && this.colorUpdate(), void 0 === this.entity.stats || this.entity.stats.alive ? 0 === this.entity.buffs.visualFreeze && (this.cycleOne = (this.cycleOne + this.speed * t) % 1, this.cycleRad = this.cycleOne * Math.PI * 2, this.cycleSin = Math.sin(this.cycleRad), this.tickAnimations(t), this.skin.sounds[5] && this.idleSoundTimer.done(e) && .08 > Math.random() && (this.playSound(this.skin.sounds[5], !0), this.idleSoundTimer.reset(i.time)), this.falling = this.entity.inWater < this.entity.radius && (this.falling && !this.entity.onGround || !this.falling && !this.onGround && Math.abs(this.entity.vel[1]) > 6), this.walking = 0 != this.entity.steer[0] || 0 != this.entity.steer[1], this.tickVisuals(t, e, i)) : this.tickDeath(t, e, i), nE(this.transform, !1))
        }
        tickVisuals(t, e, i) {
            this.checkCycleReset(), this.calculateCycleSpeed(), void 0 !== this.body[1] && this.tickEyes(t, this.body[1]), void 0 !== this.body[10] && this.tickCape(t, this.body[10]), this.tickWalking(t), this.tickLanding();
            for (let s = 0; s < this.animset.length; ++s) this.animset[s](this, t, e, i);
            if (this.skeleton.groundNormal || this.entity.mount && this.entity.mount.skeleton.groundNormal) {
                let n = Math.min(1, 10 * t);
                this.groundNormal[0] += (this.entity.groundNormal[0] - this.groundNormal[0]) * n, this.groundNormal[2] += (this.entity.groundNormal[2] - this.groundNormal[2]) * n, ol(this.transform.rotation, this.groundNormal)
            } else this.flip || (this.transform.rotation[0] = this.transform.rotation[2] = 0)
        }
        tickFixed(t, e, i) {
            this.hasDied || this.tickPushBack(t, e, i)
        }
        tickAnimations(t) {
            let e = this.currentAnim = this.animQueue[0];
            if (e) {
                let i = e.info,
                    s = e.fract;
                if (this.animQueue.length > 1 && 0 === i.priority ? e.fract > .6 ? e.time += 5 * t : e.time = e.info.duration : e.time += t, e.fract = e.time / i.duration, e.time > i.duration) {
                    if (!e.loop) return e.fract = 1, this.onAnimEnd(e), void this.animQueue.shift();
                    e.fract %= 1, e.time = 0
                }
                for (let n = 0; n < i.sounds.length; ++n) {
                    let a = i.sounds[n];
                    a.end > 0 ? e.fract >= a.start && e.fract <= a.end ? void 0 === e.activeSounds[n] && (e.activeSounds[n] = lz(a.id, this.transform, this.soundPrio, !0, 1)) : void 0 !== e.activeSounds[n] && (e.activeSounds[n].stop(), e.activeSounds[n] = void 0) : e.fract >= a.start && (s < a.start || 0 === a.start && 0 === s) && (4 === e.id && 50 === a.id ? lz(this.skin.sounds[0], this.transform, this.soundPrio, !1, 1) : lz(a.id, this.transform, this.soundPrio, !1, 1))
                }
                for (let r = 0; r < i.effects.length; ++r) {
                    let l = i.effects[r];
                    if (0 === l.type && e.fract > l.start && s <= l.start) {
                        let o, c = !1;
                        if (99 === l.body) {
                            let d = as.entity(e.dirImpactTarget);
                            d && d.visual && (o = nT(), nM(o, d.visual.transform, this.transform, d.radius), nE(o, !1), d.visual.addPushBack(this.transform.position[0] - d.visual.transform.position[0], this.transform.position[2] - d.visual.transform.position[2], 2)), c = !0
                        } else 101 === l.body ? (o = nT(), sV(o.position, this.transform.position), sV(o.scale, this.transform.scale), sV(o.rotation, this.transform.rotation), nE(o, !1), c = !0) : o = 100 === l.body ? this.transform : this.body[l.body];
                        if (void 0 === o) continue;
                        mf(l.id, o, this.soundPrio, c)
                    } else if (l.type > 0) {
                        if (e.fract >= l.start && e.fract <= l.end) {
                            if (void 0 === e.activeEffects[r]) {
                                let u = 100 === l.body ? this.transform : this.body[l.body];
                                u && (e.activeEffects[r] = 1 === l.type ? mp(l.id, u, this.soundPrio, !1) : mg(l.id, u, this.soundPrio, !1))
                            } else {
                                let $ = e.activeEffects[r];
                                1 === l.type || ($.fractionLast = $.fractionNow, $.fractionNow = Math.min(1, Math.max(0, 1 - (l.end - e.fract) / (l.end - l.start))))
                            }
                        } else void 0 !== e.activeEffects[r] && (e.activeEffects[r].done = !0, e.activeEffects[r] = void 0)
                    }
                }
            }
        }
        tickEyes(t, e) {
            if (e.visible) {
                let i = 0;
                i = this.eyesBlink > 0 ? this.eyesBlink - t : .006 > Math.random() ? .1 : this.eyesBlink, (this.eyesBlink > 0 && i < 0 || i > 0 && this.eyesBlink < 0) && (e.scale[1] = i > 0 ? .1 : e.scale[0], e.matrixNeedsUpdate = !0), this.eyesBlink = i
            }
        }
        tickCape(t, e) {
            e.visible && this.skin.capeswing && ((this.entity.steer[1] > 0 || this.falling) && (this.capeoffset += .5 * sq(this.entity.vel) * t), this.capeoffset *= 1 - 3 * t, sW(e.rotation, Math.max(0, this.capeoffset), 0, 0))
        }
        tickLanding() {
            this.entity.inWater > this.entity.radius || (this.hasJustJumped && this.entity.onGround && (this.cDist < 20 && (0 == this.entity.vel[1] || this.entity.vel[1] < -4) && (1 === this.soundPrio && this.playSound(this.skin.sounds[8], !0), this.movementPushbackVel[2] = .05, this.movementPushbackVel[1] = -.15, this.eyesBlink = .3), this.hasJustLanded = !0, this.hasJustJumped = !1, this.flip = 0), this.hasJustLanded && !this.entity.onGround && (this.entity.vel[1] > 5 && (1 === this.soundPrio && this.playSound(this.skin.sounds[7], !0), .5 > Math.random() && (this.flip = this.entity.steer[1]), this.movementPushbackVel[2] = .05, this.movementPushbackVel[1] = -.1, this.eyesBlink = .3, .2 > l4(0, 1) && this.onEffort()), this.hasJustJumped = !0, this.hasJustLanded = !1))
        }
        tickWalking(t) {
            if ((this.cDist < 20 || this.transform.scale[1] > 2) && !this.falling) {
                let e = this.transform.scale[1] > 2 || this.body[0].scale[1] > 2,
                    i = this.fraction(.2, t),
                    s = this.fraction(.7, t);
                this.entity.inWater > 0 ? this.walking ? this.entity.inWater < this.entity.radius ? (i || s) && (this.playSound(e ? 55 : this.entity.inWater > this.entity.radius / 2 ? 127 : 128, !1), this.watersplash(92)) : (i || s) && (i && this.playSound(129, !1), this.watersplash(93)) : (i || s) && this.watersplash(93) : this.walking && (e || 1 === this.soundPrio) && (i || s) && this.playSound(e ? 55 : this.skin.sounds[6], !e)
            }
        }
        calculateCycleSpeed() {
            this.falling ? this.speed = 1.5 : this.walking ? this.entity.inWater < this.entity.radius ? this.speed = this.entity.speed / 20 * (-1 === this.entity.steer[1] ? 1.3 : 1) * .45 / (.4 + .6 * this.entity.size) : this.speed = this.entity.speed / 20 * .2 : this.speed = .5
        }
        fraction(t, e, i = this.cycleOne) {
            return i >= t && i - this.speed * e < t
        }
        mesh(t, e, i, s, n, a, r = !1) {
            let l = hZ(s, r, sO.shadowscreature, !0, !1);
            if (l.data.lod = n, l.visible = !1, l.matrixAutoUpdate = i, void 0 !== a && this.changeMeshBaseColor(l, a), e >= 0) {
                if (!this.body[e]) return void console.log("Error: cant set parent body", e);
                nC(l, this.body[e]), l.parent.data.lod = Math.max(n, l.parent.data.lod || 1)
            } else - 1 === e && nC(l, this.transform);
            return this.meshes.push(l), this.body[t] = l, l
        }
        removeMesh(t) {
            let e = this.body[t];
            void 0 !== e && (e.data.multi.remove(e), this.meshes.splice(this.meshes.indexOf(e), 1), this.body[t] = void 0)
        }
        clearMeshes() {
            for (let t = 0; t < this.meshes.length; ++t) {
                let e = this.meshes[t];
                e.data.multi.remove(e)
            }
            this.meshes.length = 0, this.body.length = 0
        }
        clearEffects() {
            for (let t = 0; t < this.effects.length; ++t) this.effects[t].done = !0;
            this.effects.length = 0
        }
        onRemove() {
            this.clearAnims(), this.clearMeshes(), this.clearEffects(), nA(this.transform)
        }
        anim(t, e, i) {
            if (this.transform.visible && this.animQueue.length <= 2) {
                let s = {
                    id: t,
                    info: h.get(t),
                    loop: e,
                    dirImpactTarget: i,
                    activeSounds: [],
                    activeEffects: [],
                    time: 0,
                    fract: 0
                };
                this.animQueue.push(s)
            }
        }
        clearAnims() {
            for (let t = 0; t < this.animQueue.length; ++t) this.onAnimEnd(this.animQueue[t]);
            this.animQueue.length = 0
        }
        onAnimEnd(t) {
            for (let e = 0; e < t.activeEffects.length; ++e) {
                let i = t.activeEffects[e];
                i && (i.done = !0)
            }
            t.activeEffects.length = 0;
            for (let s = 0; s < t.activeSounds.length; ++s) {
                let n = t.activeSounds[s];
                n && n.stop()
            }
            t.activeSounds.length = 0
        }
        playSound(t, e) {
            return 0 !== t && !this.inFog && (lz(t, this.transform, this.soundPrio, !1, e ? this.getAudioPitch() : 1), !0)
        }
        onHurt(t) {
            (t > .2 || this.hurtSoundTimer.done(as.time)) && this.playSound(this.skin.sounds[1], !0) && this.hurtSoundTimer.reset(as.time)
        }
        onEffort() {
            .3 > l4(0, 1) && this.playSound(this.skin.sounds[3], !0)
        }
        onAggro() {
            this.playSound(this.skin.sounds[4], !0) && this.idleSoundTimer.reset(as.time)
        }
        onDeath() {
            this.hasDied = !0, this.playSound(this.skin.sounds[2], !0), this.body[1] && this.removeMesh(1), this.addColor(dN.death), this.deathTimer.reset(as.time, 3);
            let t = this.meshes.length;
            for (; t--;) {
                let e = this.meshes[t];
                e.data.deathSize = (e.geometry.bounds.initiated ? e.geometry.bounds.radius : 1) * (e.scale[0] + e.scale[1] + e.scale[2]) / 3, nC(e, null), nv(e.position, e.worldMatrix), ny(e.scale, e.worldMatrix), n0(e.quaternion, e.worldMatrix), e.data.deathVel = [l4(-.5, .5), 1, l4(-.5, .5)], e.matrixAutoUpdate = !0
            }
        }
        tickDeath(t, e, i) {
            this.deathTimer.done(e) ? this.clearMeshes() : this.meshes.forEach(e => {
                if (!e.visible || void 0 === e.data.deathVel) return;
                let s = e.data.deathVel,
                    n = e.data.deathSize;
                sX(e.position, e.position, s, t), sQ(s, s, 1 - 3 * t);
                let a = i.getHeight(e.position[0], e.position[2]) + .5 * n;
                s[1] < 0 && e.position[1] < a ? s[1] < -1 ? (s[1] = .7 * Math.abs(s[1]), s[0] += l4(-1, 1) / n, s[2] += l4(-1, 1) / n) : s[1] = -.5 : s[1] -= 50 * t, ne(ar, s, an), sX(e.rotation, e.rotation, ar, -(5 * t)), nE(e, !1)
            })
        }
        mountPosition(t) {
            ni(t, this.skeleton.mountOffset, this.body[0].worldMatrix)
        }
        mountLegs(t, e) {
            sW(t.rotation, -.9, e ? .2 : -.2, e ? .4 : -.4), sW(t.position, e ? .6 : -.6, -.4, .5)
        }
        getAudioPitch() {
            return Math.max(.6, Math.min(1, .5 / this.entity.radius))
        }
        getTopAbsolute() {
            return this.entity.radius * this.skeleton.height
        }
        addColor(t) {
            this.colors.add(t), this.needsColorUpdate = !0
        }
        removeColor(t) {
            this.colors.delete(t), this.needsColorUpdate = !0
        }
        colorUpdate() {
            this.needsColorUpdate = !1, this.meshes.forEach(t => this.updateMeshColor(t))
        }
        changeMeshBaseColor(t, e) {
            t.data.basecolor = e, this.updateMeshColor(t)
        }
        updateMeshColor(t) {
            let e = t.data.color;
            n9(e, t.data.basecolor), this.colors.forEach(t => {
                let i = t[3],
                    s = 1 - i;
                e[0] = e[0] * s + t[0] * i, e[1] = e[1] * s + t[1] * i, e[2] = e[2] * s + t[2] * i
            })
        }
        setShoulders(t, e = 1, i = !1) {
            if (this.skeleton.shoulders) {
                if (this.hasDied || !1 === t) {
                    if (!this.hasDied) {
                        for (let s = 8; s <= 9; ++s) this.removeMesh(s);
                        for (let n = 14; n <= 15; ++n) this.body[n] && this.removeMesh(n)
                    }
                } else
                    for (let a = 0; a <= 1; ++a)
                        if (!this.body[8 + a]) {
                            let r = this.mesh(8 + a, 0, !0, 1, .6);
                            sW(r.position, a ? .5 : -.5, .4 * e - .4, -.05), sW(r.scale, .8 * e, .5 * e, .5 * e), this.changeMeshBaseColor(r, t)
                        } if (!1 !== i)
                    for (let l = 0; l <= 1; ++l) {
                        this.body[14 + l] || this.mesh(14 + l, 8 + l, !1, 7, .3);
                        let o = this.body[14 + l];
                        sW(o.rotation, 0, 3.14, 0), sW(o.position, l ? .2 : -.2, 0, -.5), sW(o.scale, .35, .55, .2), this.changeMeshBaseColor(o, i)
                    } else
                        for (let c = 14; c <= 15; ++c) this.body[c] && this.removeMesh(c)
            }
        }
        setCape(t, e) {
            this.skeleton.cape && (this.hasDied || !1 === t ? this.hasDied || void 0 === this.body[10] || this.removeMesh(10) : (void 0 === this.body[10] && sW(this.mesh(10, 0, !0, 8, .7).position, 0, .2, -.55), sW(this.body[10].scale, e, e, e), this.changeMeshBaseColor(this.body[10], t)))
        }
        setHeadgear(t) {
            this.skeleton.helmet && (this.hasDied || !1 === t ? this.hasDied || void 0 === this.body[11] || this.removeMesh(11) : (void 0 === this.body[11] && this.mesh(11, 0, !1, 9, .5), this.changeMeshBaseColor(this.body[11], t)))
        }
        setGem(t, e = 1) {
            if (this.skeleton.helmet) {
                if (this.hasDied || !1 === t) this.hasDied || void 0 === this.body[12] || this.removeMesh(12);
                else {
                    if (void 0 === this.body[12]) {
                        let i = this.mesh(12, 0, !1, 7, .5);
                        sW(i.position, 0, .4, .54), sW(i.scale, .3 * e, .3 * e, .08 * e)
                    }
                    this.changeMeshBaseColor(this.body[12], t)
                }
            }
        }
        setCrown(t) {
            this.skeleton.helmet && (this.hasDied || !1 === t ? this.hasDied || void 0 === this.body[13] || this.removeMesh(13) : (void 0 === this.body[13] && (this.mesh(13, 0, !1, 10, .8), this.body[13].position[1] = .8), this.changeMeshBaseColor(this.body[13], t)))
        }
        watersplash(t) {
            let e = nT();
            sV(e.position, this.entity.pos), e.position[1] = this.entity.pos[1] - this.entity.radius + this.entity.inWater + .05, nE(e), mf(t, e, this.soundPrio, !0)
        }
    }
    class kf {
        constructor(t) {
            this.id = t.id || 0, this.type = t.type, this.pos = [0, 0, 0], this.vel = [0, 0, 0], this.rot = this.size = this.radius = -0, this.setSize(t.size), this.name = t.name
        }
        async init(t) {
            this.name = t.name || ""
        }
        preFixed(t, e, i) {}
        tickFixed(t, e, i) {}
        postFixed(t, e, i) {}
        preDelta(t, e, i) {}
        tickDelta(t, e, i) {}
        postDelta(t, e, i) {}
        onRemove() {}
        setPos(t) {
            this.pos[0] = t[0], this.pos[1] = t[1], this.pos[2] = t[2]
        }
        setRot(t) {
            this.rot = oa(t)
        }
        onTarget(t) {
            return !0
        }
        setName(t) {
            this.name = t
        }
        clampWorldPos() {
            as.clampV3(this.pos), this.pos[1] = Math.max(this.pos[1], this.getWorldYBody(as, this.pos[0], this.pos[2]))
        }
        getWorldYBody(t, e, i) {
            return t.getHeight(e, i)
        }
        setSize(t) {
            this.size = t, this.radius = t / 2
        }
        distanceV2(t) {
            return nj(ah, t, om(am, this.pos)), nQ(ah)
        }
        distanceV3(t) {
            return sY(ar, t, this.pos), sq(ar)
        }
        squaredDistanceV2(t) {
            return nj(ah, t, om(am, this.pos)),
                function t(e) {
                    let i = e[0],
                        s = e[1];
                    return i * i + s * s
                }(ah)
        }
        squaredDistance(t) {
            return sY(ar, t, this.pos),
                function t(e) {
                    let i = e[0],
                        s = e[1],
                        n = e[2];
                    return i * i + s * s + n * n
                }(ar)
        }
        rotationToV2(t) {
            return nj(ah, t, om(am, this.pos)), nX(ah, ah), oo(ah)
        }
        rotationToV3(t) {
            return sY(ar, t, this.pos), sZ(ar, ar), oc(ar)
        }
    }
    class kp extends kf {
        constructor(t) {
            super(t), this.hudPos = [0, 0, 0], this.netDeletion = new aH(0, 0)
        }
        handleMovementData(t, e) {
            sV(this.pos, t.pos), sV(this.vel, t.vel)
        }
        onRemove() {
            this.visual && this.visual.onRemove()
        }
    }
    class kg {
        constructor(t) {
            this.entity = t, this.skills = new Map, this.skillIdsLearned = [], this.skillIdsActive = [], this.timedCast = new aH, this.timedSkill = void 0, this.timedTarget = void 0, this.pvpBoundModifier = 0, this.gcdEnd = 0
        }
        add(t, e = 0, i = 0, s) {
            let n = this.skills.get(t);
            return n = Object.assign(n || {}, {
                level: void 0 !== s ? s : n ? n.level + 1 : 1,
                logic: dC.get(t),
                cd: new aH(e, i - e)
            }), this.skills.set(t, n), n
        }
        updateSkillsLearned(t) {
            this.skillIdsLearned.length = 0, this.skillIdsLearned.push(...t)
        }
        remove(t) {
            this.skills.delete(t)
        }
        compileActiveSkillIds() {
            this.skillIdsActive.length = 0, this.skills.forEach((t, e) => {
                if (!t.logic.engineOnly)
                    for (let i = 0; i < t.level; ++i) this.skillIdsActive.push(e)
            })
        }
        globalCd(t, e) {
            this.skills.forEach(i => {
                i.logic.auto || i.logic.ignoreGcd || (i.cd.end < t && (i.cd.start = t), i.cd.end < e && (i.cd.end = e), i.cd.duration = i.cd.end - i.cd.start)
            }), this.gcdEnd = e
        }
        clearGlobalCd() {
            this.skills.forEach(t => {
                t.logic.auto || t.logic.ignoreGcd || t.cd.end === this.gcdEnd && (t.cd.end = t.cd.start, t.cd.duration = 0)
            })
        }
        startTimedCast(t, e, i, s) {
            this.timedCast.reset(e, s), this.timedSkill = t, this.timedTarget = i, this.entity.steer[0] = 0, this.entity.steer[1] = 0, this.pvpBoundModifier = dC.get(t.id).pvpBoundsAdd
        }
        interruptTimedCast(t, e) {
            this.timedCast.reset(0, 0), this.timedSkill = void 0, this.timedTarget = void 0, this.pvpBoundModifier = 0, e && this.clearGlobalCd()
        }
        finishTimedCast(t) {
            return this.interruptTimedCast(!1, !1)
        }
        onDeath() {
            this.interruptTimedCast(!0, !1)
        }
        clear() {}
        hasInstantCast(t) {
            return this.entity.buffs.instantCast.size > 0 && Array.from(this.entity.buffs.instantCast).some(e => e.logic.instantCast.has(t))
        }
    }
    let kv = new Map;
    class ky extends kp {
        constructor(t) {
            t.creature && (t.name = t.creature.name), super(t), this.creatureId = t.creature ? t.creature.id : -1, this.stats = new class t extends pY {
                constructor(t) {
                    super(t)
                }
                setStat(t, e) {
                    this.stat.set(t, e), this.entity.statsDirty = !0, 20 == t ? this.entity.setPrestige(e) : 21 == t ? this.entity.setElo(e) : 6 == t || 7 == t ? this.entity.uiFrameDirty = !0 : 19 == t && this.entity.inventory && this.entity.inventory.setSize(e)
                }
                setResource(t, e) {
                    super.setResource(t, e), this.entity.uiFrameDirty = !0
                }
                die() {
                    super.die(), this.entity.uiFrameDirty = !0, this.entity.visual && this.entity.visual.onDeath()
                }
                respawn() {
                    super.respawn(), this.entity.uiFrameDirty = !0, this.entity.visual && this.entity.remakeTransform()
                }
                refreshCombatTimer(t, e) {
                    super.refreshCombatTimer(t, e), this.entity.uiFrameDirty = !0
                }
                onCombatEnd() {
                    super.onCombatEnd(), this.entity.uiFrameDirty = !0
                }
            }(this), this.buffs = new class t extends ka {
                constructor(t) {
                    super(t), this.stickEffects = new Map, this.effects = new Set, this.visualFreeze = 0, this.visualIncapacitate = 0
                }
                addEffectBuff(t, e, i) {
                    if (e.logic.fx.stick && (!e.logic.incapacitated && !e.logic.tags.has(4) || this.immuneCC.size <= 0) && !this.stickEffects.has(t)) {
                        let s = mp(e.logic.fx.stick, this.entity.visual.transform, this.entity.id === as.player.id || e.caster === as.player.id ? 1 : 0, !1);
                        this.stickEffects.set(t, s)
                    }
                    if (this.effects.has(t)) {
                        if (i && this.stickEffects.has(t)) {
                            let n = this.stickEffects.get(t);
                            n.loops = 0, n.fractionNow = 0
                        }
                    } else e.logic.fx.visual && this.entity.visual.skin.id !== e.logic.fx.visual && this.changeEntityVisual(e.logic.fx.visual), e.logic.fx.mount && this.changeEntityMount(e.logic.fx.mount(e), e.logic.fx.mountVisualData(e)), e.logic.fx.color && this.entity.visual.addColor(e.logic.fx.color), e.logic.fx.anim && (this.entity.visual.clearAnims(), this.entity.visual.anim(e.logic.fx.anim, !0, 0)), this.visualFreeze += e.visualFreeze, this.visualIncapacitate += e.visualIncapacitate, this.effects.add(t);
                    e.logic.fx.apply && i && mf(e.logic.fx.apply, this.entity.visual.transform, this.entity.id === as.player.id || e.caster === as.player.id ? 1 : 0, !1)
                }
                removeEffectBuff(t, e, i) {
                    if (this.stickEffects.has(t)) {
                        let s = this.stickEffects.get(t);
                        this.buffs.has(t) || (s.done = !0, this.stickEffects.delete(t))
                    }
                    this.effects.has(t) && (e.fx.visual && this.entity.visual.skin.id === e.fx.visual && this.changeEntityVisual(), e.fx.mount && this.changeEntityMount(), e.fx.color && this.entity.visual.removeColor(e.fx.color), e.fx.anim && this.entity.visual.clearAnims(), this.visualFreeze -= i.visualFreeze, this.visualIncapacitate -= i.visualIncapacitate, this.effects.delete(t))
                }
                setBuff(t, e, i, s, n, a, r, l) {
                    let o = super.setBuff(t, e, i, s, n, a);
                    o.data = l, o.visualFreeze = o.visualIncapacitate = 0, 0 === this.immuneCC.size && (o.logic.fx.frozen && o.visualFreeze++, o.logic.fx.incapacitated && o.visualIncapacitate++), this.entity.buffDisplayDirty = !0, this.entity.visual && this.addEffectBuff(t, o, r)
                }
                removeBuff(t, e) {
                    let i = super.removeBuff(t, e);
                    i && (this.entity.buffDisplayDirty = !0, this.removeEffectBuff(t, i.logic, i), void 0 !== i.logic.fx.endSound && void 0 !== as.player && lz(i.logic.fx.endSound, this.entity.visual.transform, this.entity.id === as.player.id || e === as.player.id ? 1 : 0, 0, 1))
                }
                changeEntityVisual(t) {
                    this.entity.remakeTransform(t), this.stickEffects.forEach((t, e) => {
                        let i = mp(t.info.id, this.entity.visual.transform, t.priority, !1);
                        i.loops = 1, t.done = !0, this.stickEffects.set(e, i)
                    })
                }
                changeEntityMount(t, e) {
                    this.entity.mount && (this.entity.mount.onRemove(), this.entity.mount = void 0, this.entity.updateVisualPosition(0, as.time, as, !0)), t && (this.entity.mount = new k_(this.entity, t, e.colPrim, e.colSec, e.colEyes), void 0 !== e.post && e.post(this.entity.mount), this.entity.updateTransformScale(), this.entity.updateVisualPosition(0, as.time, as, !0), this.entity.updateTransformRotation(.016), this.entity.updateMountRotation(.016))
                }
            }(this), this.skills = new class t extends kg {
                constructor(t) {
                    super(t)
                }
                tick(t, e, i) {
                    if (this.isPlayer) {
                        let s = this.entity.buffs.incapacitated.size > 0;
                        this.skills.forEach((t, e) => {
                            let n = kv.get(e) || kv.set(e, new Map).get(e),
                                a = new Map,
                                r = 0;
                            if (s && !t.logic.ignoreIncapacitated ? r = 9 : 3 !== (r = t.logic.can(this.entity, t.level, this.entity.target, !0)) && 4 !== r || (r = t.logic.can(this.entity, t.level, this.entity.id, !0)), r !== t.status && (t.status = r, n.get("status") !== r && a.set("status", r)), t.cd.done(i.smoothtime)) t.cd.icondone || (t.cd.icondone = !0, void 0 !== n.get("cd") && a.set("cd", void 0), void 0 !== n.get("remaining") && a.set("remaining", void 0));
                            else {
                                t.cd.icondone = !1;
                                let l = Math.round(100 - 100 * t.cd.fraction(i.smoothtime)),
                                    o;
                                t.cd.duration > 1.5 && (o = (o = t.cd.remaining(i.smoothtime)) <= 3 ? Math.ceil(10 * o) / 10 : Math.ceil(o)), n.get("cd") !== l && a.set("cd", l), n.get("remaining") !== o && a.set("remaining", o)
                            }
                            a.size > 0 && ey.update(e => (a.forEach((i, s) => {
                                n.set(s, i), e[t.logic.id][s] = i
                            }), e))
                        })
                    }
                    if (this.timedSkill && this.entity.visual) {
                        let n = this.timedSkill.fx;
                        if (n) {
                            let a = this.entity.visual.animQueue[0],
                                r = this.timedCast.remaining(e);
                            if (n.animCast) {
                                let l = h.get(n.animCast);
                                r -= Math.min(.3, l.duration / 2)
                            }
                            r > 0 ? !n.animChannel || a && n.animChannel === a.id || (this.entity.visual.clearAnims(), this.entity.visual.anim(n.animChannel, !0, 0)) : !n.animCast || a && n.animCast === a.id || (this.entity.visual.clearAnims(), this.entity.visual.anim(n.animCast, !1, 0))
                        }
                    }
                }
                add(t, e = 0, i = 0, s) {
                    super.add(t, e, i, s), this.isPlayer && (this.compileActiveSkillIds(), ey.update(e => (e[t] = {}, e)), this.skills.get(t).logic.id < 100 && eC.update(e => (e.set(t, s), e)))
                }
                remove(t) {
                    this.isPlayer && (this.compileActiveSkillIds(), ey.update(e => (e[t] = void 0, e)), this.skills.get(t) && eC.update(e => (e.delete(t), e))), super.remove(t)
                }
                updateSkillsLearned(t) {
                    super.updateSkillsLearned(t), e4.update(e => {
                        e.clear();
                        for (let i = 0; i < t.length; ++i) {
                            let s = t[i];
                            e.has(s) || e.set(s, yu(t, s))
                        }
                        return e
                    })
                }
                cd(t, e, i) {
                    this.skills.get(t).cd.set(e, i)
                }
                clearSkillInfo() {
                    eC.update(t => (t.clear(), t)), e4.update(t => (t.clear(), t))
                }
                startTimedCast(t, e, i, s) {
                    super.startTimedCast(t, e, i, s), this.entity.uiFrameDirty = !0
                }
                interruptTimedCast(t, e) {
                    super.interruptTimedCast(t, e), this.entity.uiFrameDirty = !0, t && this.entity.visual && this.entity.visual.clearAnims()
                }
            }(this), this.steer = [0, 0], this.speed = 1, this.static = !1, this.jump = 0, this.onGround = !0, this.inWater = 0, this.groundNormal = [0, 0, 0], this.target = 0, this.level = 0, this.faction = 0, this.posLock = [0, 0], this.posLockRadius = 0, this.aabb = cr()
        }
        setAABB() {
            cu(this.aabb, this.pos, this.size, this.size, this.size)
        }
        preFixed(t, e, i) {
            super.preFixed(t, e, i), this.buffs.tick(t, e, i), this.stats.tick(t, e), this.skills.tick(t, e, i)
        }
        getStatBasedMoveSpeed() {
            return Math.max(Math.min(65534, this.stats.getStat(15)))
        }
        postFixed(t, e, i) {
            this.handlePosLock()
        }
        handlePosLock() {
            if (this.posLockRadius > 0) {
                nj(am, om(ah, this.pos), this.posLock);
                let t = nQ(am);
                if (t > this.posLockRadius) {
                    var e, i, s;
                    let n = (e = am, i = this.posLock, s = nG(am, am, this.posLockRadius / t), e[0] = i[0] + s[0], e[1] = i[1] + s[1], e);
                    sW(this.pos, n[0], this.pos[1], n[1])
                }
            }
        }
        hasMovementOverride() {
            return this.buffs.movementOverride.size > 0
        }
        buffMovementOverride(t, e, i) {
            this.hasMovementOverride() && this.buffs.movementOverride.forEach(s => {
                s.logic.movementOverride(t, e, i, this, s)
            })
        }
        combatRangeCheck(t, e) {
            let i = this.pos[0] - t.pos[0],
                s = Math.max(0, Math.abs(this.pos[1] - t.pos[1]) - this.size),
                n = this.pos[2] - t.pos[2];
            return i * i + s * s + n * n < (e + (t.size + this.size)) ** 2
        }
        combatCylinderCheck(t, e, i) {
            return !(this.aabb[1] > t[1] + e || this.aabb[4] < t[1] - e || Math.sqrt((t[0] - this.pos[0]) ** 2 + (t[2] - this.pos[2]) ** 2) > i + this.radius)
        }
        getWorldYBody(t, e, i) {
            return super.getWorldYBody(t, e, i) + this.radius
        }
        horizontalSteer(t, e, i) {
            if (this.stats.alive) {
                this.rot = i;
                let s = nX(ah, e);
                e[1] < 0 && (s[1] *= .5), nG(s, s, t / 20),
                    function t(e, i, s) {
                        let n = Math.sin(s),
                            a = Math.cos(s);
                        return e[0] = i[1] * n + i[0] * a, e[2] = i[1] * a - i[0] * n, e
                    }(this.vel, s, i)
            } else this.vel[0] = 0, this.vel[2] = 0
        }
        setSteer(t, e) {
            this.steer[0] = t, this.steer[1] = e
        }
        setJump(t) {
            this.jump = t
        }
        setRot(t) {
            super.setRot(t)
        }
        setSpeed(t) {
            this.speed = t
        }
        setTarget(t) {
            let e = t > 0 && this.canTarget(as.getEntityById(t));
            return !1 !== e && void 0 !== e ? e.onTarget(this.id) : this.target !== (this.target = 0)
        }
        onTarget(t) {
            return as.getEntityById(t).target = this.id, super.onTarget(t)
        }
        getTargetEntity() {
            return as.getEntityById(this.target)
        }
        canTarget(t) {
            return t
        }
        setFaction(t) {
            this.faction = t
        }
        setLevel(t) {
            this.level = t
        }
        setClass(t) {
            this.class = t
        }
        onRemove() {
            this.stats.clear(), this.buffs.clearTempBuffs(), this.buffs.clearPassiveBuffs(), this.skills.clear(), super.onRemove()
        }
        hostility(t) {
            return (!0 === as.mode.partyBasedHostility ? t.party !== this.party : t.faction !== this.faction) ? 0 === t.type ? 0 === t.stats.stat.get(26) && 0 === this.stats.stat.get(26) ? 0 : 2 : 1 : 0
        }
        canCombatInteract(t) {
            return !0
        }
        canSupportInteract(t) {
            return !0
        }
        die(t, e, i) {}
        setPosLock(t, e, i) {
            this.posLock[0] = ~~t, this.posLock[1] = ~~e, this.posLockRadius = ~~i
        }
        tickWaterCollisions(t) {
            let e = this.inWater;
            this.inWater = 0;
            for (let i = 0; i < t.waterAABB.length; ++i) {
                let s = t.waterAABB[i];
                if (co(s, this.aabb)) return this.inWater = s[4] - this.aabb[1], !e && this.vel[1] < -3 && this.onEnterWater(), !0
            }
            return !1
        }
        onEnterWater() {}
    }
    class k0 extends ky {
        constructor(t) {
            super(t), this.uiFrameDirty = !0, this.uiRange = !0, this.buffDisplayDirty = !0, this.visualPosition = [0, 0, 0], this.speechTimer = new aH(0, 5), this.mount = void 0, this.mountRotAdd = 0, this.namePlateScale = .5, t.creature && (t.skin = t.creature.skin, t.creature.col1 > 0 && (t.colPrim = dA(t.creature.col1, 0)), t.creature.col2 > 0 && (t.colSec = dA(t.creature.col2, 0))), this.skin = t.skin, this.colPrim = t.colPrim, this.colSec = t.colSec, this.colEyes = t.colEyes
        }
        makeTransform(t, e, i, s) {
            this.visual = new k_(this, t || this.skin, e || this.colPrim, i || this.colSec, s || this.colEyes)
        }
        remakeTransform(t, e, i, s) {
            void 0 !== this.visual && (this.visual.onRemove(), this.visual = void 0), this.makeTransform(t, e, i, s), this.updateTransformScale(), this.updateTransformRotation(1), this.updateVisualPosition(0, 0, as, !0)
        }
        onRemove() {
            super.onRemove(), void 0 !== this.mount && this.mount.onRemove()
        }
        updateVisualPosition(t, e, i, s = !1) {
            let n = sK(this.pos, this.visualPosition);
            (s || n > 1e-5) && (sV(this.visualPosition, this.pos), void 0 === this.mount ? sV(this.visual.transform.position, this.visualPosition) : sV(this.mount.transform.position, this.visualPosition))
        }
        updateTransformScale() {
            sH(this.visual.transform.scale, .7 * this.size), void 0 !== this.mount && sH(this.mount.transform.scale, .9 * this.size)
        }
        updateTransformRotation(t) {
            if (this.stats.alive && 0 === this.buffs.visualFreeze) {
                this.updateMountRotation(t);
                let e = od(this.rot + this.mountRotAdd, this.visual.transform.rotation[1]);
                Math.abs(e) > .01 && (this.visual.transform.rotation[1] -= e * Math.min(1, 20 * t))
            }
        }
        updateMountRotation(t) {
            if (void 0 !== this.mount) {
                if (this.onGround && (0 !== this.steer[0] || 0 !== this.steer[1])) {
                    let e = 1.5 * this.steer[0];
                    0 != this.steer[1] && (e *= .5 * this.steer[1]), this.mountRotAdd -= (this.mountRotAdd - e) * Math.min(1, 10 * t)
                }
                this.mount.transform.rotation[1] = this.visual.transform.rotation[1]
            } else this.mountRotAdd = 0
        }
        tickFixed(t, e, i) {
            super.tickFixed(t, e, i)
        }
        postFixed(t, e, i) {
            super.postFixed(t, e, i), void 0 !== this.visual && this.visual.tickFixed(t, e, i), void 0 !== this.mount && this.mount.tickFixed(t, e, i)
        }
        postDelta(t, e, i) {
            super.postDelta(t, e, i), this.updateVisuals(t, e, i), this.updateUiParts(e)
        }
        updateVisuals(t, e, i) {
            this.updateTransformRotation(t), this.updateVisualPosition(t, e, i), void 0 !== this.mount && (this.mount.tick(t, e, i), this.mount.mountPosition(this.visual.transform.position)), this.visual.tick(t, e, i)
        }
        updateUiParts(t) {
            let e = this === as.player,
                i = as.player.target === this.id,
                s = as.party.has(this.name);
            if (i || s) {
                let n = 900 > this.squaredDistance(as.player.pos);
                n != this.uiRange && (this.uiFrameDirty = !0), this.uiRange = n
            }(this.uiFrameDirty || void 0 !== this.skills.timedSkill) && (i && this.hydrateUnitStore(ed), e ? this.hydrateUnitStore(ec) : s && this.hydrateUnitStore(as.party.get(this.name).unitStore)), (this.buffDisplayDirty || e || i) && (i && this.hydrateBuffStore(eu, sO.buffcountUnitframes), e ? this.hydrateBuffStore(e$, sO.buffcountUnitframes) : (this.buffDisplayDirty || i) && s && this.hydrateBuffStore(as.party.get(this.name).buffStore, sO.buffcountParty)), void 0 !== this.speechText && this.speechTimer.done(t) && (this.speechText = void 0)
        }
        setTarget(t) {
            let e = this.target,
                i = super.setTarget(t);
            if (e != this.target && this == as.player && i) {
                let s = as.getEntityById(t);
                s ? (s.hydrateUnitStore(ed, sO.buffcountUnitframes), s.hydrateBuffStore(eu, sO.buffcountUnitframes)) : ed.update(t => (t.visible = !1, t))
            }
            return i
        }
        hydrateUnitStore(t) {
            t.update(t => (t.visible = !0, t.name = this.name, t.alive = this.stats.alive, t.hp = this.stats.getResource(6), t.hpMax = this.stats.getStat(6), t.mp = this.stats.getResource(7), t.mpMax = this.stats.getStat(7), t.level = this.level, t.class = this.class, t.id = this.id, t.clan = this.clan, t.faction = this.faction, t.party = this.party, t.role = this.partyrole, t.type = this.type, t.combat = !this.stats.combatTimer.done(as.time), t.range = this.uiRange, t.powertype = 2 === this.faction && !!this.powertypeId, t.timedSkill = this.skills.timedSkill, t.timedCast = this.skills.timedCast, t)), this.uiFrameDirty = !1
        }
        hydrateBuffStore(t, e) {
            t.update(t => kb(t, this.buffs, e)), this.buffDisplayDirty = !1
        }
        speech(t, e) {
            this.speechText = t, this.speechStyle = e, this.speechTimer.reset(as.time)
        }
    }
    let kb = (t, e, i) => {
            let s = [];
            e.buffs.forEach(t => {
                t.forEach(t => {
                    t.logic.passive || void 0 === t.logic.icon || sO.buffsHideIrrelevant && t.caster !== as.player.id && (e.entity !== as.player || 1 != t.logic.type) || t.logic.unique && 0 !== s.reduce((e, i) => e + (i.id === t.id ? 1 : 0), 0) || s.push(t)
                })
            });
            let n = s.sort((t, e) => e.time - t.time).sort((t, e) => t.type - e.type).slice(0, i);
            if (t.length < n.length)
                for (; t.length < n.length;) t.push(k1());
            else if (t.length > n.length)
                for (; t.length > n.length;) k9(t.pop());
            return n.forEach((e, i) => {
                k3(as.smoothtime, e, t[i])
            }), t
        },
        kx = 0,
        kw = [],
        k1 = () => kw.pop() || {
            id: kx++,
            icon: "",
            type: 1,
            time: 0,
            duration: 10,
            stacks: 0
        },
        k9 = t => {
            kw.push(t)
        },
        k3 = (t, e, i) => {
            i.icon = `/assets/ui/${e.logic.icon}.${rF}?v=5699699`, i.type = e.logic.type, i.time = Math.min(e.timer.duration, e.timer.passed(t)), i.duration = e.timer.duration, i.stacks = e.uniqueInstances > 1 ? e.uniqueInstances : e.stacks
        };
    class kk extends k0 {
        constructor(t) {
            super(t), this.static = !0
        }
    }
    class k2 extends kk {
        constructor(t) {
            super(t), this.interactions = t.interactions, this.setDialogue(this.interactions[0].text, this.interactions[0].choices), this.remakeTransform()
        }
        interact(t) {
            this.createInteraction()
        }
        createInteraction() {
            es.set({
                title: this.name,
                text: this.text,
                choices: this.choices
            })
        }
        setDialogue(t, e) {
            this.text = t, this.choices = e
        }
    }
    class k4 extends k2 {
        constructor(t) {
            super({
                type: 6,
                size: 1.2,
                ...t
            })
        }
    }
    class kC extends k2 {
        constructor(t) {
            super({
                type: 2,
                size: 1.2,
                ...t
            })
        }
    }
    let kS = (t, e) => {
        let i = "",
            s = e + (t.length - e);
        for (; e < s;) {
            let n = t[e++];
            if (n < 128) i += String.fromCharCode(n);
            else if (n > 191 && n < 224) {
                let a = t[e++];
                i += String.fromCharCode((31 & n) << 6 | 63 & a)
            } else if (n > 239 && n < 365) {
                let r = ((7 & n) << 18 | (63 & t[e++]) << 12 | (63 & t[e++]) << 6 | 63 & t[e++]) - 65536;
                i += String.fromCharCode(55296 + (r >> 10)), i += String.fromCharCode(56320 + (1023 & r))
            } else {
                let l = t[e++],
                    o = t[e++];
                i += String.fromCharCode((15 & n) << 12 | (63 & l) << 6 | 63 & o)
            }
        }
        return i
    };
    class k7 extends kp {
        constructor(t) {
            super({
                type: 3,
                ...t
            }), this.partytimeout = 0, this.party = 0, this.droptype = "", this.tier = 0, this.quality = 0
        }
        partyTimeoutCheck(t) {
            return 0 === this.party || t.id === this.party || t.party === this.party || as.time > this.partytimeout
        }
        canBePickedUpBy(t, e = 30) {
            return this.partyTimeoutCheck(t) && t.stats.alive && t.squaredDistance(this.pos) < e
        }
    }
    let kE = {
        0: {
            size: 3,
            stationary: !0,
            impatience: 2,
            exp: 2,
            aggroRange: 42,
            drProtection: !0,
            statfactor: {
                0: 40,
                10: 40,
                11: 40,
                1: 220,
                15: 4
            },
            skills: [0, 3]
        },
        1: {
            size: 2,
            stationary: !0,
            impatience: 2,
            exp: 2,
            aggroRange: 42,
            drProtection: !0,
            statfactor: {
                10: 30,
                11: 30,
                0: 30,
                1: 120,
                15: 5
            },
            skills: [0, 2, 3, 33]
        },
        2: {
            size: .9,
            impatience: 3,
            skills: [0]
        },
        3: {
            size: 1.1,
            exp: 1.1,
            impatience: 3,
            skills: [0]
        },
        4: {
            size: 1.2,
            exp: 1.1,
            impatience: 3,
            skills: [0]
        },
        5: {
            size: 1,
            exp: 1.1,
            impatience: 3,
            skills: [0]
        },
        6: {
            size: 1,
            exp: 1.1,
            impatience: 3,
            statfactor: {
                10: .35,
                11: .35
            },
            skills: [5]
        },
        7: {
            size: 1,
            exp: 2,
            impatience: 3,
            statfactor: {
                10: 2,
                11: 2,
                6: 1.5,
                15: .6
            },
            skills: [0]
        },
        8: {
            size: 1,
            exp: 1.5,
            impatience: 3,
            statfactor: {
                6: 1.5,
                15: 1.2
            },
            skills: [0]
        },
        9: {
            size: 1,
            exp: 1,
            impatience: 3,
            statfactor: {
                6: .8,
                11: .35,
                10: .35,
                15: 1.2
            },
            skills: [5]
        },
        10: {
            size: 1.3,
            exp: 2,
            impatience: 3,
            statfactor: {
                6: 3,
                15: 1.3
            },
            skills: [0]
        },
        100: {
            size: 1,
            exp: 0,
            impatience: 3,
            statfactor: {
                6: 100,
                8: 100
            }
        },
        11: {
            size: 3,
            exp: 0,
            impatience: 3,
            statfactor: {
                6: 3,
                7: 3
            }
        },
        12: {
            size: 10,
            exp: 0,
            impatience: 0,
            stationary: !0
        }
    };
    class k6 extends k0 {
        constructor(t) {
            super({
                type: 7,
                size: 1,
                ...t
            }), this.static = !0, this.class = 5, this.behavior = kE[100]
        }
    }
    class kP {
        constructor(t) {
            this.entity = t, this.slots = new Map, this.gold = 0, this.medals = 0, this.setSize(0)
        }
        tickFixed(t, e, i) {}
        setSize(t) {
            this.size = Math.min(100, t)
        }
        setGold(t) {
            this.gold = t
        }
        setMedals(t) {
            this.medals = t
        }
        setItem(t, e) {
            let i = new by(e);
            return this.slots.set(t, i), i
        }
        removeItem(t) {
            let e = this.slots.get(t);
            return this.slots.delete(t), e
        }
        async hydrateItems(t = !1) {
            let e = [],
                i = [];
            if (this.slots.forEach((t, s) => {
                    t.dirty && (t.dirty = !1, e.push(t.dbid), i.push(s))
                }), e.length) {
                let s = await this.fetchData(e);
                this.compareData(s, i, 0), this.postHydrate(i, t)
            } else t && this.postHydrate(i, t)
        }
        hydrate(t) {
            this.slots.has(t.slot) ? this.slots.get(t.slot).hydrate(t) : console.error("received hydration of unknown item")
        }
        postHydrate(t) {}
        compareData(t, e, i) {
            t.forEach(t => {
                null !== t.slot && (this.hydrate(t), e = e.filter(e => e !== t.slot))
            }), e.forEach(t => this.removeItem(t, i))
        }
        findFirstItemOfType(t, e) {
            for (let i of this.slots)
                if (i[1].type == t && i[1].tier == e) return i[1]
        }
        findFirstSlotOfType(t, e) {
            let i = -1,
                s = 0;
            for (let n of this.slots) {
                let a = n[0],
                    r = n[1];
                r.type == t && r.tier == e && a > i && r.bound >= s && (i = a, s = r.bound)
            }
            return i >= 0 ? i : void 0
        }
        findByDbid(t) {
            for (let e of this.slots)
                if (e[1] && e[1].dbid === t) return e;
            throw "Item not found"
        }
        findFirstEmpty() {
            for (let t = 0; t < this.size; ++t)
                if (!this.slots.has(t)) return t
        }
        findFirstUnmaxedStackableOfType(t, e) {
            for (let i of this.slots)
                if (i[1].type == t && i[1].tier == e && i[1].stacks < 50) return i[1]
        }
    }
    let kM;
    class k5 extends k0 {
        constructor(t) {
            super({
                type: 0,
                size: .9,
                ...t
            }), this.exp = 0, this.party = 0, this.partyrole = 0, this.prestige = 0, this.prestigeRank = 0, this.elo = 0, this.eloRank = 0, this.clan = void 0, this.clanRole = 0
        }
        tickMovement(t, e, i, s, n) {
            this.tickVelocity(t, e, i, s, n), this.tickTerrainCollisions(t, e, i, s, n), this.tickPropCollisions(t, e, i, s), this.tickWaterCollisions(as), this.clampWorldPos()
        }
        tickVelocity(t, e, i, s, n) {
            this.inWater > this.radius ? (this.onGround && (this.vel[1] = Math.max(0, this.vel[1])), this.inWater > this.radius + .1 || this.vel[1] < 0 ? this.vel[1] = Math.min(s > 0 ? 3 : 1, Math.max(this.vel[1] + (s ? 10 : 5) * t, -5)) : this.vel[1] = s > 0 ? 7 : 0, this.horizontalSteer(.5 * n, e, i)) : this.onGround ? (this.stats.alive && s > 0 && n > 0 ? (this.vel[1] = 9, this.onGround = !1) : this.vel[1] = -25 * t, this.horizontalSteer(n, e, i)) : (this.vel[1] = Math.max(-60, this.vel[1] - 25 * t), this.stats.alive && 0 === this.vel[0] && 0 === this.vel[2] && this.horizontalSteer(.5 * n, e, i))
        }
        tickTerrainCollisions(t, e, i, s, n) {
            let a = as.clampV3(sX([0, 0, 0], this.pos, this.vel, t));
            this.onGround || sH(this.groundNormal, 0);
            let r = this.getWorldYBody(as, a[0], a[2]);
            if (0 !== this.vel[0] || 0 !== this.vel[2] || this.vel[1] > 0 || !this.onGround) {
                let l = as.getNormal(a[0], a[2]);
                if (r >= a[1] || !this.inWater && this.onGround && l[1] > .65 && a[1] - r < .05) {
                    a[1] = r;
                    let o = this.onGround;
                    if (this.onGround = l[1] > .65, this.onGround && sV(this.groundNormal, l), this.onGround) !o && this.vel[1] < 0 && this.onFallLanding(-this.vel[1]);
                    else {
                        o && ((l = sV(ar, l))[1] = 0, sZ(l, l));
                        let c = nt(this.vel, l),
                            d = sQ(ar, l, c);
                        sY(this.vel, this.vel, d), sX(a, this.pos, this.vel, t)
                    }
                } else this.onGround = !1;
                sV(this.pos, a)
            } else this.onGround = a[1] < r, sV(this.pos, a)
        }
        tickPropCollisions(t, e, i, s) {
            this.setAABB();
            let n = as.triangleGrid.queryAABB(this.aabb);
            for (let a = 0; a < n.length; ++a) {
                let r = n[a],
                    l = oh(ac, r[0], r[1], r[2], this.pos),
                    o = sK(this.pos, ac);
                if (o < this.radius * this.radius && 0 > nt(this.vel, r[3])) {
                    let c = sY(ar, this.pos, l);
                    sZ(c, c);
                    let d = nt(this.vel, c),
                        u = this.radius - Math.sqrt(o);
                    if (sV(this.groundNormal, c), c[1] > .65) {
                        this.onGround || (this.onGround = !0, this.onFallLanding(-this.vel[1]));
                        let $ = sQ(al, an, d);
                        sY(this.vel, this.vel, $), sX(this.pos, this.pos, an, u)
                    } else {
                        let h = sQ(al, c, d);
                        sY(this.vel, this.vel, h), sX(this.pos, this.pos, c, u)
                    }
                }
            }
        }
        setExp(t) {
            this.exp = t
        }
        setParty(t, e) {
            this.party = t, this.partyrole = e
        }
        setPrestige(t) {
            return t !== this.prestige && (this.prestige = t, this.prestigeRank = b7(t), !0)
        }
        setElo(t) {
            return t !== this.elo && (this.elo = t, this.eloRank = rA(t), !0)
        }
        setClan(t, e = 0) {
            this.clan = t, this.clanRole = e
        }
        getNearbyPartyMembers(t) {
            let e = [];
            return this.stats.alive && e.push(this), this.party > 0 && as.entities.type[0].forEach(i => {
                i.party == this.party && i != this && i.stats.alive && 1e3 > sK(t, i.pos) && e.push(i)
            }), e
        }
        calculatePartyItemFind(t) {
            let e = 0;
            return t.forEach(t => {
                e += t.stats.getStat(18)
            }), e / Math.max(1, t.length) / 100
        }
        canCombatInteract(t) {
            return 0 === t.type ? !as.mode.pvpprotect || 2 > this.hostility(t) || !(0 === this.stats.stat.get(26) || 0 === t.stats.stat.get(26)) && Math.abs(this.stats.stat.get(26) - t.stats.stat.get(26)) <= 5 + Math.max(this.skills.pvpBoundModifier, t.skills.pvpBoundModifier) : 1 !== t.type || t.stats.stat.get(26) > 0
        }
        canSupportInteract(t) {
            return 0 == this.hostility(t) && (!as.mode.pvpprotect || 0 !== t.type || 5 >= Math.abs(this.stats.stat.get(26) - t.stats.stat.get(26)))
        }
        onFallLanding(t) {}
    }
    let kD = [1, 2, 3, 4];
    class kT extends k5 {
        constructor(t) {
            t.skin = 0, super(t)
        }
        tickFixed(t, e, i) {
            super.tickFixed(t, e, i), this.tickMovement(t, this.steer, this.rot, this.jump, this.speed)
        }
        setClass(t) {
            t !== this.class && (super.setClass(t), this.skin = kD[this.class], this.remakeTransform())
        }
        makeTransform(t, e) {
            super.makeTransform(t, e), this.prestige > 0 && this.setPrestige(this.prestige, !0), this.level >= 10 && this.setLevel(this.level), this.elo > 1500 && this.setElo(this.elo, !0)
        }
        setPrestige(t, e) {
            if (super.setPrestige(t) || e) {
                if (!this.visual) return;
                let i = Math.min(this.prestigeRank, 10),
                    s = this.prestigeRank - 11;
                i < 1 ? (this.visual.setCrown(!1), this.visual.setHeadgear(!1)) : (this.visual.setHeadgear(s < 0 ? dI[Math.min(4, i - 1)] : dN.darkgold), i > 5 ? this.visual.setCrown(dI[i - 6]) : this.visual.setCrown(!1)), s < 0 ? this.visual.setGem(!1) : this.visual.setGem(dU[s], s > 0 ? 1 : .8)
            }
        }
        setElo(t, e) {
            if (super.setElo(t) || e) {
                if (void 0 === this.visual) return;
                let i = rA(t);
                this.visual.setShoulders(dz[Math.min(i, 1)], .65 + .08 * i, i > 0 && dz[i])
            }
        }
        setLevel(t) {
            super.setLevel(t), void 0 !== this.visual && (t >= 15 ? this.visual.setCape(0 === this.faction ? dN.vanguard : dN.bloodlust, t >= 25 ? 1 : .5) : this.visual.setCape(!1))
        }
        setParty(t, e) {
            this.uiFrameDirty = !0, this.buffDisplayDirty = !0, super.setParty(t, e)
        }
        onEnterWater() {
            this.visual.playSound(130, !1), this.visual.watersplash(94)
        }
    }
    let kA = t => 1 + .21 * (t - 1);
    class k8 extends kT {
        constructor(t) {
            super(t), as.setPlayer(this), this.skills.isPlayer = !0, this.skills.clearSkillInfo(), this.inventory = new class t extends kP {
                constructor(t) {
                    super(t), this.dirty = !1
                }
                tickFixed(t, e, i) {
                    super.tickFixed(t, e, i), this.dirty && (this.hydrateItems(), this.dirty = !1)
                }
                setGold(t, e, i) {
                    super.setGold(t), bv(t, e, i, "$g"), e_.set(t)
                }
                setMedals(t, e, i) {
                    super.setMedals(t), bv(t, e, i, "$m"), ef.set(t)
                }
                setItem(t, e, i) {
                    super.setItem(t, e).reason = i, this.dirty = !0
                }
                removeItem(t, e) {
                    bg(super.removeItem(t), e), void 0 !== kM[t] && (kM[t].set(void 0), this.dirty = !0, this.updateInventoryCounts())
                }
                hydrate(t) {
                    t.store = kM[t.slot], super.hydrate(t)
                }
                postHydrate(t) {
                    super.postHydrate(t), this.updateInventoryCounts()
                }
                updateInventoryCounts() {
                    let t = {};
                    this.slots.forEach(e => {
                        let i = e.type + e.tier;
                        t[i] = (t[i] || 0) + (e.stacks ? e.stacks : 1)
                    }), ev.set(t)
                }
                async fetchData(t) {
                    let e = await fetch("/api/item/get", {
                            method: "POST",
                            body: JSON.stringify({
                                ids: t
                            })
                        }),
                        i = await e.json();
                    if (!i.fail) return i;
                    console.error(i)
                }
                setSize(t) {
                    super.setSize(t), eg.update(t => {
                        for (let e = 111; e >= 0; --e) e >= 101 ? t[e] || (t[e] = tX(void 0)) : e >= this.size ? t[e] && delete t[e] : t[e] || (t[e] = tX(void 0));
                        return kM = t, t
                    })
                }
            }(this), this.partyInfoUpdateTimer = new aH(0, 1), this.heartBeatTimer = new aH(0, 1), this.lastNetRot = this.rot, this.inputTicksPassed = 0, this.inputTicksSinceLastPosUpdate = 0, this.inputTicksSinceLastRotUpdate = 0, o0[1] = .7
        }
        makeTransform(t, e) {
            super.makeTransform(t, e), this.visual.soundPrio = 1
        }
        tickFixed(t, e, i) {
            super.tickFixed(t, e, i), this.inventory.tickFixed(t, e, i)
        }
        preFixed(t, e, i) {
            super.preFixed(t, e, i), (ob.turnright.down || ob.turnleft.down) && (o0[0] = oa(o0[0] + 3 * sO.mouseSensitivity * t * ((ob.turnleft.down ? 1 : 0) - (ob.turnright.down ? 1 : 0)))), this.handleInput(t, e, i)
        }
        postFixed(t, e, i) {
            super.postFixed(t, e, i)
        }
        handleInput(t, e, i) {
            this.inputTicksPassed++;
            let s = !1,
                n = !1,
                a = !1,
                r = !1,
                l = !1,
                o = !1,
                c = this.steer[0],
                d = this.steer[1],
                u = this.jump,
                $ = this.rot,
                h = c,
                m = d,
                _ = u,
                f = $;
            this.hasMovementOverride() ? (this.buffMovementOverride(t, e, i), c = this.steer[0], d = this.steer[1], u = this.jump, $ = this.rot) : (c = (ob.left.down ? 1 : 0) + (ob.right.down ? -1 : 0), d = (ob.fwd.down || ob.lmb.down && ob.rmb.down ? 1 : 0) + (ob.back.down ? -1 : 0), u = ob.jump.down ? 1 : 0, $ = sO.lockedcamera && ob.lmb.down || ob.rmb.down || ob.turnleft.down || ob.turnright.down ? o0[0] : this.rot), c === h && d === m || (n = c !== h, a = d !== m, this.setSteer(c, d)), u !== _ && (this.setJump(u), l = !0);
            let p = od($, this.lastNetRot);
            this.inputTicksSinceLastRotUpdate++, $ !== f && this.setRot($), $ !== this.lastNetRot && ((0 !== this.steer[0] || 0 !== this.steer[1]) && Math.abs(p) > .1 || this.inputTicksSinceLastRotUpdate > 10 || a || n || Math.abs(p) > .2) && (this.lastNetRot = f, s = !0);
            let g = this.getStatBasedMoveSpeed();
            g != this.speed && (this.setSpeed(g), r = !0), this.inputTicksSinceLastPosUpdate++, this.inputTicksSinceLastPosUpdate > 600 ? o = !0 : this.inputTicksSinceLastPosUpdate > 40 ? 0 === this.steer[0] && 0 === this.steer[1] || (o = !0) : this.inputTicksSinceLastPosUpdate > 20 && (0 !== this.steer[0] || 0 !== this.steer[1]) && (s || n || a) && (o = !0), (s || n || a || r || l || o) && this.sendInput(s, n, a, r, l, o)
        }
        sendInput(t, e, i, s, n, a) {
            let r = {
                uint8s: [],
                int8s: [],
                uint16s: [],
                doubles: []
            };
            r.uint8s.push(Math.min(254, this.inputTicksPassed)), n && r.uint8s.push(this.jump), e && !i ? r.int8s.push(this.steer[0]) : (e || i) && r.int8s.push(this.steer[0], this.steer[1]), t && (this.inputTicksSinceLastRotUpdate = 0, r.doubles.push(this.rot)), a && (this.inputTicksSinceLastPosUpdate = 0, r.doubles.push(this.pos[0], this.pos[1], this.pos[2])), s && r.uint16s.push(this.speed), rp(aF.clientPlayerInput.packData(r)), this.inputTicksPassed = 0
        }
        handleMovementData(t) {
            sV(this.pos, t.pos), sV(this.vel, t.vel)
        }
        updateCharPanel() {
            (sO.charpanelOpen || sO.skillmenuOpen) && this.statsDirty && (this.statsDirty = !1, eI.update(t => (Array.from(this.stats.stat).forEach(e => t[e[0]] = e[1]), t)))
        }
        updatePartyInfo(t) {
            if (this.partyInfoUpdateTimer.done(t)) {
                this.partyInfoUpdateTimer.reset(t);
                let e = this.getNearbyPartyMembers(this.pos),
                    i = kA(e.length);
                tK.update(t => (t.nearby = e.length, t.exprate = Math.round(100 * i), t.itemfind = Math.round(100 * i + 100 * this.calculatePartyItemFind(e)), t))
            }
        }
        handleCamera(t) {
            if (at.rotation[0] = aL(.7 * o0[1], -1.5, 1.5), !(ob.lmb.down || ob.rmb.down || 0 === this.steer[0] && 0 === this.steer[1])) {
                let e = od(this.rot, o0[0]) * Math.min(1, 2 * t);
                0 !== e && (Math.abs(e) > .03 * t ? (e = e > 0 ? Math.max(e, Math.min(1, .6 * t)) : Math.min(e, Math.max(1, -.6 * t)), o0[0] -= e) : o0[0] = this.rot)
            }
            at.rotation[1] = o0[0], nE(at, !1), sW(nZ.transform.position, 0, 1, -sO.cameraZoom), nZ.updateGlobalWorldPos(), at.position[1] += Math.max(0, as.getHeight(aL(nZ.worldPosition[0], 0, as.bounds), aL(nZ.worldPosition[2], 0, as.bounds)) - nZ.worldPosition[1]) + 2 * Math.tan(nZ.fov * Math.PI / 180 / 2) * nZ.near, nE(at, !1), nZ.updateMatrixWorldCamView(!1)
        }
        handleHeartbeat(t) {
            let e = this.stats.getResource(6) / (.5 * this.stats.getStat(6));
            this.heartBeatTimer.done(t) && e > 0 && e < 1 && (e = (Math.max(0, Math.min(1, e)) + .5) / 1.5, lL(103), this.heartBeatTimer.reset(t, e))
        }
        postDelta(t, e, i) {
            this.updateCharPanel(), this.updatePartyInfo(e), super.postDelta(t, e, i), sV(at.position, this.mount ? this.mount.transform.position : this.visual.transform.position), this.handleCamera(t), this.handleHeartbeat(e)
        }
        updateTransformRotation(t) {
            this.stats.alive && 0 === this.buffs.visualFreeze && (this.updateMountRotation(t), this.buffs.movementOverride.size || !ob.rmb.down ? this.visual.transform.rotation[1] = this.rot : this.visual.transform.rotation[1] = o0[0], this.visual.transform.rotation[1] += this.mountRotAdd)
        }
        setLevel(t) {
            super.setLevel(t), this.uiFrameDirty = !0
        }
        onRemove() {
            super.onRemove(), as.removePlayer(this)
        }
        setExp(t) {
            super.setExp(t), e0.update(e => (e.current = t, e.max = c_(this.level), e))
        }
        setClan(t, e = 0) {
            super.setClan(t, e), ez.set(t)
        }
        setRot(t, e = !1) {
            super.setRot(t), e && (o0[0] = t)
        }
    }
    class kR extends k2 {
        constructor(t) {
            super({
                type: 4,
                size: 1.2,
                ...t
            })
        }
    }
    class kF extends k0 {
        constructor(t) {
            let e = p.get(t.creature.id),
                i = kE[e.behavior];
            super({
                type: 1,
                size: t.creature.scale / 100 * i.size,
                ...t
            }), this.behavior = i, this.powertypeId = e.power, this.powertype = [{
                name: "Solo",
                respawn: 60,
                spawnchance: .5,
                expfactor: .5,
                power: .4
            }, {
                name: "Party",
                respawn: 30,
                spawnchance: .5,
                expfactor: 1,
                power: 1
            }, {
                name: "Minor boss",
                respawn: 700,
                spawnchance: .4,
                expfactor: 6,
                power: 8
            }, {
                name: "Major boss",
                respawn: 900,
                spawnchance: .3,
                expfactor: 12,
                power: 14
            }, {
                name: "World boss",
                respawn: 0,
                spawnchance: 0,
                expfactor: 0,
                power: 1,
                customstats: !0
            }][e.power], this.stationary = this.behavior.stationary || !1, this.groundHeight = 0
        }
        tickFixed(t, e, i) {
            if (this.horizontalSteer(this.speed, this.steer, this.rot), super.tickFixed(t, e, i), this.stats.alive) {
                sX(this.pos, this.pos, this.vel, t), this.groundHeight = i.getHeight(this.pos[0], this.pos[2]);
                let s = this.pos[1] - this.radius,
                    n = s + 1,
                    a = n - s;
                cl[0] = cl[3] = this.pos[0], cl[5] = cl[2] = this.pos[2], cl[4] = n, cl[1] = s;
                let r = i.triangleGrid.queryAABB(cl);
                if (r.length > 0) {
                    kn(ks, this.pos[0], n, this.pos[2], 0, -a, 0);
                    for (let l = 0; l < r.length; ++l) {
                        let o = r[l],
                            c = op(o[0], o[1], o[2], ks.origin, ks.dir, !1);
                        if (c < 1 / 0) {
                            let d = n - c * a;
                            d > this.groundHeight && (this.groundHeight = d)
                        }
                    }
                }
            }
            this.setAABB(), this.tickWaterCollisions(i), this.inWater > this.radius || (this.pos[1] -= 10 * t), this.pos[1] - this.radius <= this.groundHeight && (this.pos[1] = this.groundHeight + this.radius)
        }
    }
    class kN extends kp {
        constructor(t) {
            super({
                type: 10,
                ...t
            })
        }
    }
    class kI extends k2 {
        constructor(t) {
            super({
                type: 9,
                size: 1.2,
                ...t
            })
        }
    }
    class kU extends k2 {
        constructor(t) {
            super({
                type: 5,
                size: 1.5,
                ...t
            })
        }
    }
    class kz extends k2 {
        constructor(t) {
            super({
                type: 8,
                size: 1.2,
                ...t
            })
        }
    }
    let kO = new Map([
            [6, class t extends k4 {
                constructor(t) {
                    super({
                        ...t,
                        ...rC.npcs.blacksmith
                    })
                }
            }],
            [2, class t extends kC {
                constructor(t) {
                    super({
                        ...t,
                        ...rC.npcs.conjurer
                    })
                }
                interact(t) {
                    let e = kS(t, 1).split("#");
                    "" !== e[0] ? this.setDialogue(this.interactions[0].text, Array.from(e, t => {
                        let e = t.split("~");
                        return this.interactions[0].choices[0].replace("$1", e[0]) + (e[1] > 0 ? ` (Lv. ${e[1]}+)` : "")
                    })) : this.setDialogue(this.interactions[0].text, []), super.interact(t)
                }
            }],
            [7, class t extends k6 {
                constructor(t) {
                    super(t), this.remakeTransform()
                }
            }],
            [4, class t extends kR {
                constructor(t) {
                    super({
                        ...t,
                        ...rC.npcs.merchant
                    })
                }
            }],
            [0, kT],
            [9, class t extends kI {
                constructor(t) {
                    super({
                        ...t,
                        ...rC.npcs.sage
                    })
                }
                interact(t) {
                    this.interactions[0].choices[0] = this.interactions[0].choices[0].replace("$1", 10 * as.player.level), super.interact(t)
                }
            }],
            [5, class t extends kU {
                constructor(t) {
                    super({
                        ...t,
                        ...rC.npcs.stash
                    })
                }
            }],
            [8, class t extends kz {
                constructor(t) {
                    super({
                        ...t,
                        ...rC.npcs.trader
                    });
                    let e = v.get(t.creature.id);
                    this.items = [], y.forEach(t => {
                        if (t.shop === e.shop) {
                            let i = new by,
                                s = tX();
                            i.hydrate({
                                type: t.type,
                                tier: t.tier,
                                stacks: 0 === t.stacks ? void 0 : t.stacks,
                                store: s
                            }), i.buyid = t.id, this.items.push([i, s])
                        }
                    })
                }
            }],
            [3, class t extends k7 {
                constructor(t) {
                    super(t), this.visual = {
                        transform: hZ(1561, !1, !1, !1, !0)
                    }, this.visual.transform.data.multi.needsUpdate = !1, this.setSize(.2), this.visual.transform.visible = !1, this.uiTimeout = 0, this.dirty = !1, this.hasInfo = !1, this.hasPos = !1, this.hasRot = !1, this.color = "misc"
                }
                postDelta(t, e, i) {
                    if (this.visual.transform.visible && this.dirty) {
                        let s = i.getChunkFromWorld(this.pos[0], this.pos[2]);
                        void 0 !== s && s.deserialized && (this.pos[1] = i.getHeight(this.pos[0], this.pos[2]) + .1 * Math.random() + .1, this.visual.transform.rotation[1] = Math.random() * Math.PI * 2, ol(this.visual.transform.rotation, i.getNormal(this.pos[0], this.pos[2])), sV(this.visual.transform.position, this.pos), this.visual.transform.data.multi.needsUpdate = !0, nE(this.visual.transform, !1), this.dirty = !1)
                    }
                }
                setDropInfo(t, e, i, s, n) {
                    let a, r;
                    this.hasInfo = !0, this.party = s, this.partytimeout = n, this.droptype = d6[t], this.tier = e, this.quality = i, this.stackable = !1, this.lootquality = i, "gold" == this.droptype ? (this.name = this.tier + "c", this.setSize(.1), a = "gold", this.color = "gold", this.quality = 100) : ((r = dL[a = this.droptype + this.tier]) && (this.name = rS(this.droptype, this.tier)), "misc" !== this.droptype && "rune" !== this.droptype && "book" !== this.droptype ? (this.color = dF(i)[1], sO.itemQualityPercent && (this.name += ` ${this.quality}%`)) : (this.color = this.droptype, this.quality = 100, this.stackable = !0, "rune" === this.droptype && (this.lootquality = 90)));
                    let l = r && r.art || a;
                    n9(this.visual.transform.data.uvshift, l0[l]), sW(this.visual.transform.scale, 20 * l0[l][0], 1, 20 * l0[l][1]), this.visual.transform.data.shine[0] = 6.1 * Math.random(), this.dirty = !0, this.visual.transform.visible = !0
                }
                onRemove() {
                    this.visual.transform.data.multi.remove(this.visual.transform), ob.shift.down && (uL.add(this), this.uiTimeout = 5 * Math.round(as.time / 5) + 10)
                }
            }],
            [1, class t extends kF {
                constructor(t) {
                    super(t), this.remakeTransform()
                }
            }],
            [10, class t extends kN {
                constructor(t) {
                    super(t), this.meshId = 0, this.scale = 0, this.effects = [], this.dirty = !1, this.rot = 3.14 * Math.random()
                }
                postDelta(t, e, i) {
                    if (this.dirty) {
                        sV(this.mesh.position, this.pos), this.mesh.rotation[1] = this.rot, sH(this.mesh.scale, this.scale), this.mesh.matrixNeedsUpdate = !0, nE(this.mesh, !0);
                        for (let s = 0; s < this.effects.length; ++s) {
                            let n = this.effects[s];
                            nE(n.transform, !0)
                        }
                        this.mesh.data.multi && (this.mesh.data.multi.needsUpdate = !0), this.dirty = !1
                    }
                }
                setNodeInfo(t, e) {
                    t !== this.meshId && (this.meshId > 0 && this.removeMesh(), this.meshId = t, this.makeMesh(), this.dirty = !0), this.scale !== e && (this.scale = e, this.dirty = !0)
                }
                makeMesh() {
                    let t = d.get(this.meshId);
                    t.geometry > 0 ? this.mesh = hZ(this.meshId, !0, !0, !1, !0) : this.mesh = nT();
                    for (let e = 0; e < t.effects.length; ++e) {
                        let i = t.effects[e],
                            s = nT();
                        sV(s.position, i.pos), sV(s.scale, i.scale), sV(s.rotation, i.rot), nC(s, this.mesh);
                        let n = mp(i.id, s, 0, !0);
                        this.effects.push(n)
                    }
                }
                removeMesh() {
                    this.mesh.data.multi ? this.mesh.data.multi.remove(this.mesh) : nA(this.mesh), this.mesh = void 0;
                    for (let t = 0; t < this.effects.length; ++t) this.effects[t].done = !0;
                    this.effects.length = 0
                }
                onRemove() {
                    this.removeMesh()
                }
            }]
        ]),
        kL = (t, e) => 0 == t ? e == as.playerId ? k8 : kT : kO.get(t),
        kB = [-0, -1, -0];
    class kq {
        constructor(t) {
            this.bounds = 0, this.chunkAmount = 0, this.entities = {
                array: [],
                map: new Map,
                type: {}
            }, kO.forEach((t, e) => this.entities.type[e] = []), this.chunksMap = new Map, this.chunksArray = [], this.unloadedChunks = new Set, this.currentlyLoadingChunks = new Set, this.finishedLoadingChunks = new Set, this.time = this.accum = -0, this.timestep = 1 / 60, this.tickId = 0, this.data = void 0, this.triangleGrid = void 0, this.waterAABB = [], this.setOctrees()
        }
        load(t, e) {
            this.destroy(), this.id = t, this.file = e, b.forEach(t => {
                t.name === e && (this.data = t)
            }), this.parse(!1)
        }
        tickIdToTimestamp(t) {
            return t * this.timestep
        }
        setTimeFromTickId(t) {
            return this.tickId = t, this.time = this.tickIdToTimestamp(t), this.tickId
        }
        tickDelta(t, e) {
            let i = this.time + e;
            for (let s = 0, n = this.chunksArray.length; s < n; ++s) this.chunksArray[s].tickDelta(t, i, this);
            for (let a = this.entities.array.length - 1; a >= 0; --a) this.entities.array[a].preDelta(t, i, this), this.entities.array[a].tickDelta(t, i, this), this.entities.array[a].postDelta(t, i, this)
        }
        tickFixed(t, e = 1) {
            for (let i = this.entities.array.length - 1; i >= 0; --i) this.entities.array[i].preFixed(t, this.time, this, e), this.entities.array[i].tickFixed(t, this.time, this, e), this.entities.array[i].postFixed(t, this.time, this, e)
        }
        createEntity(t, e, i) {
            return (i = i || {}).id = e, new(kL(t, e))(i)
        }
        addEntity(t) {
            if (void 0 !== t && void 0 !== t.type) {
                if (!(this.entities.array.length >= 32766)) return this.isEntityInWorld(t) || this.isEntityIdTaken(t.id) ? (console.log("Error: Entity in world or entity id taken"), console.log(t), void console.log(this.getEntityById(t.id))) : (this.entities.array.push(t), this.entities.map.set(t.id, t), this.entities.type[t.type].push(t), t);
                console.log("Error: tried addint entity but we already are at the maximum")
            } else console.log("Error: tried adding an entity of unknown type to the world")
        }
        removeEntity(t) {
            if (void 0 === t) return !1;
            this.entities.map.delete(t.id);
            let e = this.entities.array.indexOf(t);
            return e > -1 && this.entities.array.splice(e, 1), (e = this.entities.type[t.type].indexOf(t)) > -1 && this.entities.type[t.type].splice(e, 1), t.onRemove(), t
        }
        isEntityIdTaken(t) {
            return this.entities.map.has(t)
        }
        isEntityIdAllowed(t) {
            return !0
        }
        isEntityInWorld(t) {
            return this.entities.array.indexOf(t) >= 0
        }
        entity(t) {
            return this.entities.map.get(t)
        }
        getEntityById(t) {
            return this.entities.map.get(t)
        }
        serialize() {
            return this.serializedData = aN.world.encode(this.data), this.serializedData
        }
        getHeight(t, e) {
            t = aL(t, 0, this.bounds), e = aL(e, 0, this.bounds);
            let i = this.chunksMap.get(Math.min(Math.floor(t / 64), this.chunkAmount - 1) + Math.min(Math.floor(e / 64), this.chunkAmount - 1) * this.chunkAmount);
            return i && i.deserialized ? i.getHeight(t >= this.bounds ? 63 : t % 64, e >= this.bounds ? 63 : e % 64) : -0
        }
        getNormal(t, e) {
            t = aL(t, 0, this.bounds), e = aL(e, 0, this.bounds);
            let i = this.chunksMap.get(Math.min(Math.floor(t / 64), this.chunkAmount - 1) + Math.min(Math.floor(e / 64), this.chunkAmount - 1) * this.chunkAmount);
            if (i && i.deserialized) {
                t = t >= this.bounds ? 63 : t % 64, e = e >= this.bounds ? 63 : e % 64;
                let s = 2 * Math.floor(t /= 2) + 32 * Math.floor(e /= 2) * 2;
                t % 1 + e % 1 > 1 && s++, s *= 3, sW(kB, i.normals[s], i.normals[s + 1], i.normals[s + 2])
            } else sW(kB, 0, 0, 0);
            return kB
        }
        clampV3(t) {
            return t[0] = aL(t[0], 0, this.bounds), t[2] = aL(t[2], 0, this.bounds), t
        }
        getChunkFromWorld(t, e) {
            return t = aL(t, 0, this.bounds), e = aL(e, 0, this.bounds), t = Math.min(Math.floor(t / 64), this.chunkAmount - 1), e = Math.min(Math.floor(e / 64), this.chunkAmount - 1), this.chunksMap.get(t + e * this.chunkAmount)
        }
        getChunk(t, e) {
            return t = aL(t, 0, this.chunkAmount), e = aL(e, 0, this.chunkAmount), this.chunksMap.get(t + e * this.chunkAmount)
        }
        setMode(t) {
            this.mode = _J[this.id] || _J[t || "normal"]
        }
        parse(t) {
            this.setMode(), t || (this.chunkAmount = this.data.chunkAmount, this.bounds = 64 * this.chunkAmount, this.setOctrees(), this.unloadedChunks.clear(), this.finishedLoadingChunks.clear(), this.currentlyLoadingChunks.clear(), this.createChunks()), this.waterAABB.length = 0, this.data.water.forEach(t => {
                let e = cr();
                0 === t.watertype ? cc(e, [0, t.pos[1] - 10, 0], this.bounds, 10, this.bounds) : cu(e, [t.pos[0], t.pos[1] - 5, t.pos[2]], t.sx, 10, t.sz), this.waterAABB.push(e)
            })
        }
        destroy() {
            this.chunksMap.forEach(t => {
                t.destroy()
            }), this.chunksMap.clear(), this.chunksArray.length = [];
            for (let t = this.entities.array.length - 1; t >= 0; t--) this.removeEntity(this.entities.array[t]);
            this.data = void 0, this.waterAABB.length = 0, this.bounds = 1, this.setOctrees()
        }
        setOctrees() {
            this.triangleGrid = new ki(this.bounds, this.bounds, this.bounds, 50, 50, 50)
        }
        rebuildTriangleOctree() {
            this.triangleGrid.clear(), this.chunksMap.forEach(t => {
                for (let e in t.props) t.props[e].forEach(e => {
                    e.loaded = !1, e.loadGeometry(this, t)
                })
            })
        }
        triangleRaycastClosest(t, e, i, s, n, a) {
            kn(ks, t, e, i, s, n, a);
            let r = 1,
                l = this.triangleGrid.queryRay(ks.origin, ks.dir, ks.invDir);
            for (let o = 0; o < l.length; ++o) {
                let c = l[o];
                r = Math.min(r, op(c[0], c[1], c[2], ks.origin, ks.dir, !1))
            }
            return r
        }
        triangleRaycastAny(t, e, i, s, n, a, r) {
            kn(ks, t, e, i, s, n, a);
            let l = this.triangleGrid.queryRay(ks.origin, ks.dir, ks.invDir);
            for (let o = 0; o < l.length; ++o) {
                let c = l[o];
                if (1 > op(c[0], c[1], c[2], ks.origin, ks.dir, r)) return !0
            }
            return !1
        }
        raycastEnvironmentClosest(t, e, i, s, n, a) {
            let r = this.triangleRaycastClosest(t, e, i, s, n, a);
            r < 1 && (s *= r, n *= r, a *= r);
            let l = 0,
                o = 0,
                c = .1;
            for (; l < 100 && o < 1;) {
                let d = o + c,
                    u = t + s * d,
                    $ = i + a * d,
                    h = e + n * d - this.getHeight(u, $);
                h < 0 ? h > -.05 ? (o += c, l = 100) : c *= .5 : o += c, l++
            }
            return Math.min(o, r, 1)
        }
        raycastEnvironmentAny(t, e, i, s, n, a, r) {
            let l = Math.sqrt(s * s + n * n + a * a),
                o = 3 / l,
                c = s * o,
                d = n * o,
                u = a * o,
                $ = t,
                h = e + r,
                m = i,
                _ = Math.floor(l / 3),
                f = 0;
            for (; f < _;)
                if (++f, $ += c, h += d, m += u, this.getHeight($, m) > h) return !0;
            return this.triangleRaycastAny(t, e, i, s, n, a, !0)
        }
        getPlayerByName(t) {
            let e = t.toLowerCase();
            return this.entities.type[0].find(t => t.name && t.name.toLowerCase() === e)
        }
        onChunkBeginLoading(t) {
            this.unloadedChunks.has(t.id) && (this.unloadedChunks.delete(t.id), this.currentlyLoadingChunks.add(t.id))
        }
        onChunkFinishLoading(t) {
            this.currentlyLoadingChunks.has(t.id) && (this.currentlyLoadingChunks.delete(t.id), this.finishedLoadingChunks.add(t.id), this.finishedLoadingChunks.size === this.chunksArray.length && this.onAllChunksFinishLoading())
        }
        onAllChunksFinishLoading() {}
        addChunk(t) {
            this.chunksMap.set(t.id, t), this.chunksArray.push(t)
        }
        removeChunk(t) {
            this.chunksMap.delete(t.id), this.chunksArray.splice(this.chunksArray.indexOf(t), 1)
        }
    }
    let kV = (t, e, i = "") => {
            tJ.update(s => (s.push({
                text: t,
                icon: e,
                css: i
            }), s))
        },
        kW = {
            2: "On cooldown.",
            3: "Can only be cast on enemy.",
            4: "Can only be cast on ally.",
            5: "Not enough mana.",
            6: "Out of range.",
            10: "Target is dead.",
            7: "Can't do that during movement.",
            8: "Can't cast while busy.",
            9: "You are incapacitated.",
            11: "Can't do that in combat.",
            12: "Can't cast this right now.",
            13: "Level difference is too big.",
            14: "Target is not in line of sight."
        },
        kH = new Map;
    kH.set(16, t => {
        if (lY("system", `You have learned ${rC.items.book[t[0]].name} Lv. ${t[1]+1}`, !0), lL(89), dY(24, 100), 0 === t[1] && dC.get(t[0]).autoSkillbar) {
            let e = sO.skillbarsettings[as.player.name].findIndex(t => -1 === t.id);
            e >= 0 && eL[e].update(e => (e.id = t[0], e))
        }
    }).set(15, t => {
        as.player.skills.add(t[0], fW(t[2]), fW(t[3]), t[1])
    }).set(17, t => {
        as.player.skills.remove(t[0])
    }).set(18, t => {
        as.player.skills.updateSkillsLearned(t)
    }).set(19, t => {
        eS.set(kS(t, 0))
    }).set(1, t => {
        ei.set({
            type: "error",
            text: kW[t[0]]
        })
    }).set(20, t => {
        as.player.setExp(t[1]);
        let e = as.entity(t[2]);
        e && ct(sV([0, 0, 0], e.visualPosition), t[0]), sO.chat[0] && lY("exp", `Gained ${t[0]} experience ${e?"from "+e.name:""}.
      ${as.player.exp}/${c_(as.player.level)}`, !0)
    }).set(21, t => {
        as.player.setExp(t[1]), lY("error", `Lost ${t[0]} experience. ${as.player.exp}/${c_(as.player.level)}`, !0)
    }).set(22, t => {
        as.player.setExp(t[0])
    }).set(45, t => {
        let e = as.entity(t[1]);
        lL(104), e && ce(sV([0, 0, 0], e.visualPosition), t[0]), sO.chat[11] && lY("fame", `Gained $fm${t[0]} fame ${e?"from "+e.name:""} (${t[2]} recent kills).`, !0)
    }).set(46, t => {
        lL(104), sO.chat[11] && lY("fame", `Gained $fm${t[0]} salary from the war.`, !0)
    }).set(47, t => {
        lL(105), sO.chat[11] && lY("fame", `War: Gained $fm${t[0]} spoils of war (Fight ${t[1]>0?"Victory!":"Loss!"}).`, !0)
    }).set(48, t => {
        lL(105), sO.chat[11] && lY("fame", `Obelisk: Captured obelisk for $fm${t[0]} and $m${t[2]}.`, !0), as.player.inventory.setMedals(t[1], t[2], 1)
    }).set(49, t => {
        ek.set(), e2.set(!1), 1 === t[0] && lY("system", "War: You have left the war due to inactivity.", !0)
    }).set(23, t => {
        let e = as.getEntityById(t[0]);
        e && e.interact(t)
    }).set(24, t => {
        es.set(void 0)
    }).set(25, t => {
        lY("system", kS(t, 0), !0)
    }).set(26, t => {
        lY("error", kS(t, 0), !0)
    }).set(51, t => {
        let e = kS(t, 1);
        $6(rC.ui.party.summon, rC.ui.party.onSummon.replace("$1", e), [{
            text: rC.ui.accept,
            nocombat: !0,
            remaining: 20,
            fun() {
                $1("summonaccept", e)
            }
        }, {
            text: rC.ui.decline,
            fun() {}
        }])
    }).set(27, t => {
        let e = kS(t, 1);
        $6(rC.ui.party.invite, rC.ui.party.onInvite.replace("$1", e), [{
            text: rC.ui.accept,
            fun() {
                $1("partyaccept", t[0] + "")
            }
        }, {
            text: rC.ui.decline,
            fun() {
                $1("partydecline", t[0] + "")
            }
        }])
    }).set(29, t => {
        as.player.inventory.setItem(t[0], t[1], t[2])
    }).set(30, t => {
        as.player.inventory.removeItem(t[0], t[1])
    }).set(31, t => {
        as.player.inventory.setGold(t[0], t[1], t[2])
    }).set(32, t => {
        as.player.inventory.setMedals(t[0], t[1], t[2])
    }).set(33, t => {
        ep.set(t[0]), bv(t[0], t[1], 12, "$sp")
    }).set(34, t => {
        eb.set(0 == t[0] ? void 0 : t[0] - 1)
    }).set(50, t => {
        ex.set(0 == t[0] ? void 0 : t[0] - 1)
    }).set(35, t => {
        eE.set(t[0]), t[0] && lL(106)
    }).set(36, t => {
        eM.set(t.pop()), kj(t, e6)
    }).set(37, t => {
        e5.update(t => !t), lY("inv", rC.ui.merchant.auctioncancel, !0)
    }).set(38, t => {
        kj(t.slice(2), eA), t[0] && lL(107), eT.set({
            gold: t[1]
        })
    }).set(39, t => {
        eT.set({
            gold: t[0]
        })
    }).set(40, t => {
        eT.set(!1)
    }).set(41, t => {
        e8.set(!0), lL(108), dY(22, 100)
    }).set(42, t => {
        e8.set(!1)
    }).set(43, t => {
        eR.set(!0)
    }).set(44, t => {
        eR.set(!1)
    }).set(53, t => {
        let e = as.entity(t[0]);
        void 0 !== e && (e.party = 1)
    }).set(54, t => {
        window.open("/pve?kill=" + t[0], "_blank")
    }).set(52, t => {
        let e = t[0];
        e < 1e3 && e > 0 && ei.set({
            type: "error",
            timer: 500,
            text: e
        }), e <= 5 && e > 0 ? lL(109) : 0 === e ? lL(110) : 1e3 === e ? lL(111) : 2e3 === e && lL(112)
    });
    let kj = (t, e) => {
            e.update(e => (e.length = 0, t.forEach(t => {
                e.push(new by(t))
            }), e))
        },
        kG = (t, e) => {
            as.player && kH.get(t)(e)
        },
        kY = new Map;
    kY.set(0, (t, e, i) => {}).set(1, (t, e, i) => {
        as.removeEntity(t)
    }).set(2, (t, e, i) => {
        e[1] > 0 && e[1] !== t.target && t.visual && t.visual.onAggro(), t === as.player && u3(e[1])
    }).set(3, (t, e, i) => {
        for (let s = 1; s < e.length; s += 2) t.stats.setResource(e[s], e[s + 1])
    }).set(6, (t, e, i) => {
        for (let s = 1; s < e.length; s += 2) t.stats.setResource(e[s], e[s + 1])
    }).set(4, (t, e, i) => {
        for (let s = 1; s < e.length; s += 2) t.stats.setStat(e[s], e[s + 1])
    }).set(5, (t, e, i) => {
        if (t == as.player && (dY(6, 100), t.skills.cd(e[1], as.time, fW(e[2])), e[5] > 0 && t.skills.globalCd(fW(e[4]), fW(e[5]))), !i && t.visual && !t.visual.inFog) {
            let s = dC.get(e[1]);
            s.castLen && t.visual.currentAnim || !s.fx.animCast || t.visual.anim(s.fx.animCast), t.visual.onEffort()
        }
    }).set(22, (t, e, i) => {
        t.skills.startTimedCast(dC.get(e[1]), fW(e[2]), e[3], fW(e[4])), e[5] > 0 && t.skills.globalCd(fW(e[2]), fW(e[5]))
    }).set(23, (t, e, i) => {
        t.skills.interruptTimedCast(!0, 1 === e[1])
    }).set(24, (t, e, i) => {
        t.skills.finishTimedCast(fW(e[1]))
    }).set(7, (t, e, i) => {
        let s = e[1],
            n = e[2],
            a = as.getEntityById(e[3]),
            r = e[4],
            l = e[5],
            o = e[6],
            c = e[7];
        void 0 !== a && 0 === sO.dpsmeterMode && oe(a, s, n);
        let d = t === as.player,
            u = a === as.player;
        d ? sO.showIncomingDamage && oX([-.3, -.3, .5], s, l, o, !0, 0) : u && oX(t.visualPosition, s, l, o, !1, 2), l > 0 && t.stats.changeResource(6, -s), c > 0 && (t.stats.refreshCombatTimer(as.time, c), a && a.stats.refreshCombatTimer(as.time, c));
        let $ = dC.get(n);
        if (!i && l > 0 && t.visual && !t.visual.inFog) {
            let h = r > 0 && mj.has(r) ? mj.get(r).effect.transform : a && a.visual && a.visual.transform,
                m = t.visual.transform;
            a && a.visual && $.fx.animImpact && a.visual.anim($.fx.animImpact, !1, t.id), 1 !== l ? (t.visual.onHurt(s / t.stats.getStat(6), l), h && kK($, h, m, t.radius, u ? 1 : 0)) : h && ($.fx.effectDirImpact || $.fx.animImpact) && kJ(13, h, m, t.radius, u ? 1 : 0)
        }
    }).set(8, (t, e, i) => {
        let s = as.getEntityById(e[3]);
        void 0 !== s && 1 === sO.dpsmeterMode && oe(s, e[1], e[2]), s && e[5] > 0 && s.stats.refreshCombatTimer(as.time, e[5]);
        let n = t === as.player,
            a = s === as.player;
        n ? sO.showIncomingHeal && oJ([.3, -.3, .5], e[1], e[4], !0, 0) : a && oJ(t.visualPosition, e[1], e[4], !1, 2), t.stats.changeResource(6, e[1]);
        let r = dC.get(e[2]);
        !i && s && s.visual && t.visual && !t.visual.inFog && kK(r, s.visual.transform, t.visual.transform, t.radius, n || a ? 1 : 0)
    }).set(9, (t, e, i) => {
        t.stats.changeResource(7, e[1]);
        let s = as.getEntityById(e[3]),
            n = t === as.player;
        n && sO.showIncomingHeal && oZ([.35, -.2, .5], e[1], e[4], !0);
        let a = dC.get(e[2]);
        !i && s && s.visual && t.visual && !t.visual.inFog && !s.visual.inFog && kK(a, s.visual.transform, t.visual.transform, t.radius, n ? 1 : 0)
    }).set(10, (t, e, i) => {
        0 == e[1] ? t.stats.alive && (t.stats.die(), t == as.player && as.mode.allowRespawn ? $6(rC.ui.death.death, rC.ui.death.deathmsg, [{
            text: rC.ui.death.respawn,
            blockedTime: Math.max(0, Math.ceil(e[2] - as.time) + 1),
            fun() {
                $1("respawn", "")
            }
        }]) : t.id == as.player.target && dY(7, 100)) : t.stats.alive || t.stats.respawn()
    }).set(11, (t, e, i) => {
        t.setFaction(e[1])
    }).set(14, (t, e, i) => {
        t.setLevel(e[1])
    }).set(16, (t, e, i) => {
        t.setClass(e[1])
    }).set(12, (t, e, i) => {
        t.setName(kS(e, 1))
    }).set(13, (t, e, i) => {
        t.setClan(e.length > 2 ? kS(e, 2) : void 0, e[1])
    }).set(15, (t, e, i) => {
        if (t.setLevel(e[1]), sO.chat[6]) {
            let s = `${t==as.player?"You":kX(e[0])} leveled up to ${e[1]}!`;
            lY("lvlup", s), t == as.player && (dY(16, 100), dC.forEach(t => {
                t.class === as.player.class && t.minlevel === e[1] && (dY(19, 100), kV(`<span class=textprimary><b class=textgreen>${rC.items.book[t.id].name}</b><br>Skill book available at the Trader!</span>`, `skills/${t.id}.${rF}`, "border primary"))
            }))
        }
        t.visual && !t.visual.inFog && mf(26, t.visual.transform, t == as.player ? 1 : 0, !1)
    }).set(17, (t, e, i) => {
        t.buffs.setBuff(e[1], e[2], e[3], fW(e[4]), fW(e[5]), e[6], e[7], e.length > 8 ? e.slice(8) : void 0)
    }).set(19, (t, e, i) => {
        e[2] === as.player.id && oK(t.visualPosition, 2, !1)
    }).set(18, (t, e, i) => {
        t.buffs.removeBuff(e[1], e[2])
    }).set(20, (t, e, i) => {
        let s = dC.get(e[1]),
            n = new aH(as.time, fW(e[4]) - as.time + .2);
        mG(e[0], e[2], s, e[3], n)
    }).set(21, (t, e, i) => {
        let s = dC.get(e[1]),
            n = e[2],
            a = fW(e[3]) - as.time,
            r = new aH(as.time, a),
            l = 4,
            o = e.length - l,
            c = o > 6 ? 2 + (o - 6) / 4 : 2,
            d = [],
            u = [];
        for (let $ = l; $ < l + 3 * c; $ += 3) d.push([fq(e[$], 6400), fq(e[$ + 1], 6400), fq(e[$ + 2], 6400)]);
        if (c > 2)
            for (let h = l + 3 * c; h < e.length; ++h) u.push(e[h] / 65535);
        mY(t.id, d, u, s, n, r)
    }).set(25, (t, e, i) => {
        t.setParty(e[1], e[2])
    }).set(26, (t, e, i) => {
        !1 === t.hasInfo && t.setDropInfo(e[1], e[2], e[3], e[4], e[5])
    }).set(27, (t, e, i) => {
        t.setNodeInfo(e[1], e[2], e[3])
    }).set(28, (t, e, i) => {
        t.setPosLock(e[1], e[2], e[3])
    });
    let kQ = (t, e, i) => {
            let s = as.getEntityById(e[0]);
            void 0 === s || kY.get(t)(s, e, i)
        },
        kX = t => {
            let e = as.getEntityById(t);
            return "" + (t > 0 ? e ? e.name : "unknown" : "nobody")
        },
        kJ = (t, e, i, s, n) => {
            let a = mf(t, nT(), n, !0);
            nM(a.transform, i, e, s), nE(a.transform, !1)
        },
        kK = (t, e, i, s, n) => {
            if (t.fx.effectDirImpact && kJ(t.fx.effectDirImpact, e, i, s, n), t.fx.effectImpact) {
                let a = mf(t.fx.effectImpact, nT(), n, !0);
                sV(a.transform.position, i.position), nE(a.transform, !1)
            }
            t.fx.effectTarget && mf(t.fx.effectTarget, i, n, !1)
        },
        kZ = [es, eE, eT, eR, e8],
        Ct = [tZ, e6, ee],
        Ce = [ec, ed],
        Ci = () => {
            Ce.forEach(t => t.update(t => (t.visible = !1, t))), tK.update(t => (t.membercount = 0, t.role = 0, sO.partyinfo = t, t)), kZ.forEach(t => t.set()), Ct.forEach(t => t.set([]))
        };
    class Cs extends kq {
        constructor(t) {
            super(t), this.smoothtime = 0, this.loading = !1, this.mapinfo = {
                icons: []
            }, this.playerId = 0, this.removePlayer(), this.netTimeoutTimer = new aH, this.party = new Map, this.partyIterator = 0, this.chunkviewrange = 0, this.chunkCache = [], rf("close", () => {
                this.onDisconnect()
            }), this.netData = [], rf(aF.serverEntityDelta.header, t => {
                this.netData.push(aF.serverEntityDelta.decode(t))
            }), this.chatData = [], rf(aF.serverChat.header, t => {
                this.chatData.push(t)
            }), this.systemMessageData = [], rf(aF.serverSystemMessage.header, t => {
                this.systemMessageData.push(t)
            }), this.partyData = void 0, rf(aF.serverPartyUpdate.header, t => {
                this.partyData = t
            }), rf(aF.serverPartyPositions.header, t => {
                t = aF.serverPartyPositions.decode(t).members, this.party.forEach(e => {
                    let i = t.find(t => t.entityid === e.id);
                    i && (e.pos[0] = i.pos[0], e.pos[1] = i.pos[1])
                })
            }), rf(aF.serverWarUpdate.header, t => {
                ek.update(e => {
                    let i = aF.serverWarUpdate.decode(t);
                    return void 0 === e || 0 === i.contributors.length && (i.contributors = e.contributors), i
                })
            }), rf(aF.serverMapUpdate.header, t => {
                this.mapinfo = aF.serverMapUpdate.decode(t)
            }), rf(aF.ping.header, t => {
                rx(aF.ping.decode(t))
            }), rf(aF.serverChangeWorld.header, t => {
                eB.set(aF.serverChangeWorld.decode(t).world)
            })
        }
        handlePartyData(t) {
            let e;
            this.party.forEach(t => {
                t.found = !1
            }), (t = aF.serverPartyUpdate.decode(t)).members.forEach(t => {
                if (this.party.has(t.name)) {
                    let i = this.party.get(t.name);
                    t.entityid !== this.player.id && (i.local = t.world === this.id, i.unitStore.update(e => (e.id = t.entityid, e.name = t.name, e.level = t.level, e.class = t.class, e.world = t.world, e.party = this.player.party, e.faction = this.player.faction, e.role = t.role, e))), i.id = t.entityid, i.found = !0
                } else this.party.set(t.name, {
                    id: t.entityid,
                    found: !0,
                    pos: [0, 0],
                    local: t.world === this.id,
                    name: t.name,
                    buffStore: t.entityid == this.player.id ? e$ : tX([]),
                    unitStore: t.entityid == this.player.id ? ec : tX({
                        id: t.entityid,
                        name: t.name,
                        level: t.level,
                        class: t.class,
                        world: t.world,
                        role: t.role,
                        party: this.player.party,
                        faction: this.player.faction,
                        type: 0,
                        visible: !0,
                        alive: !0,
                        powertype: !1,
                        range: !1
                    })
                });
                t.entityid == this.player.id && (e = t)
            }), this.party.forEach((t, e) => {
                t.found || this.party.delete(e)
            }), tZ.set(Array.from(this.party.values()).filter(t => sO.showSelfInParty || t.id != this.player.id)), e ? tK.update(i => (i.membercount = t.members.length, i.role = e.role, i.queues = t.queues, sO.partyinfo = i, i)) : tK.update(t => (t.membercount = 0, t.role = 0, t.queues = [], sO.partyinfo = t, t))
        }
        handleChatData(t) {
            t.forEach(t => {
                (t = aF.serverChat.decode(t)).messages.forEach(t => {
                    if ("" == t.from) {
                        let e = t.message.split(" ");
                        rC && rC.ui.messages[e[0]] && (t.message = rC.ui.messages[e[0]], e.splice(1).forEach((e, i) => {
                            t.message = t.message.replace("$" + (i + 1), e)
                        })), t.channel = "notice"
                    } else if (sO.chatbubbles) {
                        let i = "to" == t.channel ? this.player.name : t.from,
                            s = this.getPlayerByName(i);
                        if (s) {
                            let n;
                            switch (t.channel) {
                                case "from":
                                case "to":
                                    n = oq.chatWhisper;
                                    break;
                                case "clan":
                                    n = oq.chatClan;
                                    break;
                                case "party":
                                    n = oq.chatParty;
                                    break;
                                default:
                                    n = oq.chatGlobal
                            }
                            s.speech(i + ": " + t.message, n)
                        }
                    }
                    "GM" === t.clan && "global" === t.channel && (t.channel = "GM"), lY(t.channel, t.message, "system" == t.channel || "notice" == t.channel, t.from, t.faction, t.class, t.level, t.subscribed, t.id)
                })
            })
        }
        handleSystemMessageData(t) {
            t.forEach(t => {
                (t = aF.serverSystemMessage.decode(t)).messages.forEach(t => {
                    lY(t.type, t.message, !0)
                })
            })
        }
        handleEntityCreation(t) {
            for (let e = 0, i = t.log.length; e < i; ++e) {
                let s = t.log[e];
                0 === s.type && (this.isEntityIdTaken(s.data[0]) || this.addEntity(this.createEntity(s.data[1], s.data[0], {
                    creature: f.get(s.data[2])
                })))
            }
        }
        handleEntityInput(t) {
            for (let e = 0; e < t.inputs.length; ++e) {
                let i = t.inputs[e],
                    s = this.entity(i.id);
                void 0 !== s && (nW(s.steer, i.steer), s.setRot(i.rot, !0), s.setJump(i.jump), s.setSpeed(i.speed))
            }
        }
        handleEntityMovements(t) {
            for (let e = 0; e < t.movements.length; ++e) {
                let i = t.movements[e],
                    s = this.entity(i.id);
                if (void 0 !== s) {
                    let n = t.inputs[e];
                    s.handleMovementData(i, n)
                }
            }
        }
        handleEntityLog(t) {
            for (let e = 0, i = t.log.length; e < i; ++e) kQ(t.log[e].type, t.log[e].data, !1)
        }
        handlePersonalLog(t) {
            for (let e = 0, i = t.logPersonal.length; e < i; ++e) kG(t.logPersonal[e].type, t.logPersonal[e].data)
        }
        pollNetData(t) {
            let e = this.netData[0];
            if (void 0 !== e) return Math.abs(e.tickId - t) > 1 && (t = this.setTimeFromTickId(e.tickId)), e.tickId <= t ? (this.netData.shift(), e) : void 0
        }
        tickFixed(t, e) {
            let i = this.pollNetData(e);
            void 0 !== i && (this.handleEntityCreation(i), this.handleEntityInput(i)), this.loading || super.tickFixed(t), void 0 !== i && (this.handleEntityLog(i), this.handlePersonalLog(i), this.handleEntityMovements(i)), this.handleNetTimeouts()
        }
        tick(t) {
            for (this.netData.length > 5 && (this.accum += (this.netData.length - 5) * this.timestep), t = Math.min(t, 1), this.accum += t; this.accum > this.timestep;) this.accum -= this.timestep, this.setTimeFromTickId(this.tickId + 1), this.tickFixed(this.timestep, this.tickId);
            this.tickDelta(t, this.accum), this.setSmoothTime(t), this.handleMiscNetData(), this.loading || rb(this.time), this.manageChunks(t)
        }
        handleNetTimeouts() {
            if (this.player && (this.netTimeoutTimer.done(this.time) || this.time < this.netTimeoutTimer.start)) {
                this.netTimeoutTimer.reset(this.time - .5, 1);
                for (let t = this.entities.array.length - 1; t >= 0; t--) {
                    let e = this.entities.array[t];
                    e != this.player && (1e4 > sK(e.pos, this.player.pos) ? e.netDeletion.reset(this.time, 2) : e.netDeletion.end > 0 && e.netDeletion.done(this.time) && (this.removeEntity(e), e.id == this.player.target && this.player.setTarget(0)))
                }
            }
        }
        handleMiscNetData() {
            if (this.player && (this.partyData && (this.handlePartyData(this.partyData), this.partyData = void 0), this.chatData.length && (this.handleChatData(this.chatData), this.chatData.length = 0), this.systemMessageData.length && (this.handleSystemMessageData(this.systemMessageData), this.systemMessageData.length = 0), this.player.party > 0)) {
                if (sO.partyBuffLimitUpdateRate) {
                    let t = Array.from(this.party.values())[this.partyIterator++ % this.party.size];
                    if (t) {
                        let e = this.entity(t.id);
                        void 0 !== e && e.id !== this.player.id && (e.buffDisplayDirty = !0)
                    }
                } else this.entities.type[0].forEach(t => {
                    t.party === this.player.party && (t.buffDisplayDirty = !0)
                })
            }
        }
        removeEntity(t) {
            let e = super.removeEntity(t);
            if (e && !this.loading) {
                let i = this.party.get(e.name);
                void 0 !== i && (i.unitStore.update(t => (t.timedSkill = void 0, t.timedCast = void 0, t.alive = !0, t.range = !1, t.mp = t.hp = t.hpMax = t.mpMax = 0, t)), i.buffStore.set([]))
            }
            return e
        }
        load(t, e, i) {
            super.load(t, e), this.playerId = i, el.set("1%  " + t), this.loading = !0, lY("log", "Entering " + (t.charAt(0).toUpperCase() + t.slice(1)))
        }
        parse(t) {
            super.parse(t), _z(this, !t)
        }
        onDisconnect() {
            this.netData.length = 0, this.partyData = void 0, this.party.clear(), this.loading = !0
        }
        destroy() {
            this.loading = !0, super.destroy(), _O(), wV(this)
        }
        setPlayer(t) {
            Object.assign(window.ha, {
                world: as,
                me: t,
                coder: aF,
                ws: rr,
                send: rp
            }), this.player = t, ew.set(!0), Ci()
        }
        removePlayer(t) {
            this.player == t && (this.player = void 0, this.playerId = 0, ew.set(!1), ek.set(), e2.set(!1), this.mapinfo.icons.length = 0)
        }
        setSmoothTime(t) {
            let e = this.smoothtime - this.time;
            Math.abs(e) > 1 ? this.smoothtime = this.time : this.smoothtime += e > .05 ? .5 * t : e < -.05 ? 2 * t : t
        }
        onChunkFinishLoading(t) {
            if (super.onChunkFinishLoading(t), this.loading) {
                if (0 == this.currentlyLoadingChunks.size) el.set(!1), this.loading = !1, ei.set({
                    type: "area",
                    text: this.file.replace(/_/g, " "),
                    time: 5e3
                }), wq(this);
                else {
                    let e = this.finishedLoadingChunks.size + this.currentlyLoadingChunks.size;
                    el.set(Math.max(1, Math.round(this.finishedLoadingChunks.size / e * 100)) + "%  " + this.id)
                }
            }
        }
        createChunks() {}
        createCachedChunk(t, e, i) {
            if (this.chunkCache.length) {
                let s = this.chunkCache.pop();
                return s.init(t, e, i, this), s
            } {
                let n = new ke;
                return n.init(t, e, i, this), n
            }
        }
        returnCachedChunk(t) {
            this.chunkCache.push(t)
        }
        manageChunks(t) {
            if (!this.player) return;
            this.chunkviewrange += (_8 - this.chunkviewrange) * t;
            let e = Math.max(0, Math.min(this.chunkAmount, Math.floor((this.player.pos[0] - this.chunkviewrange) / 64) - 1)),
                i = Math.max(0, Math.min(this.chunkAmount, Math.ceil((this.player.pos[0] + this.chunkviewrange) / 64) + 1)),
                s = Math.max(0, Math.min(this.chunkAmount, Math.ceil((this.player.pos[2] + this.chunkviewrange) / 64) + 1)),
                n = Math.max(0, Math.min(this.chunkAmount, Math.floor((this.player.pos[2] - this.chunkviewrange) / 64) - 1));
            for (let a = e; a < i; ++a)
                for (let r = n; r < s; ++r) {
                    let l = this.chunkAmount * r + a;
                    if (!this.chunksMap.has(l)) {
                        let o = this.createCachedChunk(l, a, r, this);
                        this.addChunk(o), this.unloadedChunks.add(o.id), o.state = 1
                    }
                }
            for (let c = this.chunksArray.length - 1; c >= 0; c--) {
                let d = this.chunksArray[c];
                (d.x + 5 < e || d.z + 5 < n || d.x - 5 > i || d.z - 5 > s) && (this.returnCachedChunk(d), this.removeChunk(d), d.destroy())
            }
        }
    }
    let Cn = async t => {
        let e = await fetch("api/user/join", {
                method: "POST",
                body: JSON.stringify({
                    id: t
                })
            }),
            i = await e.json();
        if (!i.world) throw eB.set(void 0), eq.set(void 0), i.result || "Unknown Error";
        return eB.set(i.world), eq.set(t), !0
    }, Ca = 0, Cr = !1, Cl = new aH(0, 2e4), Co = 2, Cc = t => {
        Cl.done(t) && (t > 1e5 && !Cr && t - Ca > 18e4 ? (Cr = !0, Ca = t, eD.set(Co), Co++) : Cr && (Cr = !1, eD.set(0)), Cl.reset(t))
    }, Cd = {
        guardstone: {
            port: 5002
        },
        headless: {
            port: 5003
        },
        faivel: {
            port: 5004
        },
        arena3v3: {
            port: 5006
        },
        arena5v5: {
            port: 5007
        },
        dev: {
            port: 5008
        }
    }, Cu = t => {
        console.log("Connecting to " + sO.activeWorld), t && el.set("Connecting  " + sO.activeWorld), rg(Cd[sO.activeWorld].port)
    }, C$ = t => {
        as.load(t.world, t.file, t.playerId), as.setTimeFromTickId(t.tickId), Ch = 0
    }, Ch = 0, Cm = async t => {
        if (4002 === t) el.set("Connecting  " + sO.activeWorld), as.destroy();
        else try {
            if (el.set(`Connection Problem (${t})  ` + sO.activeWorld), 1006 === t && ++Ch >= 5 || t >= 4008) throw !0;
            as.destroy(), await new Promise(t => setTimeout(t, 2e3 + 2e3 * Math.random())), await Cn(sO.lastConnectedChar)
        } catch (e) {
            return window.location.href = "/", !1
        }
        Cu(!1)
    }, C_ = (t, e) => {
        ap(e), wK(t, e, as.loading), Cc(e), as && as.player ? (ok(), wO(t), as.tick(t), wL(t), wB(t, as), _U(t, as), _I()) : as && as.tick(t)
    };
    window.onload = async () => {
        console.log("Hordes 0.42.5699 Live");
        let t = await fetch("data/game/game.json?v=5699699");
        w(await t.json()), o3(), _F(), wz(), rc(C$, Cm), a_(new Cs({})), Cu(!0), Cp()
    };
    let Cf = 0,
        Cp = () => {
            let t = ra(),
                e = (t - (Cf || 1e3 / 60)) / 1e3;
            Cf = t, C_(e, t), requestAnimationFrame(Cp)
        }
}();
